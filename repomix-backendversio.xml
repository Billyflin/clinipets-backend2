This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/build/**, **/target/**, **/.gradle/**, **/.idea/**, **/.git/**, **/*.jar, **/*.class, **/mvnw*, firebase-service-account.json
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
gradle/
  wrapper/
    gradle-wrapper.properties
src/
  main/
    kotlin/
      cl/
        clinipets/
          agendamiento/
            api/
              BloqueoController.kt
              DisponibilidadController.kt
              DisponibilidadDtos.kt
              GestionAgendaController.kt
              ReservaController.kt
              ReservaDtos.kt
            application/
              BloqueoService.kt
              DisponibilidadService.kt
              GestionAgendaService.kt
              PricingCalculator.kt
              ReservaEventListener.kt
              ReservaService.kt
            domain/
              events/
                AgendamientoEvents.kt
              BloqueoAgenda.kt
              BloqueoAgendaRepository.kt
              Cita.kt
              CitaRepository.kt
              ClinicalValidator.kt
              DetalleCita.kt
              EstadoCita.kt
              HorarioClinica.kt
              OrigenCita.kt
              TipoAtencion.kt
            scheduler/
              RecordatorioScheduler.kt
          core/
            api/
              DashboardController.kt
              PingController.kt
            config/
              AdminProperties.kt
              ClinicProperties.kt
              DataSeeder.kt
              FirebaseConfig.kt
              MetaProperties.kt
              TimeConfig.kt
            domain/
              AuditableEntity.kt
            notifications/
              NotificationService.kt
            scheduler/
              DataCleanupScheduler.kt
            security/
              FirebaseFilter.kt
              JwtPayload.kt
              SecurityConfig.kt
            storage/
              MinioConfig.kt
              StorageService.kt
            web/
              ApiError.kt
              ConflictException.kt
              DomainExceptions.kt
              RestExceptionHandler.kt
          identity/
            api/
              AuthController.kt
              AuthDtos.kt
              DeviceTokenController.kt
            application/
              AccountMergeService.kt
              AuthService.kt
            domain/
              AuthProvider.kt
              User.kt
              UserRepository.kt
              UserRole.kt
          maestros/
            api/
              MaestrosController.kt
            application/
              RazasService.kt
          servicios/
            api/
              InventarioController.kt
              ServicioDtos.kt
              ServicioMedicoController.kt
            application/
              InventarioReportService.kt
              InventarioService.kt
              PromoEngineService.kt
              ServicioMedicoService.kt
            domain/
              CategoriaServicio.kt
              Insumo.kt
              InsumoRepository.kt
              Promocion.kt
              ReglaPrecio.kt
              ServicioInsumo.kt
              ServicioInsumoRepository.kt
              ServicioMedico.kt
              ServicioMedicoRepository.kt
          veterinaria/
            api/
              HistorialController.kt
              MascotaController.kt
              MascotaDtos.kt
              ReporteController.kt
            application/
              MascotaService.kt
            domain/
              Especie.kt
              Mascota.kt
              MascotaEnums.kt
              MascotaRepository.kt
              PlanPreventivo.kt
              PlanPreventivoRepository.kt
              SignosVitales.kt
              SignosVitalesRepository.kt
            galeria/
              api/
                GaleriaController.kt
                GaleriaDtos.kt
              application/
                GaleriaService.kt
              domain/
                MascotaMedia.kt
                MascotaMediaRepository.kt
            historial/
              api/
                FichaClinicaController.kt
                HistorialDtos.kt
              application/
                FichaClinicaService.kt
                HistorialClinicoService.kt
                PdfService.kt
              domain/
                FichaClinica.kt
                FichaClinicaRepository.kt
          ClinipetsApplication.kt
    resources/
      static/
        google-login.html
        index.html
        privacy.html
      application-dev.properties
      application-prod.properties
      application.properties
      banner.txt
      logback-spring.xml
      logopastel.svg
  test/
    kotlin/
      cl/
        clinipets/
          backend/
            agendamiento/
              api/
                ReservaDtosTest.kt
              application/
                ClinipetsIntegrityTests.kt
                ReservaServiceTest.kt
                TransactionalQAValidation.kt
              domain/
                ClinicalValidatorTest.kt
                PricingCalculatorTest.kt
            veterinaria/
              application/
                MascotaServiceTest.kt
          core/
            api/
              InstantSerializationTest.kt
            web/
              DomainExceptionsTest.kt
    resources/
      mockito-extensions/
        org.mockito.plugins.MockMaker
      application-test.properties
      application.properties
.dockerignore
.env.example
.gitattributes
.gitignore
build.gradle.kts
docker-compose.yml
Dockerfile
env
gradle.properties
gradlew
gradlew.bat
README.md
settings.gradle.kts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/main/kotlin/cl/clinipets/agendamiento/api/GestionAgendaController.kt">
package cl.clinipets.agendamiento.api

import cl.clinipets.agendamiento.application.GestionAgendaService
import cl.clinipets.core.security.JwtPayload
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.security.SecurityRequirement
import io.swagger.v3.oas.annotations.tags.Tag
import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.web.bind.annotation.*
import java.util.UUID

@RestController
@RequestMapping("/api/v1/gestion-agenda")
@PreAuthorize("hasAnyRole('STAFF', 'ADMIN')")
@SecurityRequirement(name = "bearer-jwt")
@Tag(name = "Gesti√≥n de Agenda", description = "Endpoints para gesti√≥n avanzada del flujo de atenci√≥n")
class GestionAgendaController(
    private val gestionService: GestionAgendaService
) {

    @PatchMapping("/{citaId}/iniciar-atencion")
    @Operation(summary = "Inicia la atenci√≥n del paciente en el box")
    fun iniciarAtencion(
        @PathVariable citaId: UUID,
        @AuthenticationPrincipal staff: JwtPayload
    ): CitaDetalladaResponse {
        val cita = gestionService.iniciarAtencion(citaId, staff)
        return cita.toDetalladaResponse()
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/application/GestionAgendaService.kt">
package cl.clinipets.agendamiento.application

import cl.clinipets.agendamiento.domain.Cita
import cl.clinipets.agendamiento.domain.CitaRepository
import cl.clinipets.agendamiento.domain.EstadoCita
import cl.clinipets.core.security.JwtPayload
import cl.clinipets.core.web.NotFoundException
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.util.UUID

@Service
class GestionAgendaService(
    private val citaRepository: CitaRepository
) {
    private val logger = LoggerFactory.getLogger(GestionAgendaService::class.java)

    @Transactional
    fun iniciarAtencion(citaId: UUID, staff: JwtPayload): Cita {
        logger.info("[INICIAR_ATENCION] Iniciando atenci√≥n de cita $citaId por ${staff.email}")
        val cita = citaRepository.findById(citaId)
            .orElseThrow { NotFoundException("Cita no encontrada: $citaId") }

        cita.cambiarEstado(EstadoCita.EN_ATENCION, staff.email)
        val resultado = citaRepository.save(cita)
        
        logger.info("[INICIAR_ATENCION] Cita $citaId marcada como EN_ATENCION")
        return resultado
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/application/ReservaEventListener.kt">
package cl.clinipets.agendamiento.application

import cl.clinipets.agendamiento.domain.CitaRepository
import cl.clinipets.agendamiento.domain.events.ReservaCanceladaEvent
import cl.clinipets.agendamiento.domain.events.ReservaConfirmadaEvent
import cl.clinipets.agendamiento.domain.events.ReservaCreadaEvent
import cl.clinipets.core.notifications.NotificationService
import org.slf4j.LoggerFactory
import org.springframework.context.event.EventListener
import org.springframework.scheduling.annotation.Async
import org.springframework.stereotype.Component
import java.time.ZoneId
import java.time.format.DateTimeFormatter

@Component
class ReservaEventListener(
    private val citaRepository: CitaRepository,
    private val notificationService: NotificationService,
    private val clinicZoneId: ZoneId
) {
    private val logger = LoggerFactory.getLogger(ReservaEventListener::class.java)
    private val dateFormatter = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm")

    @Async
    @EventListener
    fun onReservaCreada(event: ReservaCreadaEvent) {
        logger.info("[EVENT] ReservaCreada: ${event.citaId}")

        val cita = citaRepository.findById(event.citaId).orElse(null) ?: return
        val fechaFormateada = cita.fechaHoraInicio
            .atZone(clinicZoneId)
            .format(dateFormatter)

        notificationService.enviarNotificacion(
            userId = cita.tutorId,
            titulo = "‚úÖ Reserva confirmada",
            cuerpo = "Tu cita est√° agendada para el $fechaFormateada",
            data = mapOf(
                "type" to "reserva_creada",
                "citaId" to cita.id.toString()
            )
        )
    }

    @Async
    @EventListener
    fun onReservaCancelada(event: ReservaCanceladaEvent) {
        logger.info("[EVENT] ReservaCancelada: ${event.citaId}")

        val cita = citaRepository.findById(event.citaId).orElse(null) ?: return

        notificationService.enviarNotificacion(
            userId = cita.tutorId,
            titulo = "‚ùå Cita cancelada",
            cuerpo = "Tu cita ha sido cancelada. ${event.motivo}",
            data = mapOf(
                "type" to "reserva_cancelada",
                "citaId" to cita.id.toString()
            )
        )
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/scheduler/RecordatorioScheduler.kt">
package cl.clinipets.agendamiento.scheduler

import cl.clinipets.agendamiento.domain.CitaRepository
import cl.clinipets.agendamiento.domain.EstadoCita
import cl.clinipets.core.notifications.NotificationService
import org.slf4j.LoggerFactory
import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Component
import java.time.Instant
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import java.time.temporal.ChronoUnit

@Component
class RecordatorioScheduler(
    private val citaRepository: CitaRepository,
    private val notificationService: NotificationService,
    private val clinicZoneId: ZoneId
) {
    private val logger = LoggerFactory.getLogger(RecordatorioScheduler::class.java)
    private val dateFormatter = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm")

    /**
     * Env√≠a recordatorio 24 horas antes de cada cita
     * Cron: Ejecuta todos los d√≠as a las 9:00 AM
     */
    @Scheduled(cron = "0 0 9 * * *")
    fun enviarRecordatoriosDiarios() {
        logger.info("[SCHEDULER] Iniciando env√≠o de recordatorios diarios")

        val ahora = Instant.now()
        val en24Horas = ahora.plus(24, ChronoUnit.HOURS)
        val en25Horas = en24Horas.plus(1, ChronoUnit.HOURS)

        // Buscar citas entre 24-25 horas desde ahora
        val citas = citaRepository.findAllByFechaHoraInicioBetweenOrderByFechaHoraInicioAsc(
            en24Horas,
            en25Horas
        ).filter { it.estado == EstadoCita.CONFIRMADA }

        logger.info("[SCHEDULER] Encontradas ${citas.size} citas para recordatorio")

        citas.forEach { cita ->
            val fechaFormateada = cita.fechaHoraInicio
                .atZone(clinicZoneId)
                .format(dateFormatter)

            notificationService.enviarNotificacion(
                userId = cita.tutorId,
                titulo = "‚è∞ Recordatorio de cita",
                cuerpo = "Tu cita es ma√±ana a las $fechaFormateada. ¬°No faltes!",
                data = mapOf(
                    "type" to "recordatorio_24h",
                    "citaId" to cita.id.toString()
                )
            )
        }
    }

    /**
     * Env√≠a recordatorio 1 hora antes de cada cita
     * Cron: Ejecuta cada hora
     */
    @Scheduled(cron = "0 0 * * * *")
    fun enviarRecordatoriosUrgentes() {
        logger.info("[SCHEDULER] Iniciando recordatorios de 1 hora")

        val ahora = Instant.now()
        val en1Hora = ahora.plus(1, ChronoUnit.HOURS)
        val en90Minutos = en1Hora.plus(30, ChronoUnit.MINUTES)

        val citas = citaRepository.findAllByFechaHoraInicioBetweenOrderByFechaHoraInicioAsc(
            en1Hora,
            en90Minutos
        ).filter { it.estado == EstadoCita.CONFIRMADA }

        logger.info("[SCHEDULER] Encontradas ${citas.size} citas pr√≥ximas")

        citas.forEach { cita ->
            val fechaFormateada = cita.fechaHoraInicio
                .atZone(clinicZoneId)
                .format(dateFormatter)

            notificationService.enviarNotificacion(
                userId = cita.tutorId,
                titulo = "üîî Tu cita es pronto",
                cuerpo = "Tu cita es en 1 hora ($fechaFormateada). Te esperamos!",
                data = mapOf(
                    "type" to "recordatorio_1h",
                    "citaId" to cita.id.toString()
                )
            )
        }
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/api/DashboardController.kt">
package cl.clinipets.core.api

import cl.clinipets.agendamiento.domain.CitaRepository
import cl.clinipets.agendamiento.domain.EstadoCita
import cl.clinipets.veterinaria.domain.MascotaRepository
import cl.clinipets.identity.domain.UserRepository
import cl.clinipets.identity.domain.UserRole
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.security.SecurityRequirement
import io.swagger.v3.oas.annotations.tags.Tag
import org.springframework.http.ResponseEntity
import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId
import java.time.temporal.ChronoUnit

data class EstadisticasResponse(
    val totalClientes: Long,
    val totalMascotas: Long,
    val citasHoy: Int,
    val citasSemana: Int,
    val citasMes: Int,
    val ingresosMes: Int,
    val topServicios: List<ServicioPopular>
)

data class ServicioPopular(
    val nombre: String,
    val cantidad: Int
)

@RestController
@RequestMapping("/api/v1/dashboard")
@PreAuthorize("hasAnyRole('STAFF', 'ADMIN')")
@SecurityRequirement(name = "bearer-jwt")
@Tag(name = "Dashboard", description = "Estad√≠sticas generales del sistema")
class DashboardController(
    private val citaRepository: CitaRepository,
    private val mascotaRepository: MascotaRepository,
    private val userRepository: UserRepository,
    private val clinicZoneId: ZoneId
) {

    @Operation(summary = "Obtener estad√≠sticas generales")
    @GetMapping("/estadisticas")
    fun obtenerEstadisticas(): ResponseEntity<EstadisticasResponse> {
        val ahora = Instant.now()
        val hoy = LocalDate.now(clinicZoneId)

        // Contadores b√°sicos
        val totalClientes = userRepository.findAllByRoleIn(listOf(UserRole.CLIENT)).size.toLong()
        val totalMascotas = mascotaRepository.count()

        // Citas por per√≠odo
        val inicioHoy = hoy.atStartOfDay(clinicZoneId).toInstant()
        val finHoy = hoy.plusDays(1).atStartOfDay(clinicZoneId).toInstant()

        val citasHoy = citaRepository.findAllByFechaHoraInicioBetweenOrderByFechaHoraInicioAsc(
            inicioHoy, finHoy
        ).count()

        val hace7Dias = ahora.minus(7, ChronoUnit.DAYS)
        val citasSemana = citaRepository.findAllByFechaHoraInicioBetweenOrderByFechaHoraInicioAsc(
            hace7Dias, ahora
        ).count()

        val hace30Dias = ahora.minus(30, ChronoUnit.DAYS)
        val citasMes = citaRepository.findAllByFechaHoraInicioBetweenOrderByFechaHoraInicioAsc(
            hace30Dias, ahora
        )

        val ingresosMes = citasMes
            .filter { it.estado == EstadoCita.FINALIZADA }
            .sumOf { it.precioFinal }

        // Top servicios del mes
        val topServicios = citasMes
            .flatMap { it.detalles }
            .groupingBy { it.servicio.nombre }
            .eachCount()
            .toList()
            .sortedByDescending { it.second }
            .take(5)
            .map { ServicioPopular(it.first, it.second) }

        return ResponseEntity.ok(
            EstadisticasResponse(
                totalClientes = totalClientes,
                totalMascotas = totalMascotas,
                citasHoy = citasHoy,
                citasSemana = citasSemana,
                citasMes = citasMes.size,
                ingresosMes = ingresosMes,
                topServicios = topServicios
            )
        )
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/notifications/NotificationService.kt">
package cl.clinipets.core.notifications

import cl.clinipets.identity.domain.UserRepository
import com.google.firebase.messaging.FirebaseMessaging
import com.google.firebase.messaging.Message
import com.google.firebase.messaging.Notification
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import java.util.UUID

@Service
class NotificationService(
    private val userRepository: UserRepository
) {
    private val logger = LoggerFactory.getLogger(NotificationService::class.java)

    /**
     * Env√≠a notificaci√≥n push a un usuario espec√≠fico
     */
    fun enviarNotificacion(
        userId: UUID,
        titulo: String,
        cuerpo: String,
        data: Map<String, String> = emptyMap()
    ) {
        try {
            val user = userRepository.findById(userId).orElse(null) ?: run {
                logger.warn("[PUSH] Usuario $userId no encontrado")
                return
            }

            if (user.fcmToken.isNullOrBlank()) {
                logger.debug("[PUSH] Usuario ${user.email} sin token FCM")
                return
            }

            val message = Message.builder()
                .setToken(user.fcmToken)
                .setNotification(
                    Notification.builder()
                        .setTitle(titulo)
                        .setBody(cuerpo)
                        .build()
                )
                .putAllData(data)
                .build()

            val response = FirebaseMessaging.getInstance().send(message)
            logger.info("[PUSH] Enviada a ${user.email}: $response")
        } catch (ex: Exception) {
            logger.error("[PUSH] Error enviando notificaci√≥n a $userId", ex)
        }
    }

    /**
     * Env√≠a notificaci√≥n a m√∫ltiples usuarios
     */
    fun enviarNotificacionMasiva(
        userIds: List<UUID>,
        titulo: String,
        cuerpo: String,
        data: Map<String, String> = emptyMap()
    ) {
        logger.info("[PUSH] Enviando notificaci√≥n masiva a ${userIds.size} usuarios")
        userIds.forEach { userId ->
            enviarNotificacion(userId, titulo, cuerpo, data)
        }
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/scheduler/DataCleanupScheduler.kt">
package cl.clinipets.core.scheduler

import cl.clinipets.agendamiento.domain.CitaRepository
import cl.clinipets.agendamiento.domain.EstadoCita
import org.slf4j.LoggerFactory
import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Component
import org.springframework.transaction.annotation.Transactional
import java.time.Instant
import java.time.temporal.ChronoUnit

@Component
class DataCleanupScheduler(
    private val citaRepository: CitaRepository
) {
    private val logger = LoggerFactory.getLogger(DataCleanupScheduler::class.java)

    /**
     * Cancela autom√°ticamente citas CONFIRMADAS que pasaron hace m√°s de 2 horas
     * Cron: Ejecuta cada 30 minutos
     */
    @Scheduled(cron = "0 */30 * * * *")
    @Transactional
    fun cancelarCitasExpiradas() {
        logger.info("[CLEANUP] Buscando citas expiradas...")

        val hace2Horas = Instant.now().minus(2, ChronoUnit.HOURS)

        val citasExpiradas = citaRepository.findByEstadoAndCreatedAtBefore(
            EstadoCita.CONFIRMADA,
            hace2Horas
        ).filter { 
            it.fechaHoraFin < Instant.now().minus(2, ChronoUnit.HOURS)
        }

        if (citasExpiradas.isEmpty()) {
            logger.debug("[CLEANUP] No hay citas expiradas")
            return
        }

        logger.warn("[CLEANUP] Marcando ${citasExpiradas.size} citas expiradas como NO_ASISTIO")

        citasExpiradas.forEach { cita ->
            cita.estado = EstadoCita.NO_ASISTIO // ‚Üê Cambiar de CANCELADA a NO_ASISTIO
            citaRepository.save(cita)
            logger.info("[CLEANUP] Cita ${cita.id} marcada como NO_ASISTIO autom√°ticamente")
        }
    }

    /**
     * Elimina tokens FCM inv√°lidos cada semana
     * Cron: Domingos a las 3:00 AM
     */
    @Scheduled(cron = "0 0 3 * * SUN")
    @Transactional
    fun limpiarTokensInvalidos() {
        logger.info("[CLEANUP] Limpieza de tokens FCM (placeholder)")
        // TODO: Implementar l√≥gica para detectar tokens inv√°lidos
        // Requiere tracking de errores de Firebase
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/api/HistorialController.kt">
package cl.clinipets.veterinaria.api

import cl.clinipets.core.security.JwtPayload
import cl.clinipets.veterinaria.historial.application.HistorialClinicoService
import cl.clinipets.veterinaria.historial.application.HistorialCompletoResponse
import cl.clinipets.veterinaria.historial.application.PdfService
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.security.SecurityRequirement
import io.swagger.v3.oas.annotations.tags.Tag
import org.springframework.core.io.ByteArrayResource
import org.springframework.http.HttpHeaders
import org.springframework.http.MediaType
import org.springframework.http.ResponseEntity
import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.web.bind.annotation.*
import java.util.*

@RestController @RequestMapping("/api/v1/historial")
@SecurityRequirement(name = "bearer-jwt")
@Tag(name = "Historial Cl√≠nico", description = "Historial m√©dico completo de mascotas")
class HistorialController(
    private val historialService: HistorialClinicoService,
    private val pdfService: PdfService
) {

    @Operation(summary = "Obtener historial cl√≠nico completo de una mascota")
    @GetMapping("/mascota/{mascotaId}")
    fun obtenerHistorialCompleto(
        @PathVariable mascotaId: UUID,
        @AuthenticationPrincipal user: JwtPayload
    ): ResponseEntity<HistorialCompletoResponse> {
        val historial = historialService.obtenerHistorialCompleto(mascotaId, user)
        return ResponseEntity.ok(historial)
    }

    @Operation(summary = "Descargar carnet sanitario en PDF")
    @GetMapping("/mascota/{mascotaId}/carnet-pdf")
    fun descargarCarnetPdf(
        @PathVariable mascotaId: UUID,
        @AuthenticationPrincipal user: JwtPayload
    ): ResponseEntity<ByteArrayResource> {
        val pdfBytes = pdfService.generarCarnetSanitarioPdf(mascotaId, user)
        val headers = HttpHeaders().apply {
            contentType = MediaType.APPLICATION_PDF
            add(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"carnet-$mascotaId.pdf\"")
        }
        return ResponseEntity.ok()
            .headers(headers)
            .contentLength(pdfBytes.size.toLong())
            .body(ByteArrayResource(pdfBytes))
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/historial/application/HistorialClinicoService.kt">
package cl.clinipets.veterinaria.historial.application

import cl.clinipets.core.security.JwtPayload
import cl.clinipets.core.web.NotFoundException
import cl.clinipets.core.web.UnauthorizedException
import cl.clinipets.identity.domain.UserRole
import cl.clinipets.veterinaria.api.SignosVitalesDto
import cl.clinipets.veterinaria.api.toDto
import cl.clinipets.veterinaria.domain.MascotaRepository
import cl.clinipets.veterinaria.domain.PlanPreventivoRepository
import cl.clinipets.veterinaria.domain.SignosVitalesRepository
import cl.clinipets.veterinaria.domain.TipoPreventivo
import cl.clinipets.veterinaria.historial.domain.FichaClinicaRepository
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.time.Instant
import java.time.temporal.ChronoUnit
import java.util.*

data class HistorialCompletoResponse(
    val mascotaId: UUID,
    val nombreMascota: String,
    val fichasClinicas: List<ResumenFichaDto>,
    val planPreventivo: PlanPreventivoResumen,
    val signosVitales: EvolucionSignosVitales
)

data class ResumenFichaDto(
    val id: UUID,
    val fecha: Instant,
    val motivo: String,
    val diagnostico: String?,
    val veterinario: String
)

data class PlanPreventivoResumen(
    val vacunasCompletas: Boolean,
    val ultimaVacuna: VacunaDto?,
    val proximaVacuna: VacunaDto?,
    val ultimaDesparasitacion: DesparasitacionDto?,
    val alertas: List<AlertaPreventiva>
)

data class VacunaDto(
    val nombre: String,
    val fecha: Instant,
    val refuerzo: Instant?
)

data class DesparasitacionDto(
    val tipo: TipoPreventivo,
    val producto: String,
    val fecha: Instant
)

data class AlertaPreventiva(
    val tipo: String,
    val mensaje: String,
    val prioridad: PrioridadAlerta
)

enum class PrioridadAlerta {
    BAJA, MEDIA, ALTA, CRITICA
}

data class EvolucionSignosVitales(
    val ultimoRegistro: SignosVitalesDto?,
    val pesoPromedio: Double?,
    val tendenciaPeso: TendenciaPeso,
    val alertas: List<String>
)

enum class TendenciaPeso {
    ESTABLE, AUMENTO, DISMINUCION, FLUCTUANTE
}

@Service
class HistorialClinicoService(
    private val mascotaRepository: MascotaRepository,
    private val fichaClinicaRepository: FichaClinicaRepository,
    private val planPreventivoRepository: PlanPreventivoRepository,
    private val signosVitalesRepository: SignosVitalesRepository
) {
    private val logger = LoggerFactory.getLogger(HistorialClinicoService::class.java)

    @Transactional(readOnly = true)
    fun obtenerHistorialCompleto(mascotaId: UUID, user: JwtPayload): HistorialCompletoResponse {
        logger.info("[HISTORIAL_COMPLETO] Consultando para mascota: $mascotaId")
        
        val mascota = mascotaRepository.findById(mascotaId)
            .orElseThrow { NotFoundException("Mascota no encontrada") }

        // Validar permisos
        if (user.role == UserRole.CLIENT && mascota.tutor.id != user.userId) {
            throw UnauthorizedException("No tienes permiso para ver este historial")
        }

        // 1. Fichas cl√≠nicas
        val fichas = fichaClinicaRepository.findAllByMascotaIdOrderByFechaAtencionAsc(mascotaId)
        val fichasResumen = fichas.map { 
            ResumenFichaDto(
                id = it.id!!,
                fecha = it.fechaAtencion,
                motivo = it.motivoConsulta,
                diagnostico = it.avaluoClinico,
                veterinario = "Veterinario Tratante" // TODO: Vincular con User
            )
        }

        // 2. Plan preventivo
        val preventivos = planPreventivoRepository.findAllByMascotaIdOrderByFechaAplicacionDesc(mascotaId)
        val planResumen = generarResumenPreventivo(preventivos, mascota.especie)

        // 3. Signos vitales
        val vitales = signosVitalesRepository.findAllByMascotaIdOrderByFechaDesc(mascotaId)
        val evolucion = analizarEvolucionSignosVitales(vitales)

        return HistorialCompletoResponse(
            mascotaId = mascota.id!!,
            nombreMascota = mascota.nombre,
            fichasClinicas = fichasResumen,
            planPreventivo = planResumen,
            signosVitales = evolucion
        )
    }

    private fun generarResumenPreventivo(
        preventivos: List<cl.clinipets.veterinaria.domain.PlanPreventivo>,
        especie: cl.clinipets.veterinaria.domain.Especie
    ): PlanPreventivoResumen {
        val vacunas = preventivos.filter { it.tipo == TipoPreventivo.VACUNA }
        val desparasitaciones = preventivos.filter { 
            it.tipo == TipoPreventivo.DESPARASITACION_INTERNA || 
            it.tipo == TipoPreventivo.DESPARASITACION_EXTERNA 
        }

        val ahora = Instant.now()
        val proximasVacunas = vacunas
            .filter { it.fechaRefuerzo != null && it.fechaRefuerzo!! > ahora }
            .sortedBy { it.fechaRefuerzo }

        val alertas = mutableListOf<AlertaPreventiva>()

        // Validar vacunas pendientes cr√≠ticas
        proximasVacunas.firstOrNull()?.let { proxima ->
            val diasRestantes = ChronoUnit.DAYS.between(ahora, proxima.fechaRefuerzo)
            when {
                diasRestantes <= 0 -> alertas.add(
                    AlertaPreventiva(
                        "VACUNA_VENCIDA",
                        "Refuerzo de ${proxima.producto} est√° vencido",
                        PrioridadAlerta.CRITICA
                    )
                )
                diasRestantes <= 7 -> alertas.add(
                    AlertaPreventiva(
                        "VACUNA_URGENTE",
                        "Refuerzo de ${proxima.producto} en $diasRestantes d√≠as",
                        PrioridadAlerta.ALTA
                    )
                )
                diasRestantes <= 30 -> alertas.add(
                    AlertaPreventiva(
                        "VACUNA_PROXIMA",
                        "Refuerzo de ${proxima.producto} en $diasRestantes d√≠as",
                        PrioridadAlerta.MEDIA
                    )
                )
                else -> {}
            }
        }

        // Validar desparasitaci√≥n (recomendaci√≥n cada 3 meses)
        val ultimaDesp = desparasitaciones.firstOrNull()
        if (ultimaDesp != null) {
            val mesesDesdeUltima = ChronoUnit.DAYS.between(ultimaDesp.fechaAplicacion, ahora) / 30
            if (mesesDesdeUltima >= 3) {
                alertas.add(
                    AlertaPreventiva(
                        "DESPARASITACION_PENDIENTE",
                        "Han pasado $mesesDesdeUltima meses desde la √∫ltima desparasitaci√≥n",
                        PrioridadAlerta.MEDIA
                    )
                )
            }
        } else {
            alertas.add(
                AlertaPreventiva(
                    "SIN_DESPARASITACION",
                    "No hay registro de desparasitaciones",
                    PrioridadAlerta.ALTA
                )
            )
        }

        return PlanPreventivoResumen(
            vacunasCompletas = validarEsquemaCompleto(vacunas, especie),
            ultimaVacuna = vacunas.firstOrNull()?.let {
                VacunaDto(it.producto, it.fechaAplicacion, it.fechaRefuerzo)
            },
            proximaVacuna = proximasVacunas.firstOrNull()?.let {
                VacunaDto(it.producto, it.fechaRefuerzo!!, null)
            },
            ultimaDesparasitacion = ultimaDesp?.let {
                DesparasitacionDto(it.tipo, it.producto, it.fechaAplicacion)
            },
            alertas = alertas
        )
    }

    private fun validarEsquemaCompleto(
        vacunas: List<cl.clinipets.veterinaria.domain.PlanPreventivo>,
        especie: cl.clinipets.veterinaria.domain.Especie
    ): Boolean {
        val vacunasRequeridas = if (especie == cl.clinipets.veterinaria.domain.Especie.PERRO) {
            setOf("S√©xtuple", "Antirr√°bica")
        } else if (especie == cl.clinipets.veterinaria.domain.Especie.GATO) {
            setOf("Triple Felina", "Antirr√°bica")
        } else {
            emptySet()
        }

        val vacunasAplicadas = vacunas.map { 
            it.producto.lowercase() 
        }.toSet()

        return vacunasRequeridas.all { requerida ->
            vacunasAplicadas.any { aplicada -> aplicada.contains(requerida.lowercase()) }
        }
    }

    private fun analizarEvolucionSignosVitales(
        vitales: List<cl.clinipets.veterinaria.domain.SignosVitales>
    ): EvolucionSignosVitales {
        if (vitales.isEmpty()) {
            return EvolucionSignosVitales(
                ultimoRegistro = null,
                pesoPromedio = null,
                tendenciaPeso = TendenciaPeso.ESTABLE,
                alertas = listOf("No hay registros de signos vitales")
            )
        }

        val ultimo = vitales.first().toDto()
        val pesos = vitales.map { it.peso }
        val pesoPromedio = pesos.average()

        // Calcular tendencia (√∫ltimos 3 registros vs anteriores)
        val tendencia = if (pesos.size >= 4) {
            val recientes = pesos.take(3).average()
            val anteriores = pesos.drop(3).take(3).average()
            when {
                recientes > anteriores * 1.1 -> TendenciaPeso.AUMENTO
                recientes < anteriores * 0.9 -> TendenciaPeso.DISMINUCION
                else -> TendenciaPeso.ESTABLE
            }
        } else {
            TendenciaPeso.ESTABLE
        }

        val alertas = mutableListOf<String>()

        // Validar temperatura del √∫ltimo registro
        if (ultimo.temperatura > 39.5) {
            alertas.add("‚ö†Ô∏è √öltima temperatura elevada: ${ultimo.temperatura}¬∞C")
        }

        // Alerta de variaci√≥n de peso
        when (tendencia) {
            TendenciaPeso.AUMENTO -> alertas.add("üìà Tendencia de aumento de peso detectada")
            TendenciaPeso.DISMINUCION -> alertas.add("üìâ Tendencia de p√©rdida de peso detectada")
            TendenciaPeso.FLUCTUANTE -> alertas.add("‚ö†Ô∏è Peso fluctuante - requiere seguimiento")
            else -> {}
        }

        return EvolucionSignosVitales(
            ultimoRegistro = ultimo,
            pesoPromedio = pesoPromedio,
            tendenciaPeso = tendencia,
            alertas = alertas
        )
    }
}
</file>

<file path="env">
DB_HOST=db
DB_PORT=5432
# --- BASE DE DATOS ---
DB_USER=clinipets_user
DB_PASSWORD=clinipets_password
DB_NAME=clinipets_db

# --- IMAGEN DOCKER (Backend) ---
# Usa 'clinipets-backend:latest' si construyes local, o tu repo real
BACKEND_IMAGE=clinipets-backend:latest

TUNNEL_TOKEN=eyJhIjoiZTAxZjM0NmYwODdiZTVkYjE5MjkxNWQ0OTNlN2E2ZTUiLCJ0IjoiMGUxMmUzZDctNzQzNy00ZjlhLWFiOGUtZmFhMmE4ZGUzYjRkIiwicyI6IllUQTJZMlZpWXpZdE5qbGtaaTAwWTJGbUxUbGlOVGt0TWpObE9EY3lNbVZoTm1VeCJ9

META_ACCESS_TOKEN=EAAPdnqb6afYBQHUiAks0ZBcnpnMHxBfZB7Loz4IaD1tJjLe0WQJFCHLiEF7PBpHrXyZAP9r1ZBoqopqSMgGzOytz1tdTca6P2UEjMg3YiWwIOkYEn0HmsQ3WGje3ctkiJiVG3iFtmb81LIFkRtSlZBR8wm2ZAzS8DR3ejHVhuLzZAu8hf8vlFIsF3bbMQ6XNrbW4Mk8XxaO9BCbdpN5VqpZB32W7cc4jHtWikCTZAXYl48e0qTlFZAepRLWZCyzR6MhNa79M4sZD
META_PHONE_NUMBER_ID=944789398706767
</file>

<file path="gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14.3-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/domain/events/AgendamientoEvents.kt">
package cl.clinipets.agendamiento.domain.events

import java.util.UUID

data class ReservaCreadaEvent(val citaId: UUID)

data class ReservaConfirmadaEvent(val citaId: UUID)

data class ReservaCanceladaEvent(val citaId: UUID, val motivo: String = "")
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/domain/BloqueoAgenda.kt">
package cl.clinipets.agendamiento.domain

import cl.clinipets.core.domain.AuditableEntity
import jakarta.persistence.*
import java.time.Instant
import java.util.UUID

@Entity
@Table(name = "bloqueos_agenda")
data class BloqueoAgenda(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @Column(nullable = false)
    val veterinarioId: UUID,

    @Column(nullable = false)
    val fechaHoraInicio: Instant,

    @Column(nullable = false)
    val fechaHoraFin: Instant,

    val motivo: String?
) : AuditableEntity()
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/domain/BloqueoAgendaRepository.kt">
package cl.clinipets.agendamiento.domain

import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.time.Instant
import java.util.UUID

@Repository
interface BloqueoAgendaRepository : JpaRepository<BloqueoAgenda, UUID> {
    fun findByFechaHoraFinGreaterThanAndFechaHoraInicioLessThan(start: Instant, end: Instant): List<BloqueoAgenda>
}
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/domain/ClinicalValidator.kt">
package cl.clinipets.agendamiento.domain

import cl.clinipets.core.web.BadRequestException
import cl.clinipets.servicios.domain.ServicioMedico
import cl.clinipets.servicios.domain.ServicioMedicoRepository
import cl.clinipets.veterinaria.domain.Mascota
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Component
import java.util.UUID

@Component
class ClinicalValidator(
    private val servicioMedicoRepository: ServicioMedicoRepository
) {

    private val logger = LoggerFactory.getLogger(ClinicalValidator::class.java)

    fun validarRequisitosClinicos(
        servicio: ServicioMedico,
        mascota: Mascota,
        serviciosEnCarritoIds: Set<UUID>
    ) {
        if (servicio.bloqueadoSiEsterilizado && mascota.esterilizado) {
            throw BadRequestException("La mascota ${mascota.nombre} ya est√° esterilizada. No puede realizarse '${servicio.nombre}'.")
        }

        if (servicio.serviciosRequeridosIds.isEmpty()) return

        servicio.serviciosRequeridosIds.forEach { reqId ->
            if (!serviciosEnCarritoIds.contains(reqId)) {
                val servicioReq = servicioMedicoRepository.findById(reqId).orElse(null)
                var cumpleClinicamente = false

                if (servicioReq != null) {
                    val nombreReq = servicioReq.nombre
                    if (nombreReq.contains("Retroviral", ignoreCase = true) ||
                        nombreReq.contains("Leucemia", ignoreCase = true)
                    ) {
                        if (mascota.testRetroviralNegativo) {
                            cumpleClinicamente = true
                            logger.info(">>> [VALIDACION] Dependencia '${servicioReq.nombre}' satisfecha por historial cl√≠nico (Negativo).")
                        }
                    }
                }

                if (!cumpleClinicamente) {
                    val nombreReq = servicioReq?.nombre ?: "Servicio Requerido"
                    throw BadRequestException("El servicio '${servicio.nombre}' requiere que agregues tambi√©n: '$nombreReq' (o que la mascota ya cumpla el requisito cl√≠nico).")
                }
            }
        }
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/domain/HorarioClinica.kt">
package cl.clinipets.agendamiento.domain

import java.time.DayOfWeek
import java.time.LocalTime

object HorarioClinica {
    private val horario: Map<DayOfWeek, Pair<LocalTime, LocalTime>> = mapOf(
        DayOfWeek.MONDAY to (LocalTime.of(11, 0) to LocalTime.of(13, 0)),
        DayOfWeek.TUESDAY to (LocalTime.of(11, 0) to LocalTime.of(13, 0)),
        DayOfWeek.WEDNESDAY to (LocalTime.of(11, 0) to LocalTime.of(13, 0)),
        DayOfWeek.THURSDAY to (LocalTime.of(11, 0) to LocalTime.of(13, 0)),
        DayOfWeek.FRIDAY to (LocalTime.of(11, 0) to LocalTime.of(13, 0)),
        DayOfWeek.SATURDAY to (LocalTime.of(10, 0) to LocalTime.of(19, 0))
    )

    fun ventanaPara(dia: DayOfWeek): Pair<LocalTime, LocalTime>? = horario[dia]
}
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/domain/OrigenCita.kt">
package cl.clinipets.agendamiento.domain

enum class OrigenCita {
    APP, WHATSAPP, WEB
}
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/domain/TipoAtencion.kt">
package cl.clinipets.agendamiento.domain

enum class TipoAtencion {
    CLINICA,
    DOMICILIO
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/config/AdminProperties.kt">
package cl.clinipets.core.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.stereotype.Component

@Component
@ConfigurationProperties(prefix = "app.security")
class AdminProperties {
    var adminEmails: List<String> = emptyList()
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/config/ClinicProperties.kt">
package cl.clinipets.core.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Configuration

@Configuration
@ConfigurationProperties(prefix = "clinipets.clinic")
data class ClinicProperties(
    var name: String = "Clinipets",
    var rut: String = "",
    var address: String = "",
    var phone: String = "",
    var email: String = "",
    var website: String = "",
    var logoPath: String = ""
)
</file>

<file path="src/main/kotlin/cl/clinipets/core/config/FirebaseConfig.kt">
package cl.clinipets.core.config

import com.google.auth.oauth2.GoogleCredentials
import com.google.firebase.FirebaseApp
import com.google.firebase.FirebaseOptions
import jakarta.annotation.PostConstruct
import org.slf4j.LoggerFactory
import org.springframework.context.annotation.Configuration
import org.springframework.core.io.ClassPathResource
import java.io.File
import java.io.FileInputStream

@Configuration
class FirebaseConfig {

    private val logger = LoggerFactory.getLogger(FirebaseConfig::class.java)

    @PostConstruct
    fun init() {
        if (FirebaseApp.getApps().isNotEmpty()) {
            return
        }

        val credentials = loadCredentials()
        if (credentials == null) {
            logger.warn("[FIREBASE] Credenciales no encontradas. Notificaciones push deshabilitadas.")
            return
        }

        val options = FirebaseOptions.builder()
            .setCredentials(credentials)
            .build()

        FirebaseApp.initializeApp(options)
        logger.info("[FIREBASE] Inicializado correctamente.")
    }

    private fun loadCredentials(): GoogleCredentials? {
        val envPath = System.getenv("GOOGLE_APPLICATION_CREDENTIALS") ?: System.getenv("FIREBASE_CONFIG")
        if (!envPath.isNullOrBlank()) {
            val envFile = File(envPath)
            if (envFile.exists()) {
                FileInputStream(envFile).use {
                    logger.info("[FIREBASE] Cargando credenciales desde ruta de entorno: {}", envPath)
                    return GoogleCredentials.fromStream(it)
                }
            } else {
                logger.warn("[FIREBASE] Ruta de entorno {} no existe.", envPath)
            }
        }

        val classpathResource = ClassPathResource("firebase-service-account.json")
        if (classpathResource.exists()) {
            logger.info("[FIREBASE] Cargando credenciales desde classpath.")
            classpathResource.inputStream.use {
                return GoogleCredentials.fromStream(it)
            }
        }

        val file = File("firebase-service-account.json")
        if (file.exists()) {
            logger.info("[FIREBASE] Cargando credenciales desde el sistema de archivos.")
            FileInputStream(file).use {
                return GoogleCredentials.fromStream(it)
            }
        }

        return null
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/config/MetaProperties.kt">
package cl.clinipets.core.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.stereotype.Component

@Component
@ConfigurationProperties(prefix = "meta")
class MetaProperties {
    var verifyToken: String = ""
    var accessToken: String = ""
    var phoneNumberId: String = ""
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/security/JwtPayload.kt">
package cl.clinipets.core.security

import cl.clinipets.identity.domain.UserRole
import java.time.Instant
import java.util.UUID

data class JwtPayload(
    val userId: UUID,
    val email: String,
    val role: UserRole,
    val expiresAt: Instant
)
</file>

<file path="src/main/kotlin/cl/clinipets/identity/api/DeviceTokenController.kt">
package cl.clinipets.identity.api

import cl.clinipets.core.security.JwtPayload
import cl.clinipets.core.web.NotFoundException
import cl.clinipets.identity.domain.UserRepository
import io.swagger.v3.oas.annotations.Operation
import jakarta.validation.constraints.NotBlank
import jakarta.validation.Valid
import org.slf4j.LoggerFactory
import org.springframework.http.ResponseEntity
import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

data class DeviceTokenRequest(
    @field:NotBlank
    val token: String
)

@RestController
@RequestMapping("/api/v1/device-token")
class DeviceTokenController(
    private val userRepository: UserRepository
) {

    private val logger = LoggerFactory.getLogger(DeviceTokenController::class.java)

    @Operation(summary = "Guardar token de dispositivo para notificaciones push", operationId = "saveDeviceToken")
    @PutMapping
    fun saveToken(
        @AuthenticationPrincipal principal: JwtPayload,
        @Valid @RequestBody request: DeviceTokenRequest
    ): ResponseEntity<Void> {
        logger.info("[DEVICE_TOKEN] Guardando token para user {}", principal.email)
        val user = userRepository.findById(principal.userId)
            .orElseThrow { NotFoundException("Usuario no encontrado") }

        user.fcmToken = request.token
        userRepository.save(user)

        return ResponseEntity.ok().build()
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/identity/application/AccountMergeService.kt">
package cl.clinipets.identity.application

import cl.clinipets.identity.domain.User
import cl.clinipets.identity.domain.UserRepository
import cl.clinipets.veterinaria.domain.MascotaRepository
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class AccountMergeService(
    private val userRepository: UserRepository,
    private val mascotaRepository: MascotaRepository
) {
    private val logger = LoggerFactory.getLogger(AccountMergeService::class.java)

    /**
     * Unifica cuentas duplicadas por tel√©fono, preservando mascotas/historial del source en el target.
     */
    @Transactional
    fun mergeUsers(source: User, target: User): User {
        if (source.id == target.id) return target
        logger.info("[MERGE] Unificando cuentas. Source={}, Target={}", source.id, target.id)
        val mascotas = mascotaRepository.findAllByTutorId(source.id!!)
        mascotas.forEach { it.tutor = target }
        mascotaRepository.saveAll(mascotas)
        userRepository.delete(source)
        return target
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/identity/domain/UserRole.kt">
package cl.clinipets.identity.domain

enum class UserRole { ADMIN, STAFF, CLIENT }
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/api/InventarioController.kt">
package cl.clinipets.servicios.api

import cl.clinipets.servicios.domain.InsumoRepository
import io.swagger.v3.oas.annotations.Operation
import org.slf4j.LoggerFactory
import org.springframework.http.ResponseEntity
import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/api/v1/inventario")
class InventarioController(
    private val inventarioReportService: cl.clinipets.servicios.application.InventarioReportService
) {
    private val logger = LoggerFactory.getLogger(InventarioController::class.java)

    @Operation(summary = "Obtener alertas de stock bajo (Staff/Admin)", operationId = "obtenerAlertasStock")
    @PreAuthorize("hasAnyRole('STAFF', 'ADMIN')")
    @GetMapping("/alertas")
    fun obtenerAlertas(): ResponseEntity<List<InsumoDetalladoDto>> {
        logger.info("[INVENTARIO_ALERTAS] Iniciando consulta de alertas")
        val alertas = inventarioReportService.generarAlertasStock()
        logger.info("[INVENTARIO_ALERTAS] Encontradas {} alertas de stock bajo", alertas.size)
        return ResponseEntity.ok(alertas)
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/application/InventarioReportService.kt">
package cl.clinipets.servicios.application

import cl.clinipets.servicios.api.InsumoDetalladoDto
import cl.clinipets.servicios.api.toDetalladoDto
import cl.clinipets.servicios.domain.InsumoRepository
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class InventarioReportService(
    private val insumoRepository: InsumoRepository
) {
    @Transactional(readOnly = true)
    fun generarAlertasStock(): List<InsumoDetalladoDto> {
        return insumoRepository.findAlertas().map { it.toDetalladoDto() }
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/application/PromoEngineService.kt">
package cl.clinipets.servicios.application

import cl.clinipets.agendamiento.api.DetalleReservaRequest
import cl.clinipets.servicios.domain.PromocionRepository
import cl.clinipets.servicios.domain.ServicioMedicoRepository
import cl.clinipets.servicios.domain.TipoDescuento
import org.springframework.stereotype.Service
import java.math.BigDecimal
import java.time.LocalDate
import java.util.UUID

data class DetalleCalculado(
    val servicioId: UUID,
    var precioFinal: Int,
    val precioOriginal: Int,
    val notas: MutableList<String> = mutableListOf()
)

@Service
class PromoEngineService(
    private val promocionRepository: PromocionRepository,
    private val servicioMedicoRepository: ServicioMedicoRepository
) {

    fun calcularDescuentos(
        detalles: List<DetalleReservaRequest>,
        fechaCita: LocalDate
    ): Map<UUID, DetalleCalculado> {
        // 1. Cargar datos base de los servicios para tener los precios originales
        val serviciosIds = detalles.map { it.servicioId }.toSet()
        val serviciosInfo = servicioMedicoRepository.findAllById(serviciosIds)
            .associateBy { it.id!! }

        // Inicializar resultados con precios originales
        val resultado = detalles.associate { req ->
            val servicio = serviciosInfo[req.servicioId]
                ?: throw IllegalArgumentException("Servicio no encontrado: ${req.servicioId}")

            // Nota: Aqu√≠ estamos usando precioBase. Si el servicio requiere peso y c√°lculo complejo,
            // idealmente deber√≠amos recibir el precio ya calculado o calcularlo aqu√≠ si tuvi√©ramos la mascota.
            // Para este MVP de motor de promociones, usaremos precioBase como punto de partida.
            val precioBase = servicio.precioBase

            req.servicioId to DetalleCalculado(
                servicioId = req.servicioId,
                precioFinal = precioBase,
                precioOriginal = precioBase
            )
        }.toMutableMap()

        // 2. Cargar promociones activas
        val promociones = promocionRepository.findAllByActivaTrue()

        // 3. Evaluar cada promoci√≥n
        promociones.forEach { promo ->
            // Filtro 1: Vigencia (Fecha y D√≠as)
            if (!promo.estaVigente(fechaCita)) return@forEach

            // Filtro 2: Triggers (El carrito tiene todos los servicios requeridos?)
            val triggersCumplidos = if (promo.serviciosTriggerIds.isEmpty()) {
                true // Si no pide triggers, se aplica "siempre" (o a los items que coincidan con beneficios)
            } else {
                promo.serviciosTriggerIds.all { triggerId ->
                    detalles.any { it.servicioId == triggerId }
                }
            }

            if (triggersCumplidos) {
                // Aplicar beneficios
                promo.beneficios.forEach { beneficio ->
                    // Buscar si el servicio beneficiado est√° en el carrito (resultado)
                    val detalle = resultado[beneficio.servicioId]
                    if (detalle != null) {
                        aplicarBeneficio(detalle, beneficio.tipo, beneficio.valor, promo.nombre)
                    }
                }
            }
        }

        return resultado
    }

    private fun aplicarBeneficio(
        detalle: DetalleCalculado,
        tipo: TipoDescuento,
        valor: BigDecimal,
        nombrePromo: String
    ) {
        val precioActual = detalle.precioFinal
        var nuevoPrecio = precioActual

        when (tipo) {
            TipoDescuento.PRECIO_FIJO -> {
                // Fija el precio al valor indicado
                nuevoPrecio = valor.toInt()
            }

            TipoDescuento.MONTO_OFF -> {
                // Resta el monto
                nuevoPrecio = precioActual - valor.toInt()
            }

            TipoDescuento.PORCENTAJE_OFF -> {
                // Resta porcentaje (ej: 10% -> precio - (precio * 0.10))
                val descuento = (precioActual.toBigDecimal().multiply(valor))
                    .divide(BigDecimal(100))
                nuevoPrecio = precioActual - descuento.toInt()
            }
        }

        // Validaci√≥n: Precio no negativo
        if (nuevoPrecio < 0) nuevoPrecio = 0

        // Si hubo cambio, guardamos
        if (nuevoPrecio != precioActual) {
            detalle.precioFinal = nuevoPrecio
            detalle.notas.add("Promo: $nombrePromo")
        }
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/domain/Insumo.kt">
package cl.clinipets.servicios.domain

import cl.clinipets.core.domain.AuditableEntity
import jakarta.persistence.*
import java.util.UUID

@Entity
@Table(name = "insumos")
class Insumo(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @Version
    var version: Long? = null,

    @Column(nullable = false)
    var nombre: String,

    @Column(nullable = false)
    var stockActual: Double,

    @Column(nullable = false)
    var stockMinimo: Int,

    @Column(nullable = false)
    var unidadMedida: String
) : AuditableEntity() {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Insumo) return false
        return id != null && id == other.id
    }

    override fun hashCode(): Int = id?.hashCode() ?: 0

    override fun toString(): String = "Insumo(id=$id, nombre='$nombre')"
}
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/domain/InsumoRepository.kt">
package cl.clinipets.servicios.domain

import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Lock
import org.springframework.data.jpa.repository.Query
import jakarta.persistence.LockModeType
import java.util.UUID

interface InsumoRepository : JpaRepository<Insumo, UUID> {
    @Query("SELECT i FROM Insumo i WHERE i.stockActual <= i.stockMinimo")
    fun findAlertas(): List<Insumo>

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT i FROM Insumo i WHERE i.id = :id")
    fun findByIdWithLock(id: UUID): Insumo?
}
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/domain/Promocion.kt">
package cl.clinipets.servicios.domain

import cl.clinipets.core.domain.AuditableEntity
import jakarta.persistence.*
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.math.BigDecimal
import java.time.LocalDate
import java.util.UUID

enum class TipoDescuento {
    PRECIO_FIJO,
    MONTO_OFF,
    PORCENTAJE_OFF
}

@Embeddable
data class PromocionBeneficio(
    @Column(nullable = false)
    val servicioId: UUID,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    val tipo: TipoDescuento,

    @Column(nullable = false)
    val valor: BigDecimal
)

@Entity
@Table(name = "promociones")
data class Promocion(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @Column(nullable = false)
    val nombre: String,

    @Column(length = 500)
    val descripcion: String? = null,

    @Column(nullable = false)
    val fechaInicio: LocalDate,

    @Column(nullable = false)
    val fechaFin: LocalDate,

    @Column(name = "dias_permitidos", length = 50)
    val diasPermitidos: String? = null, // Formato "MON,TUE"

    @Column(nullable = false)
    val activa: Boolean = true,

    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "promocion_triggers", joinColumns = [JoinColumn(name = "promocion_id")])
    @Column(name = "servicio_id")
    val serviciosTriggerIds: MutableSet<UUID> = mutableSetOf(),

    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "promocion_beneficios", joinColumns = [JoinColumn(name = "promocion_id")])
    val beneficios: MutableList<PromocionBeneficio> = mutableListOf()

) : AuditableEntity() {

    fun estaVigente(fechaCita: LocalDate): Boolean {
        if (!activa) return false
        if (fechaCita.isBefore(fechaInicio) || fechaCita.isAfter(fechaFin)) return false

        val dias = diasPermitidos
        return if (dias.isNullOrBlank()) {
            true
        } else {
            val diaSemanaIngles = fechaCita.dayOfWeek.name.take(3).uppercase() // MON, TUE...
            dias.uppercase().contains(diaSemanaIngles)
        }
    }
}

@Repository
interface PromocionRepository : JpaRepository<Promocion, UUID> {
    fun findAllByActivaTrue(): List<Promocion>
}
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/domain/ServicioInsumo.kt">
package cl.clinipets.servicios.domain

import jakarta.persistence.*
import java.util.UUID

@Entity
@Table(name = "servicio_insumos")
class ServicioInsumo(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "servicio_id", nullable = false)
    val servicio: ServicioMedico,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "insumo_id", nullable = false)
    val insumo: Insumo,

    @Column(nullable = false)
    val cantidadRequerida: Double,

    @Column(nullable = false)
    val critico: Boolean = true
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is ServicioInsumo) return false
        return id != null && id == other.id
    }

    override fun hashCode(): Int = id?.hashCode() ?: 0

    override fun toString(): String = "ServicioInsumo(id=$id, cantidadRequerida=$cantidadRequerida)"
}
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/domain/ServicioInsumoRepository.kt">
package cl.clinipets.servicios.domain

import org.springframework.data.jpa.repository.JpaRepository
import java.util.UUID

interface ServicioInsumoRepository : JpaRepository<ServicioInsumo, UUID> {
    fun findByServicioId(servicioId: UUID): List<ServicioInsumo>
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/api/ReporteController.kt">
package cl.clinipets.veterinaria.api

import cl.clinipets.veterinaria.domain.PlanPreventivoRepository
import io.swagger.v3.oas.annotations.Operation
import org.slf4j.LoggerFactory
import org.springframework.format.annotation.DateTimeFormat
import org.springframework.http.ResponseEntity
import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId

data class RecordatorioPreventivoDto(
    val mascotaId: java.util.UUID,
    val nombreMascota: String,
    val tutorNombre: String,
    val tutorEmail: String,
    val producto: String,
    val fechaRefuerzo: Instant
)

@RestController
@RequestMapping("/api/v1/reportes")
class ReporteController(
    private val planPreventivoRepository: PlanPreventivoRepository,
    private val clinicZoneId: ZoneId
) {
    private val logger = LoggerFactory.getLogger(ReporteController::class.java)

    @Operation(
        summary = "Obtener recordatorios de preventivos pendientes (Staff/Admin)",
        operationId = "obtenerRecordatorios"
    )
    @PreAuthorize("hasAnyRole('STAFF', 'ADMIN')")
    @GetMapping("/recordatorios")
    fun obtenerRecordatorios(
        @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) inicio: LocalDate,
        @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) fin: LocalDate
    ): ResponseEntity<List<RecordatorioPreventivoDto>> {
        logger.info("[REPORTE_RECORDATORIOS] Consultando recordatorios entre {} y {}", inicio, fin)

        val instantInicio = inicio.atStartOfDay(clinicZoneId).toInstant()
        val instantFin = fin.plusDays(1).atStartOfDay(clinicZoneId).toInstant()

        val pendientes = planPreventivoRepository.findRecordatoriosPendientes(instantInicio, instantFin)

        val response = pendientes.map {
            RecordatorioPreventivoDto(
                mascotaId = it.mascota.id!!,
                nombreMascota = it.mascota.nombre,
                tutorNombre = it.mascota.tutor.name,
                tutorEmail = it.mascota.tutor.email,
                producto = it.producto,
                fechaRefuerzo = it.fechaRefuerzo!!
            )
        }

        logger.info("[REPORTE_RECORDATORIOS] Encontrados {} recordatorios pendientes", response.size)
        return ResponseEntity.ok(response)
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/domain/Especie.kt">
package cl.clinipets.veterinaria.domain

enum class Especie {
    PERRO, GATO
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/domain/MascotaEnums.kt">
package cl.clinipets.veterinaria.domain

enum class Sexo {
    MACHO, HEMBRA
}

enum class Temperamento {
    DOCIL, NERVIOSO, AGRESIVO
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/domain/PlanPreventivo.kt">
package cl.clinipets.veterinaria.domain

import cl.clinipets.core.domain.AuditableEntity
import jakarta.persistence.*
import java.time.Instant
import java.util.*

enum class TipoPreventivo {
    VACUNA,
    DESPARASITACION_INTERNA,
    DESPARASITACION_EXTERNA
}

@Entity
@Table(name = "plan_preventivo")
class PlanPreventivo(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "mascota_id", nullable = false)
    val mascota: Mascota,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    val tipo: TipoPreventivo,

    @Column(nullable = false)
    val fechaAplicacion: Instant,

    @Column(nullable = false)
    val producto: String,

    @Column(nullable = true)
    val fechaRefuerzo: Instant? = null,

    @Column(nullable = true)
    val lote: String? = null,

    @Column(nullable = true)
    val observaciones: String? = null
) : AuditableEntity() {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is PlanPreventivo) return false
        return id != null && id == other.id
    }

    override fun hashCode(): Int = id?.hashCode() ?: 0

    override fun toString(): String = "PlanPreventivo(id=$id, tipo=$tipo, producto='$producto')"
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/domain/PlanPreventivoRepository.kt">
package cl.clinipets.veterinaria.domain

import org.springframework.data.jpa.repository.JpaRepository
import java.util.*

interface PlanPreventivoRepository : JpaRepository<PlanPreventivo, UUID> {
    fun findAllByMascotaIdOrderByFechaAplicacionDesc(mascotaId: UUID): List<PlanPreventivo>

    @org.springframework.data.jpa.repository.Query("SELECT p FROM PlanPreventivo p WHERE p.fechaRefuerzo BETWEEN :inicio AND :fin")
    fun findRecordatoriosPendientes(inicio: java.time.Instant, fin: java.time.Instant): List<PlanPreventivo>
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/domain/SignosVitales.kt">
package cl.clinipets.veterinaria.domain

import cl.clinipets.core.domain.AuditableEntity
import jakarta.persistence.*
import java.time.Instant
import java.util.*

@Entity
@Table(name = "signos_vitales")
class SignosVitales(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "mascota_id", nullable = false)
    val mascota: Mascota,

    @Column(nullable = false)
    var peso: Double,

    @Column(nullable = false)
    var temperatura: Double,

    @Column(nullable = false)
    var frecuenciaCardiaca: String,

    @Column(nullable = false)
    val fecha: Instant = Instant.now()
) : AuditableEntity() {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is SignosVitales) return false
        return id != null && id == other.id
    }

    override fun hashCode(): Int = id?.hashCode() ?: 0
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/domain/SignosVitalesRepository.kt">
package cl.clinipets.veterinaria.domain

import org.springframework.data.jpa.repository.JpaRepository
import java.util.*

interface SignosVitalesRepository : JpaRepository<SignosVitales, UUID> {
    @org.springframework.data.jpa.repository.EntityGraph(attributePaths = ["mascota"])
    fun findAllByMascotaIdOrderByFechaDesc(mascotaId: UUID): List<SignosVitales>
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/galeria/api/GaleriaController.kt">
package cl.clinipets.veterinaria.galeria.api

import cl.clinipets.core.security.JwtPayload
import cl.clinipets.veterinaria.galeria.application.GaleriaService
import cl.clinipets.veterinaria.galeria.domain.MediaType
import io.swagger.v3.oas.annotations.Operation
import org.springframework.http.MediaType as HttpMediaType
import org.springframework.http.ResponseEntity
import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.web.bind.annotation.*
import org.springframework.web.multipart.MultipartFile
import java.util.UUID

import org.springframework.core.io.InputStreamResource
import org.springframework.http.HttpHeaders

@RestController
@RequestMapping("/api/v1/mascotas/{mascotaId}/galeria")
class GaleriaController(
    private val galeriaService: GaleriaService
) {

    @Operation(summary = "Subir archivo a la galer√≠a de la mascota")
    @PostMapping("/upload", consumes = [HttpMediaType.MULTIPART_FORM_DATA_VALUE])
    fun uploadFile(
        @PathVariable mascotaId: UUID,
        @RequestParam("file") file: MultipartFile,
        @RequestParam("titulo", required = false) titulo: String?,
        @RequestParam("tipo", defaultValue = "IMAGE") tipo: MediaType,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<MediaResponse> {
        val response = galeriaService.subirArchivo(mascotaId, file, titulo, tipo, principal)

        // Transformar internal path a public URL para la respuesta inmediata
        val publicUrl = "/api/v1/mascotas/$mascotaId/galeria/ver/${response.id}"

        return ResponseEntity.ok(response.copy(url = publicUrl))
    }

    @Operation(summary = "Listar galer√≠a de la mascota")
    @GetMapping
    fun listarGaleria(
        @PathVariable mascotaId: UUID,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<List<MediaResponse>> {
        val internalList = galeriaService.listarArchivos(mascotaId, principal)

        // Transformar path interno a URL p√∫blica
        val publicList = internalList.map {
            it.copy(url = "/api/v1/mascotas/$mascotaId/galeria/ver/${it.id}")
        }

        return ResponseEntity.ok(publicList)
    }

    @Operation(summary = "Descargar/Visualizar archivo de la galer√≠a")
    @GetMapping("/ver/{mediaId}")
    fun verArchivo(
        @PathVariable mascotaId: UUID,
        @PathVariable mediaId: UUID,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<InputStreamResource> {
        val (inputStream, contentType) = galeriaService.descargarArchivo(mediaId, principal)

        val headers = HttpHeaders()
        headers.add(HttpHeaders.CONTENT_TYPE, contentType)
        // Opcional: headers.add(HttpHeaders.CONTENT_DISPOSITION, "inline; filename=\"...\"")

        return ResponseEntity.ok()
            .headers(headers)
            .body(InputStreamResource(inputStream))
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/galeria/api/GaleriaDtos.kt">
package cl.clinipets.veterinaria.galeria.api

import cl.clinipets.veterinaria.galeria.domain.MediaType
import java.time.Instant
import java.util.UUID

data class MediaResponse(
    val id: UUID,
    val url: String,
    val tipo: MediaType,
    val titulo: String?,
    val fechaSubida: Instant
)
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/galeria/application/GaleriaService.kt">
package cl.clinipets.veterinaria.galeria.application

import cl.clinipets.core.security.JwtPayload
import cl.clinipets.core.storage.StorageService
import cl.clinipets.core.web.NotFoundException
import cl.clinipets.core.web.UnauthorizedException
import cl.clinipets.identity.domain.UserRole
import cl.clinipets.veterinaria.domain.MascotaRepository
import cl.clinipets.veterinaria.galeria.api.MediaResponse
import cl.clinipets.veterinaria.galeria.domain.MascotaMedia
import cl.clinipets.veterinaria.galeria.domain.MascotaMediaRepository
import cl.clinipets.veterinaria.galeria.domain.MediaType
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import org.springframework.web.multipart.MultipartFile
import java.io.InputStream
import java.util.UUID

@Service
class GaleriaService(
    private val mascotaRepository: MascotaRepository,
    private val mascotaMediaRepository: MascotaMediaRepository,
    private val storageService: StorageService
) {
    private val logger = LoggerFactory.getLogger(GaleriaService::class.java)

    @Transactional
    fun subirArchivo(
        mascotaId: UUID,
        file: MultipartFile,
        titulo: String?,
        tipo: MediaType,
        principal: JwtPayload
    ): MediaResponse {
        val mascota = mascotaRepository.findById(mascotaId)
            .orElseThrow { NotFoundException("Mascota no encontrada") }

        // Validar permisos: Staff o Due√±o
        if (principal.role != UserRole.STAFF && mascota.tutor.id != principal.userId) {
            throw UnauthorizedException("No tienes permiso para subir archivos a esta mascota")
        }

        // Subir a Storage
        val folder = "mascotas/$mascotaId"
        val objectPath = storageService.uploadFile(file, folder)

        val media = mascotaMediaRepository.save(
            MascotaMedia(
                mascota = mascota,
                url = objectPath, // Guardamos el path relativo (objectName)
                tipo = tipo,
                titulo = titulo
            )
        )

        logger.info("[GALERIA] Archivo subido para mascota {}: {}", mascotaId, media.id)

        return MediaResponse(
            id = media.id!!,
            url = media.url,
            tipo = media.tipo,
            titulo = media.titulo,
            fechaSubida = media.fechaSubida
        )
    }

    @Transactional(readOnly = true)
    fun listarArchivos(mascotaId: UUID, principal: JwtPayload): List<MediaResponse> {
        val mascota = mascotaRepository.findById(mascotaId)
            .orElseThrow { NotFoundException("Mascota no encontrada") }

        if (principal.role != UserRole.STAFF && mascota.tutor.id != principal.userId) {
            throw UnauthorizedException("No tienes permiso para ver la galer√≠a de esta mascota")
        }

        return mascotaMediaRepository.findAllByMascotaIdOrderByFechaSubidaDesc(mascotaId)
            .map {
                MediaResponse(
                    id = it.id!!,
                    url = it.url,
                    tipo = it.tipo,
                    titulo = it.titulo,
                    fechaSubida = it.fechaSubida
                )
            }
    }

    @Transactional(readOnly = true)
    fun descargarArchivo(mediaId: UUID, principal: JwtPayload): Pair<InputStream, String> {
        val media = mascotaMediaRepository.findById(mediaId)
            .orElseThrow { NotFoundException("Archivo no encontrado") }

        // Validar permisos
        val mascota = media.mascota
        if (principal.role != UserRole.STAFF && mascota.tutor.id != principal.userId) {
            throw UnauthorizedException("No tienes permiso para descargar este archivo")
        }

        val inputStream = storageService.getFile(media.url)

        // Deducir contentType b√°sico
        val extension = media.url.substringAfterLast('.', "").lowercase()
        val contentType = when (extension) {
            "jpg", "jpeg" -> "image/jpeg"
            "png" -> "image/png"
            "pdf" -> "application/pdf"
            else -> "application/octet-stream"
        }

        return inputStream to contentType
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/galeria/domain/MascotaMedia.kt">
package cl.clinipets.veterinaria.galeria.domain

import cl.clinipets.veterinaria.domain.Mascota
import jakarta.persistence.*
import java.time.Instant
import java.util.UUID

@Entity
@Table(name = "mascota_media")
class MascotaMedia(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    var id: UUID? = null,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "mascota_id", nullable = false)
    var mascota: Mascota,

    @Column(nullable = false, length = 1024)
    var url: String,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    var tipo: MediaType,

    @Column(length = 255)
    var titulo: String? = null,

    @Column(name = "fecha_subida", nullable = false)
    var fechaSubida: Instant = Instant.now()
)

enum class MediaType {
    IMAGE,
    PDF,
    LAB_RESULT,
    OTHER
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/galeria/domain/MascotaMediaRepository.kt">
package cl.clinipets.veterinaria.galeria.domain

import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.util.UUID

@Repository
interface MascotaMediaRepository : JpaRepository<MascotaMedia, UUID> {
    fun findAllByMascotaIdOrderByFechaSubidaDesc(mascotaId: UUID): List<MascotaMedia>
}
</file>

<file path="src/main/resources/static/google-login.html">
<!doctype html>
<html lang="es">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
    <title>Obtener Google ID Token - Clinipets</title>
    <script async defer src="https://accounts.google.com/gsi/client"></script>
    <style>
        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif;
            margin: 2rem;
        }

        .box {
            max-width: 720px;
            margin: 0 auto;
        }

        textarea {
            width: 100%;
            height: 160px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        }

        .row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 12px 0;
            flex-wrap: wrap;
        }

        .muted {
            color: #666;
            font-size: 0.9rem;
        }


        button {
            padding: .6rem 1rem;
        }

        code {
            background: #f5f5f5;
            padding: 2px 4px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
<div class="box">
    <h1>Obtener Google ID Token</h1>
    <p class="muted">Usa este bot√≥n para iniciar sesi√≥n y obtener un <strong>ID Token</strong> (JWT) que luego puedes
        enviar a <code>POST /api/auth/google</code>.</p>

    <div class="row" id="g_id_signin"></div>

    <div class="row">
        <button disabled id="copyBtn">Copiar ID Token</button>
        <span class="muted" id="status">Esperando login‚Ä¶</span>
    </div>

    <label class="muted" for="token">token</label>
    <textarea id="token" placeholder="Aqu√≠ ver√°s tu ID Token JWT tras iniciar sesi√≥n"></textarea>

    <h3>C√≥mo usarlo</h3>
    <ol>
        <li>Haz clic en ‚ÄúSign in with Google‚Äù.</li>
        <li>Se rellenar√° el <em>ID Token</em> en el recuadro superior.</li>
        <li>C√≥pialo y √∫salo en tu request a <code>POST /api/auth/google</code>:
            <pre>POST {{host}}/api/auth/google
Content-Type: application/json

{
  "idToken": "&lt;pega_aqu√≠_el_id_token&gt;"
}
</pre>
        </li>
    </ol>

    <p class="muted">Client ID configurado para esta p√°gina:</p>
    <p><code id="cid"></code></p>
</div>

<script>
    // Ajusta este valor si cambias el client id en application-default.properties
    const CLIENT_ID = "516859256009-obqnjjbnn9k5e2phvbk35sspf1sdvqr7.apps.googleusercontent.com";

    const cidEl = document.getElementById('cid');
    const tokenEl = document.getElementById('token');
    const statusEl = document.getElementById('status');
    const copyBtn = document.getElementById('copyBtn');
    cidEl.textContent = CLIENT_ID;

    window.handleCredentialResponse = (response) => {
        const idToken = response && response.credential;
        if (idToken) {
            tokenEl.value = idToken;
            statusEl.textContent = 'ID Token recibido';
            statusEl.className = 'ok';
            copyBtn.disabled = false;
        } else {
            statusEl.textContent = 'No se recibi√≥ credential';
            statusEl.className = 'err';
        }
    };

    window.onload = () => {
        google.accounts.id.initialize({
            client_id: CLIENT_ID,
            callback: handleCredentialResponse
        });
        google.accounts.id.renderButton(
            document.getElementById('g_id_signin'),
            {theme: 'outline', size: 'large', type: 'standard', shape: 'rectangular'}
        );
    };

    copyBtn.addEventListener('click', async () => {
        try {
            await navigator.clipboard.writeText(tokenEl.value || '');
            statusEl.textContent = 'Copiado al portapapeles';
            statusEl.className = 'ok';
        } catch (e) {
            statusEl.textContent = 'No se pudo copiar';
            statusEl.className = 'err';
        }
    });
</script>
</body>
</html>
</file>

<file path="src/main/resources/static/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

Hello World!
</body>
</html>
</file>

<file path="src/main/resources/static/privacy.html">
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>Pol√≠tica de Privacidad - Clinipets</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            color: #333;
            background-color: #f9f9f9;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        h2 {
            color: #34495e;
            margin-top: 25px;
        }

        p {
            margin-bottom: 15px;
        }

        ul {
            margin-bottom: 15px;
        }

        .footer {
            margin-top: 40px;
            font-size: 0.9em;
            color: #7f8c8d;
            border-top: 1px solid #eee;
            padding-top: 20px;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Pol√≠tica de Privacidad</h1>
    <p>√öltima actualizaci√≥n: Diciembre 2025</p>

    <p>En <strong>Clinipets</strong>, nos comprometemos a proteger la privacidad de nuestros usuarios. Esta Pol√≠tica de
        Privacidad describe c√≥mo recopilamos, usamos y protegemos su informaci√≥n personal.</p>

    <h2>1. Informaci√≥n que Recopilamos</h2>
    <p>Recopilamos √∫nicamente los datos necesarios para la gesti√≥n eficiente de sus citas veterinarias y la comunicaci√≥n
        relacionada:</p>
    <ul>
        <li><strong>Datos de Identificaci√≥n:</strong> Nombre completo.</li>
        <li><strong>Datos de Contacto:</strong> Correo electr√≥nico y n√∫mero de tel√©fono.</li>
        <li><strong>Datos de Mascotas:</strong> Nombre, especie, raza y antecedentes m√©dicos relevantes.</li>
    </ul>

    <h2>2. Uso de Datos de Google (OAuth)</h2>
    <p>Nuestra aplicaci√≥n utiliza servicios de Google para facilitar el inicio de sesi√≥n. Al utilizar esta funci√≥n:</p>
    <ul>
        <li>Accedemos √∫nicamente a su nombre, correo electr√≥nico y foto de perfil p√∫blico.</li>
        <li>Utilizamos estos datos exclusivamente para verificar su identidad y crear su cuenta en nuestra plataforma.
        </li>
        <li>No publicamos nada en su nombre ni accedemos a sus contactos, archivos u otros datos privados.</li>
    </ul>

    <h2>3. Uso de la Informaci√≥n</h2>
    <p>Utilizamos su informaci√≥n para:</p>
    <ul>
        <li>Agendar y confirmar citas veterinarias.</li>
        <li>Enviar recordatorios autom√°ticos (v√≠a WhatsApp o correo electr√≥nico).</li>
        <li>Gestionar su historial cl√≠nico y el de sus mascotas.</li>
        <li>Procesar pagos a trav√©s de plataformas seguras.</li>
    </ul>

    <h2>4. Compartir Informaci√≥n con Terceros</h2>
    <p>No vendemos ni alquilamos su informaci√≥n personal. Solo compartimos datos con terceros en los siguientes casos
        estrictamente necesarios:</p>
    <ul>
        <li><strong>Proveedores de Pago:</strong> Compartimos los datos necesarios para procesar transacciones con
            MercadoPago.
        </li>
        <li><strong>Servicios de Mensajer√≠a:</strong> Utilizamos proveedores como Meta (WhatsApp API) para el env√≠o de
            notificaciones de citas.
        </li>
        <li><strong>Requerimiento Legal:</strong> Si una autoridad competente lo solicita bajo mandato legal.</li>
    </ul>

    <h2>5. Seguridad de los Datos</h2>
    <p>Implementamos medidas de seguridad t√©cnicas y organizativas para proteger su informaci√≥n contra acceso no
        autorizado, alteraci√≥n o p√©rdida. Todas las comunicaciones con nuestros servidores est√°n encriptadas mediante
        SSL/TLS.</p>

    <h2>6. Sus Derechos</h2>
    <p>Usted tiene derecho a acceder, rectificar o solicitar la eliminaci√≥n de sus datos personales de nuestra
        plataforma en cualquier momento.</p>

    <div class="footer">
        <h2>Contacto</h2>
        <p>Si tiene preguntas sobre esta pol√≠tica o el manejo de sus datos, por favor cont√°ctenos en:</p>
        <p><strong>Email:</strong> billymartinezc@gmail.com</p>
    </div>
</div>
</body>
</html>
</file>

<file path="src/main/resources/banner.txt">
‚£ø‚£ø‚£ø‚°∑‚†ä‚°¢‚°π‚£¶‚°ë‚¢Ç‚¢ï‚¢Ç‚¢ï‚¢Ç‚¢ï‚¢Ç‚†ï‚†î‚†å‚†ù‚†õ‚†∂‚†∂‚¢∂‚£¶‚£Ñ‚¢Ç‚¢ï‚¢Ç‚¢ï  ,---. .                  .
‚£ø‚£ø‚†è‚£†‚£æ‚£¶‚°ê‚¢å‚¢ø‚£∑‚£¶‚£Ö‚°ë‚†ï‚†°‚†ê‚¢ø‚†ø‚£õ‚†ü‚†õ‚†õ‚†õ‚†õ‚†°‚¢∑‚°à‚¢Ç‚¢ï‚¢Ç  |  -' |  . ,-. . ,-. ,-. |- ,-.
‚†ü‚£°‚£æ‚£ø‚£ø‚£ø‚£ø‚£¶‚£ë‚†ù‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°µ‚¢Å‚£§‚£∂‚£∂‚£ø‚¢ø‚¢ø‚¢ø‚°ü‚¢ª‚£§‚¢ë‚¢Ç  |  -. |  | | | | | | |-' |  `-.
‚£æ‚£ø‚£ø‚°ø‚¢ü‚£õ‚£ª‚£ø‚£ø‚£ø‚£¶‚£¨‚£ô‚£ª‚£ø‚£ø‚£∑‚£ø‚£ø‚¢ü‚¢ù‚¢ï‚¢ï‚¢ï‚¢ï‚¢Ω‚£ø‚£ø‚£∑‚£î  `---' `' ' ' ' ' |-' `-' `' `-'
‚£ø‚£ø‚†µ‚†ö‚†â‚¢Ä‚£Ä‚£Ä‚£à‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ó‚¢ï‚¢ï‚¢ï‚¢ï‚¢ï‚¢ï‚£Ω‚£ø‚£ø‚£ø‚£ø                   |
‚¢∑‚£Ç‚£†‚£¥‚£æ‚°ø‚°ø‚°ª‚°ª‚£ø‚£ø‚£¥‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£µ‚£µ‚£µ‚£∑‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø                   '
‚¢å‚†ª‚£ø‚°ø‚°´‚°™‚°™‚°™‚°™‚£∫‚£ø‚£ø‚£ø‚£ø‚£ø‚†ø‚†ø‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†É  ${application.title} ${application.version}
‚†£‚°Å‚†π‚°™‚°™‚°™‚°™‚£™‚£æ‚£ø‚£ø‚£ø‚£ø‚†ã‚†ê‚¢â‚¢ç‚¢Ñ‚¢å‚†ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†è‚†à  Powered by Spring Boot ${spring-boot.version}
‚°£‚°ò‚¢Ñ‚†ô‚£æ‚£æ‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ä‚¢ê‚¢ï‚¢ï‚¢ï‚¢ï‚¢ï‚°ò‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†è‚††‚†à
‚†å‚¢ä‚¢Ç‚¢£‚†π‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ß‚¢ê‚¢ï‚¢ï‚¢ï‚¢ï‚¢ï‚¢Ö‚£ø‚£ø‚£ø‚£ø‚°ø‚¢ã‚¢ú‚††‚†à
‚¢à‚¢Ç‚¢ï‚¢Ç‚†£‚°ô‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ß‚¢ë‚¢ï‚¢ï‚¢ï‚¢ï‚¢ï‚£æ‚£ø‚£ø‚¢ã‚¢ú‚††‚†à
</file>

<file path="src/main/resources/logback-spring.xml">
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <include resource="org/springframework/boot/logging/logback/defaults.xml"/>
    <include resource="org/springframework/boot/logging/logback/console-appender.xml"/>

    <!-- Configuraci√≥n √önica: Logs legibles siempre (Dev y Prod) -->
    <!-- Usamos el appender CONSOLE por defecto de Spring Boot que es bonito y legible -->
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
    </root>
</configuration>
</file>

<file path="src/main/resources/logopastel.svg">
<svg xmlns:bx="https://boxy-svg.com" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 500">
    <g transform="matrix(1.228731, 0, 0, 1.212864, -62.220078, 22.564358)" style="">
        <path d="M 373.413 138.251 C 373.677 144.964 372.321 189.719 373.013 194.595 C 373.705 199.47 374.657 205.635 375.129 208.294 C 375.6 210.953 376.664 215.17 377.495 217.664 C 378.326 220.159 380.502 225.349 382.332 229.198 L 385.658 236.197 L 383.761 238.235 C 382.717 239.356 378.613 241.855 374.642 243.788 C 370.67 245.721 364.174 248.24 360.206 249.385 C 356.237 250.531 350.46 251.832 347.369 252.276 C 344.277 252.72 338.428 253.403 334.372 253.792 C 328.123 254.392 327.982 252.881 323.564 255.362 C 320.696 256.974 298.223 264.358 298.223 264.769 C 298.223 265.179 290.364 273.672 294.224 273.824 C 298.086 273.976 322.932 270.215 329.992 269.892 C 337.053 269.57 346.693 269.122 349.561 268.612 C 352.429 268.104 359.263 266.439 364.746 264.912 C 370.228 263.385 378.479 259.01 381.6 257.526 C 384.722 256.042 385.994 252.304 388.176 250.818 C 391.026 248.879 392.966 244.765 394.557 241.581 C 395.775 239.143 398.926 232.178 399.22 230.703 C 399.69 228.36 392.625 216.066 390.113 213.481 L 373.413 138.251 Z M 237.224 251.18 C 235.857 252.183 230.389 258.539 227.914 259.868 C 226.573 260.588 195.033 264.841 166.403 265.252 C 142.175 265.6 121.002 262.154 121.003 262.256 C 121.006 262.473 121.494 270.171 122.997 272.738 C 123.172 273.037 137.07 274.821 151.956 274.01 C 182.423 272.352 226.013 267.024 227.513 266.267 C 229.006 265.513 236.978 257.673 239.52 256.058 L 237.224 251.18 Z M 395.435 260.321 C 391.194 262.89 374.386 272.713 368.021 274.764 C 362.592 276.514 355.983 278.483 353.335 279.141 C 350.688 279.798 345 280.77 340.696 281.301 C 335.9 281.89 327.36 282.107 318.632 281.861 C 305.964 281.502 303.334 281.176 294.767 278.904 C 289.472 277.499 282.673 275.417 279.659 274.277 C 275.824 272.825 273.805 267.712 273.215 268.305 C 272.624 268.898 272.475 274.278 274.374 275.439 C 275.867 276.352 280.874 278.294 284.487 279.607 C 288.1 280.922 294.238 282.538 298.126 283.199 C 302.015 283.86 308.988 284.832 313.621 285.358 C 318.654 285.929 325.759 286.105 331.272 285.795 C 336.347 285.509 343.567 284.727 347.318 284.057 C 351.069 283.388 356.484 282.256 359.353 281.544 C 362.221 280.832 366.914 279.325 369.783 278.196 C 371.278 277.608 379.616 274.365 385.3 271.059 C 390.521 268.023 394.145 265.646 395.295 263.798 L 395.435 260.321 Z"
              stroke="none" fill="#eebc73" fill-rule="evenodd" style="stroke-width: 1;">
            <bx:title>sombra1</bx:title>
        </path>
        <path d="M 200.571 220.112 C 200.282 220.869 176.077 241.831 168.952 241.583 C 161.441 241.321 130.775 238.729 127.11 237.249 C 123.445 235.77 118.449 234.179 117.128 233.233 C 115.807 232.289 111.627 229.469 110.876 229.687 C 110.126 229.905 79.999 196.92 82.907 204.684 C 84.981 210.22 90.049 219.353 94.082 224.512 C 99.984 232.062 119.137 246.341 120.522 247.29 C 121.907 248.239 128.994 251.511 134.667 252.907 C 140.339 254.303 148.039 255.818 151.778 256.272 C 155.517 256.727 163.46 257.097 169.429 257.095 C 175.932 257.093 184.467 256.473 190.728 255.548 C 196.475 254.698 204.146 253.242 207.776 252.311 C 211.406 251.381 216.994 249.675 220.194 248.52 C 223.394 247.366 228.054 245.391 230.55 244.131 C 233.045 242.872 235.853 241.903 236.041 241.338 C 236.229 240.772 245.236 238.143 243.656 236.887 C 242.076 235.631 257.551 148.781 256.354 147 C 255.156 145.218 253.519 142.935 252.652 140.609 C 251.787 138.284 236.321 118.218 235.811 115.392 C 235.687 114.704 208.52 102.97 205.729 111.346 C 197.051 137.388 204.904 210.333 204.483 209.527 L 200.571 220.112 Z"
              stroke="none" fill="#e8cca6" fill-rule="evenodd" style="stroke-width: 1;"></path>
        <path d="M 229.855 243.796 C 227.403 245.053 221.79 247.345 217.379 248.886 C 212.969 250.428 205.588 252.438 200.977 253.354 C 196.366 254.269 188.803 255.445 184.17 255.965 C 179.121 256.533 170.761 256.729 163.31 256.456 C 155.798 256.181 147.538 255.339 142.45 254.33 C 137.816 253.411 131.8 251.756 128.932 250.874 C 126.063 249.991 123.142 248.36 122.662 248.357 C 122.18 248.353 121.429 250.362 120.917 251.491 C 120.404 252.62 119.417 257.1 119.417 257.655 C 119.417 257.849 130.637 264 143.407 265.019 C 167.658 266.953 202.294 264.33 206.572 263.297 C 213.103 261.718 230.1 253.872 234.585 252.115 C 239.069 250.357 236.363 243.503 235.448 242.613 C 234.484 241.675 233.641 241.854 229.855 243.796 Z"
              stroke="none" fill="#97abd3" fill-rule="evenodd" style="stroke-width: 1;">
            <bx:title>sonbracollar</bx:title>
        </path>
        <path d="M 232.764 235.922 C 233.442 236.494 237.94 242.152 238.904 242.659 C 239.868 243.166 242.823 245.277 245.471 247.35 C 248.118 249.422 259.417 255.77 263.714 257.374 C 268.012 258.979 275.87 263.059 280.177 263.911 C 284.485 264.763 290.539 273.833 292.966 274.111 C 295.393 274.388 295.575 265.11 296.535 265.305 C 298.061 265.615 317.973 258.501 320.213 257.27 L 324.286 255.033 L 311.172 254.861 C 303.959 254.767 294.169 254.301 289.415 253.826 C 284.662 253.351 276.965 252.251 272.312 251.38 C 267.659 250.509 232.086 235.35 232.764 235.922 Z M 221.619 260.217 C 216.856 260.357 205.15 267.554 188.408 269.868 C 173.724 271.899 153.254 270.207 153.238 270.436 C 153.206 270.897 149.56 278.511 155.513 275.011 C 161.466 271.511 221.69 277.473 224.685 266.715 C 224.685 266.715 224.166 260.142 221.619 260.217 Z"
              stroke="none" fill="#e4d5b4" fill-rule="evenodd" style="stroke-width: 1;">
            <bx:title>sombra</bx:title>
        </path>
        <path d="M 216.106 71.001 C 214.165 72.388 209.698 76.468 206.182 80.067 C 202.664 83.666 203.251 84.352 202.995 85.024 C 202.738 85.695 189.494 106.29 189.484 105.515 C 189.47 104.494 185.424 104.662 179.913 104.748 C 175.373 104.818 174.183 103.655 175.195 105.648 C 176.064 107.358 170.272 115.205 171.337 118.897 C 172.402 122.588 179.685 125.455 180.153 129.663 C 180.621 133.871 119.626 206.347 107.306 205.599 C 95.33 204.873 82.846 204.066 82.682 204.217 C 82.525 204.361 84.903 207.724 88.07 211.506 C 91.611 215.734 95.763 220.422 97.252 221.52 C 100.074 223.602 107.946 230.602 107.946 230.602 L 117.496 236.779 C 121.397 238.713 127.521 241.956 131.739 243.295 C 135.958 244.633 143.2 246.53 147.833 247.508 C 154.963 249.015 158.846 249.291 173.106 249.305 C 187.616 249.318 191.11 249.069 198.282 247.508 C 202.862 246.51 209.993 244.606 214.128 243.275 C 218.262 241.945 229.163 238.898 229.163 238.621 C 229.163 238.507 223.554 229.862 222.473 225.787 C 220.919 219.934 219.562 213.938 219.691 210.981 L 219.632 202.653 C 219.632 202.653 220.089 199.951 221.511 195.353 C 223.019 190.476 225.796 186.231 227.553 183.998 C 229.31 181.766 232.213 178.419 235.242 176.396 C 238.271 174.374 240.49 171.882 241.197 171.077 C 241.904 170.272 243.625 167.318 245.023 164.513 C 246.42 161.708 248.627 156.516 249.927 152.975 C 251.226 149.434 252.29 145.655 252.29 144.577 C 252.29 143.499 252.659 142.617 253.109 142.617 C 253.56 142.617 253.914 142.123 251.522 138.566 C 249.131 135.007 245.805 130.113 245.282 130.639 C 244.846 131.077 240.715 131.465 236.104 131.501 C 230.043 131.548 226.51 131.164 223.357 130.116 C 220.958 129.319 217.68 127.837 216.072 126.823 C 214.465 125.808 212.346 123.844 211.363 122.458 C 210.38 121.072 209.078 118.274 208.468 116.241 C 207.859 114.208 207.361 110.234 207.361 107.41 C 207.361 104.357 213.43 99.313 214.42 96.333 C 215.095 94.305 211.381 90.691 213.204 85.923 C 213.86 84.209 214.534 82.466 215.188 80.8 C 217.908 73.867 219.225 71.859 219.988 71.652 C 221.116 71.348 222.327 70.114 221.18 70.03 C 220.474 69.978 218.048 69.614 216.106 71.001 Z M 254.486 169.517 C 250.735 170.11 246.253 172.888 244.267 173.688 C 242.281 174.487 239.371 175.944 237.799 176.926 C 236.227 177.906 233.256 180.592 231.197 182.893 C 229.137 185.194 226.337 189.35 224.976 192.13 C 223.146 195.861 222.38 198.753 222.046 203.187 C 221.738 207.288 222.028 211.349 222.962 215.996 C 223.714 219.738 225.363 224.975 226.626 227.634 C 227.888 230.294 230.118 233.621 231.58 235.028 C 233.042 236.436 236.946 239.031 240.256 240.795 C 243.565 242.559 251.147 245.471 257.104 247.266 C 263.061 249.061 271.817 251.803 277.112 252.716 C 283.882 253.884 294.595 255.534 307.685 255.897 L 324.567 255.109 L 336.962 249.807 C 338.534 248.602 341.231 245.734 342.954 243.434 C 344.677 241.135 346.869 237.259 347.827 234.822 C 348.987 231.865 349.71 227.824 349.998 222.681 C 350.327 216.783 350.108 213.863 349.059 210.239 C 348.305 207.635 346.464 203.126 344.968 200.218 C 343.472 197.311 341.787 194.367 341.224 193.677 C 340.66 192.988 340.429 189.158 337.54 187.808 C 334.651 186.457 330.995 183.905 329.283 182.399 C 327.572 180.894 313.848 181.478 312.603 179.51 C 310.687 176.48 309.637 175.708 305.725 174.455 C 303.185 173.642 300.711 167.263 296.298 166.14 C 290.183 164.583 281.873 168.157 273.312 167.91 C 266.268 167.706 258.762 168.843 254.486 169.517 Z M 224.59 264.753 C 224.201 264.769 219.991 267.349 213.419 268.85 C 203.876 271.03 190.965 272.384 190.965 272.384 L 168.959 273.547 C 154.038 273.547 144.499 272.578 144.06 273.967 C 143.801 274.789 141.695 279.289 141.043 283.01 C 140.391 286.732 139.857 291.148 139.856 292.823 C 139.856 294.722 138.696 295.457 137.981 295.732 C 137.35 295.975 155.612 300.62 164.438 301.752 C 173.263 302.885 185.719 304.333 192.117 304.972 C 198.516 305.61 208.083 306.345 213.378 306.605 C 218.674 306.865 242.502 306.834 246.253 307.246 C 250.003 307.658 248.367 306.832 248.367 306.832 L 246.953 296.759 C 246.175 291.219 244.814 283.604 243.929 279.836 C 243.043 276.069 225.662 272.026 225.382 270.143 C 224.957 267.296 226.032 264.695 224.59 264.753 Z M 249.918 271.553 C 249.902 271.775 249.935 271.332 249.918 271.553 Z"
              stroke="none" fill="#f9f5da" fill-rule="evenodd" style="stroke-width: 1;">
            <bx:title>piel</bx:title>
        </path>
        <path d="M 306.446 103.485 C 303.798 104.037 299.285 105.303 296.417 106.299 C 293.549 107.296 289.11 109.292 286.553 110.736 C 283.996 112.181 279.535 115.322 276.64 117.716 C 273.745 120.109 270.32 123.601 269.028 125.475 C 267.736 127.349 264.976 131.897 262.894 135.583 C 260.813 139.269 258.485 143.539 257.721 145.07 C 256.957 146.602 254.329 153.254 251.88 159.851 C 249.431 166.449 247.408 172.531 247.532 172.635 C 247.656 172.74 251.488 171.701 255.901 171.056 C 261.284 170.27 267.044 170.327 273.773 170.619 C 280.485 170.91 286.634 171.416 292.004 172.755 C 296.417 173.855 301.607 175.32 303.538 176.012 C 305.469 176.703 307.309 177.269 307.628 177.269 C 307.947 177.269 330.976 196.149 332.007 197.326 C 332.631 198.04 334.236 200.819 335.571 203.501 C 336.907 206.184 338.617 210.512 339.371 213.119 C 340.423 216.749 340.643 219.665 340.313 225.567 C 340.024 230.722 339.304 234.738 338.14 237.691 C 337.183 240.119 335.136 243.834 333.593 245.945 C 332.05 248.057 329.558 250.802 328.056 252.046 L 324.061 254.833 L 332.875 254.723 C 335.405 254.373 341.145 253.567 346.016 252.931 C 350.887 252.295 357.972 250.188 362.147 249.022 C 366.322 247.857 372.99 245.326 376.966 243.398 C 380.941 241.47 384.881 239.132 385.719 238.201 C 387.223 236.531 385.748 235.314 383.517 230.748 C 382.273 228.202 381.527 224.483 380.553 222.267 C 379.579 220.051 378.576 215.33 377.671 211.341 C 376.767 207.353 375.687 199.91 375.007 194.37 C 374.327 188.83 373.584 181.033 373.354 177.044 C 373.125 173.055 373.304 162.539 373.751 153.674 C 374.2 144.81 374.924 135.2 375.36 132.319 C 375.796 129.439 377.07 125.28 378.19 123.08 C 380.136 119.252 377.49 118.851 376.097 117.797 C 375.296 117.191 370.67 114.76 365.816 112.396 C 360.962 110.031 354.464 107.347 351.375 106.432 C 348.286 105.515 342.553 104.217 338.633 103.546 C 334.58 102.851 327.143 102.359 321.384 102.404 C 315.816 102.448 309.093 102.934 306.446 103.485 Z M 395.509 263.555 C 395.198 262.273 394.345 265.272 390.724 267.502 C 388.186 269.064 383.584 271.612 380.495 273.164 C 377.406 274.715 371.088 277.274 366.454 278.849 C 361.821 280.424 355.223 282.284 351.791 282.983 C 348.36 283.681 340.843 284.663 335.088 285.163 C 327.158 285.853 322.088 285.841 314.147 285.113 C 308.384 284.584 300.376 283.465 296.351 282.627 C 292.325 281.788 287.454 280.538 285.524 279.847 C 283.595 279.156 279.895 277.635 277.301 276.466 C 273.775 274.877 272.804 272.012 272.753 270.738 C 272.692 269.226 270.714 275.429 270.143 277.219 C 269.79 278.327 269.864 277.972 268.277 281.649 C 266.691 285.326 264.224 294.841 263.087 298.587 C 261.949 302.333 259.511 305.922 259.511 306.562 C 259.511 307.351 259.19 308.135 267.133 307.994 C 275.076 307.854 290.257 307.209 300.869 306.561 C 311.481 305.913 325.922 304.649 332.961 303.752 C 340 302.856 351.896 301.033 359.398 299.701 C 366.899 298.369 376.087 296.557 379.814 295.675 C 383.542 294.793 390.401 292.964 395.058 291.609 C 399.714 290.254 403.824 288.859 404.189 288.507 C 404.554 288.155 403.113 279.759 400.697 274.054 C 398.281 268.348 395.723 264.442 395.509 263.555 Z"
              stroke="none" fill="#fce19f" fill-rule="evenodd" style="stroke-width: 1;">
            <bx:title>perro</bx:title>
        </path>
        <path d="M 280.575 72.982 C 280.833 73.242 263.562 74.448 262.887 76.731 C 262.212 79.013 246.877 92.26 244.022 95.818 C 241.166 99.376 243.686 113.125 240.541 116.105 C 237.397 119.085 250.055 119.248 250.301 119.248 C 250.548 119.248 252.269 118.475 254.127 117.531 C 255.985 116.587 258.463 115.136 259.634 114.307 C 260.806 113.479 262.435 112.801 263.256 112.801 C 264.076 112.801 266.623 114.07 268.917 115.622 C 271.21 117.173 273.944 119.743 274.199 119.743 C 274.452 119.743 276.918 117.501 279.82 115.266 C 282.723 113.031 287.451 110.131 290.327 108.822 C 293.202 107.512 296.951 106.063 298.659 105.601 C 300.366 105.14 301.763 104.64 301.763 104.493 C 301.763 104.344 300.467 101.602 299.534 99.483 C 298.601 97.364 296.129 92.648 294.041 89.004 C 291.954 85.36 288.545 80.159 286.465 77.444 C 284.386 74.73 282.103 72.509 281.394 72.509 C 280.684 72.509 280.315 72.721 280.575 72.982 Z M 325.278 158.508 C 324.187 159.27 322.675 160.63 321.917 161.53 C 321.16 162.43 319.96 164.882 319.25 166.978 C 318.541 169.075 318.192 171.522 318.475 172.418 C 318.809 173.475 319.688 174.046 320.982 174.046 C 322.511 174.046 323.256 173.372 324.179 171.15 C 324.842 169.558 325.257 167.874 325.103 167.407 C 324.948 166.941 324.373 168.062 323.825 169.899 C 323.09 172.362 322.409 173.24 321.231 173.24 C 320.352 173.24 319.431 172.709 319.183 172.061 C 318.935 171.413 319.317 169.114 320.032 166.953 C 320.747 164.792 322.377 162.017 323.656 160.787 C 325.229 159.274 327.102 158.427 329.451 158.168 C 332.184 157.867 333.519 158.19 335.73 159.687 C 337.274 160.732 339.169 162.849 339.94 164.391 C 340.832 166.173 341.344 166.653 341.344 165.708 C 341.345 164.89 340.596 163.163 339.678 161.868 C 338.761 160.575 336.973 158.978 335.707 158.319 C 334.439 157.661 332.021 157.123 330.332 157.123 C 328.643 157.123 326.369 157.746 325.278 158.508 Z M 332.893 163.852 C 333.963 164.637 334.463 166.259 334.692 169.694 C 334.868 172.309 335.179 175.264 335.386 176.262 C 335.671 177.642 336.32 178.075 338.105 178.075 C 339.394 178.075 340.678 177.702 340.958 177.248 C 341.238 176.793 341.604 174.346 341.774 171.808 L 342.08 167.196 L 341.389 171.51 C 341.01 173.883 340.341 176.183 339.904 176.622 C 339.467 177.061 338.439 177.291 337.62 177.134 C 336.388 176.898 336.054 175.855 335.683 171.082 C 335.437 167.911 334.761 164.742 334.181 164.04 C 333.601 163.338 332.74 162.764 332.269 162.764 C 331.798 162.764 332.079 163.254 332.893 163.852 Z M 446.493 195.602 C 445.898 197.264 378.908 193.979 378.908 194.746 C 378.908 195.514 380.159 200.897 381.509 204.951 C 382.859 209.006 385.266 214.68 386.857 217.561 C 388.448 220.442 391.224 224.721 393.026 227.07 C 394.829 229.42 398.014 232.405 400.104 233.705 C 402.194 235.004 405.554 236.484 407.573 236.995 C 409.591 237.505 413.164 237.724 415.514 237.48 C 417.863 237.237 421.903 236.039 424.492 234.82 C 427.601 233.355 431.267 230.529 435.292 226.493 C 439.559 222.213 442.125 218.812 443.852 215.144 C 445.208 212.263 446.888 207.678 447.586 204.955 C 448.284 202.231 448.855 198.333 448.855 196.292 C 448.855 194.251 448.566 190.423 448.214 190.423 L 446.493 195.602 Z"
              stroke="none" fill="#a8a1cb" fill-rule="evenodd" style="stroke-width: 1;">
            <bx:title>sumbra orejas</bx:title>
        </path>
        <path d="M 387.478 249.948 C 385.272 251.339 380.859 253.674 377.672 255.136 C 374.484 256.597 368.347 258.873 364.033 260.194 C 359.718 261.514 352.603 263.187 348.22 263.912 C 343.837 264.637 336.255 265.507 331.372 265.844 C 326.488 266.181 319.062 266.343 314.87 266.206 C 310.678 266.069 303.999 265.549 300.027 265.051 C 296.056 264.554 289.738 263.615 285.987 262.965 C 282.236 262.316 277.866 261.584 276.276 261.34 C 273.736 260.951 273.323 261.128 272.877 262.8 C 272.598 263.847 272.365 266.081 272.359 267.764 C 272.351 270.021 272.887 271.326 274.402 272.736 C 275.531 273.788 279.052 275.584 282.224 276.727 C 285.397 277.87 291.062 279.515 294.812 280.383 C 298.563 281.251 304.691 282.339 308.431 282.8 C 312.169 283.263 319.39 283.634 324.477 283.626 C 329.563 283.618 337.415 283.084 341.924 282.44 C 346.435 281.796 353.024 280.526 356.566 279.618 C 360.107 278.71 365.623 277.022 368.823 275.867 C 372.024 274.711 377.71 272.219 381.461 270.327 C 385.212 268.434 389.725 265.729 391.49 264.317 C 393.255 262.903 394.97 261.019 395.302 260.129 C 395.645 259.209 395.377 256.69 394.68 254.28 C 394.006 251.952 393.013 249.455 392.472 248.732 C 391.585 247.544 391.104 247.661 387.478 249.948 Z"
              stroke="none" fill="#bfe4bc" fill-rule="evenodd" style="stroke-width: 1;">
            <bx:title>collarperro</bx:title>
        </path>
        <path d="M 86.456 92.789 C 85.486 93.273 84.138 94.843 83.46 96.277 C 82.783 97.712 81.612 101.382 80.858 104.433 C 79.795 108.734 79.493 113.511 79.512 125.695 C 79.531 137.717 79.945 144.03 81.271 152.569 C 82.224 158.708 83.004 165.325 83.004 167.276 L 83.004 170.822 L 81.984 185.715 C 81.984 185.715 82.53 203.538 82.692 204.212 C 82.854 204.886 96.466 206.032 101.016 206.394 C 105.566 206.756 128.698 206.326 129.423 206.383 C 130.148 206.441 132.546 206.408 134.752 206.312 C 136.959 206.215 141.123 205.646 144.006 205.047 C 146.89 204.448 152.341 202.834 156.121 201.46 C 160.709 199.792 164.565 197.692 167.726 195.139 C 170.331 193.037 174.14 189.089 176.192 186.367 C 178.244 183.645 180.679 179.388 181.603 176.908 C 182.527 174.427 183.691 169.776 184.189 166.573 C 184.732 163.082 184.885 157.441 184.569 152.491 C 184.28 147.949 184.603 143.307 184.263 142.38 C 183.999 141.664 183.649 136.414 183.252 131.204 C 182.811 125.403 176.967 106.051 176.38 104.905 C 175.508 103.199 159.68 106.685 157.694 106.977 L 155.267 107.335 C 155.267 107.335 141.365 111.611 141.011 111.634 C 140.657 111.658 139.099 111.954 137.545 112.293 C 134.952 112.86 134.071 112.471 126.714 107.499 C 122.31 104.523 115.818 100.721 112.288 99.049 C 108.758 97.379 103.703 95.293 101.056 94.416 C 98.408 93.537 94.437 92.615 92.23 92.363 C 89.961 92.105 87.453 92.29 86.456 92.789 Z M 120.566 265.782 C 120.288 266.511 111.609 282.09 111.548 282.211 C 111.487 282.333 110.829 283.778 110.086 285.423 C 109.341 287.069 108.991 288.563 109.307 288.744 C 109.623 288.924 113.837 290.242 118.673 291.674 C 123.507 293.106 131.27 295.144 135.922 296.204 C 140.574 297.265 145.373 298.426 146.586 298.43 C 148.642 298.436 148.796 297.912 148.835 294.721 C 148.859 292.838 149.537 287.879 150.342 283.702 C 150.973 280.429 151.887 275.697 152.236 273.384 C 152.355 272.596 143.048 271.225 138.856 270.226 C 134.664 269.228 128.68 268.233 125.955 266.962 C 121.991 265.113 121.236 264.553 120.89 265.458 L 120.566 265.782 Z M 224.414 264.753 C 223.843 265.195 227.338 278.224 227.747 279.265 C 228.082 280.12 229.019 284.265 229.829 288.476 C 230.638 292.687 231.547 298.529 231.848 301.46 L 232.395 306.788 L 238.453 307.302 C 241.784 307.585 247.885 307.816 252.01 307.816 C 256.136 307.816 259.511 307.658 259.511 307.463 C 259.511 307.269 258.96 304.64 258.286 301.621 C 257.613 298.601 256.159 292.62 255.056 288.329 C 253.953 284.038 252.247 278.749 251.266 276.575 L 247.097 267.758 C 247.097 267.758 245.092 264.048 243.95 262.278 C 242.573 260.143 239.494 256.095 239.494 256.095 L 232.245 260.832 L 224.414 264.753 Z"
              stroke="none" fill="#f2ce9e" fill-rule="evenodd" style="stroke-width: 1;">
            <bx:title>gato</bx:title>
        </path>
        <path d="M 261.837 68.719 C 259.366 69.764 254.492 72.181 251.006 74.089 C 247.52 75.997 241.677 79.504 238.022 81.883 C 234.366 84.262 231.153 86.208 230.883 86.208 C 230.613 86.208 221.775 83.804 218.17 87.461 C 214.525 91.159 212.915 98.51 211.898 100.646 C 210.891 102.759 213.433 107.782 213.201 109.521 C 212.969 111.259 213.004 114.41 213.279 115.511 C 213.554 116.611 214.76 118.683 215.959 120.114 C 217.158 121.545 219.747 123.431 221.712 124.304 C 224.29 125.45 226.977 125.878 231.366 125.843 C 235.33 125.811 239.095 125.217 242.181 124.135 C 244.784 123.222 250.548 119.248 250.301 119.248 C 250.055 119.248 252.427 116.81 255.571 113.83 C 258.716 110.85 263.625 105.502 266.481 101.944 C 269.336 98.386 273.229 92.388 275.131 88.616 C 277.034 84.843 279.143 79.888 279.818 77.606 C 280.493 75.323 280.833 73.242 280.575 72.982 C 280.315 72.721 280.707 72.509 281.443 72.509 C 282.191 72.509 284.824 75.309 287.394 78.84 C 289.929 82.323 293.635 88.386 294.213 89.225 C 294.789 90.064 293.269 86.709 292.251 84.859 C 291.232 83.009 288.694 79.303 286.609 76.623 C 284.524 73.945 281.322 70.758 279.495 69.544 C 276.972 67.867 274.987 67.273 271.251 67.077 C 267.47 66.879 265.291 67.259 261.837 68.719 Z M 380.659 119.539 C 378.52 120.237 377.428 121.321 376.078 124.083 C 375.103 126.077 373.932 130.066 373.477 132.947 C 373.021 135.828 372.649 141.993 372.649 146.647 C 372.65 151.3 373.185 160.004 373.836 165.987 C 374.488 171.97 375.796 180.855 376.744 185.73 C 377.691 190.606 378.701 194.776 378.988 194.998 C 379.274 195.219 380.749 197.369 382.265 199.775 C 383.781 202.181 387.053 206.648 389.537 209.7 C 392.02 212.754 395.752 216.465 397.829 217.948 C 399.906 219.431 403.442 221.087 405.686 221.628 C 408.103 222.21 412.023 222.421 415.302 222.145 C 418.656 221.863 422.58 220.878 425.256 219.648 C 427.817 218.47 431.615 215.659 434.296 212.955 C 436.839 210.392 440.381 206.118 442.166 203.459 C 443.952 200.8 446.071 197.212 446.666 195.55 C 447.07 194.42 448.19 192.822 448.349 190.667 C 448.423 189.652 448.125 188.77 447.732 187.286 C 446.6 183.015 444.374 175.478 442.834 172.539 C 441.295 169.6 437.598 163.933 434.617 159.945 C 431.637 155.957 425.764 149.249 421.568 145.037 C 417.372 140.825 411.234 135.172 407.929 132.474 C 404.624 129.776 400.088 126.283 397.85 124.712 C 395.611 123.14 392.723 121.319 391.431 120.665 C 390.14 120.01 387.819 119.283 386.275 119.048 C 384.731 118.813 382.203 119.034 380.659 119.539 Z M 331.467 139.55 C 328.902 139.883 324.985 141.148 322.764 142.363 C 320.541 143.578 317.154 146.325 315.235 148.469 C 313.317 150.612 311.005 154.356 310.099 156.789 C 308.991 159.764 308.451 163.134 308.451 167.082 C 308.451 170.359 309.021 174.631 309.74 176.751 C 310.48 178.933 312.726 182.415 315.018 184.933 C 317.627 187.801 320.857 190.231 324.353 191.956 C 329.282 194.389 330.293 194.591 337.327 194.557 C 343.977 194.524 345.485 194.243 349.072 192.376 C 351.335 191.198 354.667 188.718 356.474 186.866 C 358.282 185.014 360.507 181.95 361.419 180.058 C 362.331 178.166 363.49 174.385 363.996 171.657 C 364.708 167.809 364.685 165.577 363.894 161.708 C 363.334 158.964 361.932 154.973 360.778 152.836 C 359.625 150.701 357.476 147.889 356.002 146.589 C 354.527 145.29 351.617 143.359 349.533 142.298 C 347.451 141.238 343.583 140.05 340.938 139.658 C 338.294 139.267 334.032 139.218 331.467 139.55 Z"
              stroke="none" fill="#c8c0e2" fill-rule="evenodd" style="stroke-width: 1;">
            <bx:title>mancha perro</bx:title>
        </path>
        <path d="M 227.148 250.507 C 222.663 252.264 216.268 255.865 209.737 257.444 C 203.207 259.021 190.411 260.935 184.145 261.874 C 176.434 263.028 168.7 262.843 160.827 262.822 C 154.429 262.805 145.543 262.241 141.082 261.569 C 136.62 260.897 119.687 256.355 119.522 257.392 C 119.293 258.834 119.906 261.476 121.404 262.923 C 121.912 263.413 122.949 263.499 123.512 263.715 C 126.934 265.028 137.019 267.285 140.77 268.198 C 144.521 269.109 150.649 270.237 154.388 270.705 C 158.127 271.171 164.626 271.531 168.83 271.503 C 173.033 271.476 179.18 271.169 182.49 270.821 C 185.799 270.473 188.642 270.298 188.806 270.433 C 188.971 270.567 187.978 272.387 186.6 274.477 C 184.566 277.561 184.094 279.1 184.094 282.65 C 184.094 285.055 184.692 288.289 185.423 289.836 C 186.154 291.383 188.05 293.51 189.635 294.563 C 191.337 295.692 194.327 296.681 196.931 296.974 C 200.65 297.394 201.912 297.168 204.954 295.533 C 207.209 294.322 209.238 292.405 210.357 290.43 C 211.513 288.389 212.153 285.9 212.162 283.414 C 212.169 281.294 211.681 278.371 211.076 276.918 C 210.472 275.465 208.455 272.967 206.595 271.368 C 203.565 268.763 203.366 268.382 204.685 267.711 C 205.495 267.299 215.768 264.85 219.519 263.691 C 223.27 262.532 225.517 261.615 229.489 259.342 C 233.46 257.07 237.31 253.97 238.391 252.914 C 239.747 251.59 237.283 247.087 236.583 245.117 L 227.148 250.507 Z M 194.921 275.59 C 194.646 276.037 194.645 277.113 194.919 277.981 C 195.314 279.232 194.953 279.661 193.166 280.055 C 191.927 280.328 190.463 280.691 189.911 280.862 C 189.36 281.033 188.908 282.018 188.908 283.052 C 188.908 284.085 189.341 285.365 189.871 285.897 C 190.4 286.429 191.821 286.864 193.03 286.864 C 194.92 286.864 195.26 287.228 195.477 289.483 C 195.708 291.891 195.954 292.102 198.536 292.102 C 201.118 292.102 201.364 291.891 201.595 289.483 C 201.779 287.561 202.242 286.864 203.335 286.864 C 204.153 286.864 205.394 286.644 206.092 286.375 C 206.949 286.045 207.361 284.866 207.361 282.749 C 207.361 279.701 207.282 279.612 204.553 279.612 C 201.968 279.612 201.745 279.42 201.745 277.194 C 201.745 274.917 201.561 274.777 198.583 274.777 C 196.844 274.777 195.196 275.142 194.921 275.59 Z"
              stroke="none" fill="#b5cce8" fill-rule="evenodd" style="stroke-width: 1;">
            <bx:title>collar gato</bx:title>
        </path>
        <path d="M 219.657 71.501 C 219.388 72.277 216.639 75.32 215.207 78.865 C 213.775 82.411 211.053 89.398 209.459 94.09 C 207.865 98.783 207.3 107.971 207.3 109.082 C 207.3 110.193 208.872 110.02 209.738 110.808 C 210.604 111.595 211.821 109.577 212.443 109.338 C 213.065 109.098 213.825 107.876 214.134 106.621 C 214.443 105.366 215.78 102.633 217.107 100.547 C 218.434 98.46 221.838 94.574 224.672 91.911 C 227.507 89.248 229.826 86.683 229.826 86.211 C 229.826 85.738 229.073 83.097 228.153 80.34 C 227.233 77.584 225.589 74.151 224.502 72.71 C 223.414 71.269 221.989 70.091 221.336 70.091 C 220.682 70.091 219.927 70.726 219.657 71.501 Z M 200.351 87.581 C 199.037 89.264 195.933 93.814 193.453 97.691 C 189.742 103.495 188.586 104.743 186.92 104.743 C 185.807 104.743 184.902 105.014 184.909 105.347 C 184.916 105.68 186.124 110.777 187.594 116.675 C 189.065 122.572 190.99 128.374 191.873 129.568 C 192.757 130.762 194.413 131.851 195.553 131.988 C 197.043 132.168 197.9 131.722 198.602 130.406 C 199.139 129.398 199.6 125.478 199.625 121.694 C 199.652 117.911 199.528 112.096 199.351 108.772 C 199.1 104.055 199.513 100.806 201.234 93.976 C 202.446 89.162 203.281 85.065 203.09 84.873 C 202.898 84.679 201.666 85.899 200.351 87.581 Z M 92.529 106.075 C 91.708 107.069 91.442 110.196 91.484 118.365 C 91.524 126.005 91.958 130.903 92.92 134.548 C 93.679 137.423 94.835 140.596 95.49 141.599 C 96.145 142.602 97.384 143.423 98.244 143.423 C 99.105 143.423 102.797 140.613 106.45 137.178 C 110.102 133.743 114.972 129.51 117.27 127.77 C 119.57 126.03 121.637 124.118 121.865 123.52 C 122.094 122.924 120.98 120.99 119.391 119.223 C 117.802 117.456 114.29 114.331 111.587 112.278 C 108.884 110.225 104.867 107.693 102.66 106.652 C 100.454 105.61 97.52 104.755 96.139 104.751 C 94.759 104.746 93.135 105.342 92.529 106.075 Z M 166.71 105.469 C 163.988 105.735 161.567 106.147 161.329 106.387 C 161.091 106.627 162.832 111.522 165.198 117.266 C 167.564 123.01 170.708 130.784 172.184 134.543 C 174.126 139.488 175.42 141.651 176.866 142.37 C 178.472 143.167 179.181 143.152 180.477 142.293 C 181.646 141.517 182.161 140.142 182.354 137.287 C 182.5 135.121 182.194 130.665 181.674 127.383 C 181.154 124.101 179.502 117.755 178.002 113.281 C 176.503 108.806 175.274 105.054 175.272 104.944 C 175.27 104.834 174.457 104.798 173.464 104.865 C 172.47 104.933 169.432 105.205 166.71 105.469 Z M 146.53 109.359 C 142.699 110.492 142.308 110.812 142.724 112.48 C 142.979 113.501 145.165 118.797 147.58 124.247 C 150.339 130.473 152.876 134.98 154.406 136.372 C 155.746 137.591 157.213 138.588 157.667 138.588 C 158.122 138.588 159.428 137.649 160.571 136.501 C 162.521 134.543 162.618 134.079 162.148 128.996 C 161.872 126.016 160.965 121.589 160.133 119.158 C 159.3 116.727 157.844 113.214 156.899 111.352 C 155.491 108.581 154.78 107.978 152.989 108.031 C 151.784 108.067 148.877 108.665 146.53 109.359 Z M 82.548 172.688 C 82.275 173.403 81.995 176.416 81.926 179.383 C 81.801 184.729 81.822 184.784 84.207 185.461 C 85.531 185.837 90.225 186.156 94.637 186.171 C 99.444 186.187 104.203 185.727 106.51 185.024 C 108.627 184.378 111.245 183.268 112.326 182.555 C 113.645 181.687 114.294 180.512 114.294 178.987 C 114.294 177.736 113.657 176.133 112.878 175.426 C 112.099 174.718 109.843 173.747 107.863 173.267 C 105.884 172.788 99.49 172.169 93.655 171.892 C 84.338 171.45 82.985 171.547 82.548 172.688 Z M 234.639 266.422 C 230.889 269.762 227.698 273.036 227.548 273.699 C 227.399 274.362 227.487 275.746 227.744 276.774 C 228.022 277.887 229.157 278.976 230.547 279.463 C 232.091 280.003 234.064 280.015 236.368 279.497 C 238.286 279.066 241.299 277.865 243.064 276.829 C 244.83 275.792 246.94 274.206 247.752 273.305 C 249.194 271.703 249.16 271.538 246.247 265.969 C 244.607 262.835 242.86 260.289 242.362 260.311 C 241.866 260.332 238.39 263.082 234.639 266.422 Z M 115.664 274.243 C 114.027 277.052 112.689 279.911 112.689 280.595 C 112.689 281.393 113.964 282.161 116.254 282.739 C 118.214 283.236 121.383 283.641 123.296 283.641 C 125.208 283.641 127.576 283.076 128.556 282.386 C 129.538 281.696 130.34 280.317 130.34 279.321 C 130.34 278.317 129.177 276.418 127.732 275.061 C 126.298 273.714 123.819 271.83 122.222 270.874 C 120.626 269.918 119.166 269.136 118.979 269.136 C 118.791 269.136 117.3 271.434 115.664 274.243 Z"
              stroke="none" fill="#eaa69f" fill-rule="evenodd" style="stroke-width: 1;">
            <bx:title>manchas gato</bx:title>
        </path>
        <path d="M 270.342 145.593 C 269.459 145.775 267.895 146.345 266.866 146.86 C 265.836 147.375 264.122 149.292 263.055 151.12 C 261.951 153.011 261.115 155.726 261.115 157.42 C 261.115 159.334 261.549 160.564 262.329 160.864 C 262.997 161.122 264.033 160.923 264.633 160.423 C 265.233 159.924 265.923 158.281 266.167 156.772 C 266.411 155.264 267.22 153.093 267.966 151.95 C 268.876 150.555 270.044 149.87 271.513 149.87 C 272.718 149.87 274.3 150.532 275.029 151.342 C 275.785 152.18 276.575 154.932 276.868 157.744 C 277.207 161.006 277.786 162.832 278.577 163.137 C 279.234 163.39 280.239 163.208 280.811 162.731 C 281.534 162.128 281.728 160.472 281.447 157.277 C 281.225 154.755 280.675 151.711 280.225 150.514 C 279.775 149.316 278.631 147.833 277.682 147.216 C 276.734 146.6 275.056 145.909 273.952 145.679 C 272.849 145.45 271.225 145.411 270.342 145.593 Z M 217.791 152.766 C 216.247 153.438 213.957 154.965 212.703 156.16 C 211.45 157.354 209.713 159.718 208.846 161.413 C 207.969 163.125 207.378 165.631 207.515 167.054 C 207.703 169.001 208.194 169.675 209.567 169.871 C 211.075 170.086 211.373 169.752 211.373 167.844 C 211.373 166.587 212.041 164.296 212.858 162.751 C 213.675 161.207 215.534 159.128 216.988 158.13 C 218.64 156.998 220.833 156.317 222.83 156.317 C 224.662 156.317 227.173 157.029 228.714 157.986 C 230.193 158.904 232.273 160.771 233.336 162.135 C 234.615 163.777 235.703 164.447 236.559 164.117 C 237.268 163.844 237.849 162.763 237.849 161.714 C 237.849 160.63 236.551 158.4 234.84 156.542 C 232.975 154.516 230.612 152.936 228.622 152.383 C 226.857 151.892 224.33 151.503 223.006 151.518 C 221.682 151.533 219.335 152.094 217.791 152.766 Z M 326.904 158.496 C 326.243 158.738 324.718 159.855 323.516 160.98 C 322.314 162.104 320.747 164.792 320.032 166.953 C 319.317 169.114 318.935 171.413 319.183 172.061 C 319.431 172.709 320.352 173.24 321.231 173.24 C 322.392 173.24 323.084 172.383 323.766 170.098 C 324.281 168.371 325.573 166.014 326.638 164.86 C 327.846 163.552 329.429 162.764 330.85 162.764 C 332.102 162.764 333.601 163.338 334.181 164.04 C 334.761 164.742 335.437 167.915 335.683 171.091 C 336.088 176.304 336.307 176.891 337.935 177.123 C 339.268 177.313 339.948 176.827 340.542 175.258 C 340.984 174.09 341.345 171.799 341.344 170.165 C 341.344 168.532 340.712 165.934 339.94 164.391 C 339.169 162.849 337.311 160.764 335.812 159.758 C 334.312 158.751 331.965 157.958 330.597 157.992 C 329.228 158.027 327.566 158.254 326.904 158.496 Z M 145.989 162.511 C 145.109 162.756 142.888 163.995 141.054 165.263 C 139.051 166.645 137.023 169.011 135.976 171.183 C 135.017 173.172 134.35 175.627 134.493 176.639 C 134.65 177.75 135.388 178.57 136.359 178.709 C 137.636 178.893 138.256 178.117 139.386 174.923 C 140.291 172.362 141.709 170.26 143.297 169.124 C 144.711 168.114 147.464 167.181 149.66 166.969 C 152.827 166.663 154.196 166.986 157.185 168.746 C 159.195 169.929 161.46 171.878 162.219 173.075 C 162.978 174.274 163.968 175.521 164.419 175.847 C 164.871 176.172 165.486 176.444 165.788 176.451 C 166.089 176.457 166.564 175.739 166.844 174.855 C 167.154 173.872 166.651 171.993 165.553 170.031 C 164.563 168.262 162.335 165.827 160.601 164.62 C 158.124 162.897 156.391 162.387 152.519 162.245 C 149.808 162.145 146.869 162.264 145.989 162.511 Z M 189.513 179.363 C 187.261 180.059 185.185 181.337 184.432 182.491 C 183.687 183.632 183.375 185.126 183.679 186.089 C 183.99 187.074 186.108 188.627 188.953 189.956 C 193.027 191.86 193.778 192.552 194.206 194.802 C 194.48 196.245 194.462 199.049 194.166 201.032 C 193.802 203.469 192.864 205.406 191.271 207.006 C 189.974 208.308 187.867 209.604 186.587 209.887 C 185.209 210.191 183.099 209.912 181.413 209.205 C 179.847 208.548 178.098 207.258 177.527 206.339 C 176.955 205.42 175.852 204.668 175.076 204.668 C 174.17 204.668 173.664 205.283 173.664 206.386 C 173.664 207.33 174.954 209.325 176.529 210.818 C 179.071 213.225 179.897 213.532 183.829 213.532 C 186.268 213.532 189.462 212.962 190.925 212.264 C 192.388 211.567 194.53 209.627 195.684 207.954 L 197.783 204.912 L 201.504 206.805 C 203.552 207.845 206.26 208.697 207.523 208.697 C 208.786 208.697 211.064 208.175 212.584 207.537 C 214.105 206.898 216.086 205.176 216.988 203.709 C 217.889 202.242 218.528 200.163 218.41 199.089 C 218.29 198.015 217.736 196.986 217.178 196.802 C 216.604 196.613 215.644 197.717 214.968 199.343 C 214.31 200.925 212.862 202.817 211.753 203.547 C 210.343 204.474 208.751 204.743 206.479 204.437 C 204.689 204.196 202.481 203.333 201.572 202.52 C 200.663 201.707 199.427 199.875 198.826 198.448 C 198.225 197.022 197.733 194.845 197.733 193.611 C 197.733 192.338 198.95 189.648 200.541 187.399 C 202.086 185.217 203.35 182.602 203.35 181.587 C 203.35 180.573 202.652 179.368 201.798 178.909 C 200.944 178.45 198.687 178.1 196.783 178.131 C 194.879 178.162 191.607 178.716 189.513 179.363 Z M 242.914 182.131 C 241.507 182.571 239.612 183.881 238.702 185.043 C 237.648 186.388 237.046 188.344 237.046 190.42 C 237.046 192.214 237.774 195.193 238.665 197.04 C 239.554 198.886 241.63 201.755 243.278 203.415 C 244.925 205.076 247.266 206.952 248.479 207.586 C 250.609 208.699 250.686 208.964 250.686 215.245 C 250.686 221.57 250.609 221.828 247.958 224.492 C 245.729 226.73 244.619 227.232 241.887 227.232 C 240.049 227.232 237.846 226.856 236.993 226.397 C 236.138 225.937 234.903 224.273 234.249 222.699 C 233.575 221.08 232.617 219.983 232.043 220.172 C 231.486 220.357 230.917 221.271 230.78 222.204 C 230.642 223.136 231.1 225.005 231.796 226.357 C 232.492 227.709 234.121 229.366 235.415 230.038 C 236.71 230.71 239.502 231.259 241.619 231.258 C 244.11 231.256 246.321 230.69 247.877 229.658 C 249.201 228.78 250.898 227.615 251.648 227.071 C 252.825 226.218 253.653 226.766 257.666 231.051 C 260.685 234.277 263.876 236.734 266.756 238.052 C 269.197 239.168 273.619 240.426 276.583 240.848 C 279.664 241.286 283.98 241.33 286.658 240.949 C 289.235 240.584 293.131 239.374 295.316 238.262 C 297.502 237.15 300.733 234.666 302.498 232.743 C 304.263 230.82 306.513 227.574 307.498 225.53 C 308.483 223.487 309.062 221.22 308.784 220.494 C 308.507 219.768 307.783 219.173 307.176 219.173 C 306.568 219.173 305.163 220.974 304.052 223.176 C 302.942 225.376 300.711 228.506 299.094 230.13 C 297.478 231.754 294.138 234.014 291.672 235.154 C 288.24 236.741 285.875 237.23 281.574 237.248 C 278.179 237.262 274.286 236.691 271.73 235.807 C 269.404 235.002 265.722 232.931 263.549 231.206 C 261.375 229.48 258.705 226.52 257.614 224.628 C 256.343 222.42 255.432 219.243 255.073 215.759 C 254.633 211.495 254.748 210.266 255.608 210.036 C 256.21 209.875 259.103 209.164 262.035 208.458 C 264.967 207.752 269.193 206.045 271.425 204.665 C 273.657 203.287 276.222 200.957 277.125 199.49 C 278.027 198.023 278.766 195.735 278.766 194.407 C 278.766 193.078 278.043 191.067 277.158 189.938 C 276.274 188.809 273.925 187.095 271.939 186.129 C 269.952 185.164 266.433 183.859 264.119 183.231 C 261.805 182.601 256.663 181.917 252.691 181.71 C 248.72 181.502 244.32 181.691 242.914 182.131 Z M 68.964 197.179 C 64.551 197.845 60.474 198.771 59.904 199.238 C 59.322 199.713 59.171 200.392 59.559 200.782 C 59.946 201.171 64.281 200.902 69.421 200.169 C 76.449 199.166 82.152 198.962 93.835 199.298 C 102.219 199.539 112.689 200.311 117.102 201.013 C 121.514 201.717 125.759 202.489 126.533 202.73 C 127.389 202.996 128.135 202.658 128.437 201.868 C 128.71 201.153 128.737 200.372 128.497 200.13 C 128.256 199.889 126.677 199.362 124.988 198.96 C 123.298 198.558 117.405 197.683 111.892 197.015 C 106.378 196.349 96.269 195.841 89.427 195.886 C 82.585 195.931 73.376 196.513 68.964 197.179 Z M 109.881 209.473 C 105.468 210.27 98.067 211.891 93.434 213.075 C 88.8 214.259 83.114 215.934 80.797 216.797 C 78.481 217.661 74.6 219.118 72.173 220.037 C 69.66 220.988 67.76 222.202 67.76 222.857 C 67.76 223.49 68.277 224.008 68.909 224.008 C 69.54 224.008 72.947 222.938 76.478 221.63 C 80.01 220.323 87.706 217.983 93.581 216.431 C 99.458 214.879 107.514 213.049 111.486 212.364 C 115.457 211.679 120.151 211.114 121.916 211.106 C 123.681 211.098 125.937 210.874 126.93 210.607 C 127.923 210.339 128.735 209.619 128.735 209.006 C 128.735 208.16 127.427 207.907 123.32 207.957 C 120.341 207.993 114.294 208.675 109.881 209.473 Z M 120.311 219.014 C 116.781 220.656 110.729 223.7 106.864 225.78 C 102.997 227.86 96.318 231.944 92.021 234.855 C 87.723 237.766 82.791 241.352 81.061 242.822 C 78.756 244.781 78.062 245.88 78.464 246.931 C 78.94 248.178 79.208 248.222 80.505 247.268 C 81.325 246.664 84.119 244.548 86.712 242.567 C 89.306 240.586 94.858 236.798 99.05 234.149 C 103.242 231.5 109.38 227.893 112.689 226.133 C 115.999 224.374 121.234 221.935 124.323 220.714 C 127.513 219.452 130.051 217.944 130.198 217.221 C 130.377 216.345 129.878 215.962 128.593 215.989 C 127.568 216.012 123.841 217.373 120.311 219.014 Z"
              stroke="none" fill="#14324d" fill-rule="evenodd" style="stroke-width: 1;">
            <bx:title>ojos y bigote</bx:title>
        </path>
    </g>
</svg>
</file>

<file path="src/test/kotlin/cl/clinipets/backend/agendamiento/application/ClinipetsIntegrityTests.kt">
package cl.clinipets.backend.agendamiento.application

import cl.clinipets.agendamiento.api.FinalizarCitaRequest
import cl.clinipets.agendamiento.api.SignosVitalesRequest
import cl.clinipets.agendamiento.domain.*
import cl.clinipets.servicios.domain.*
import cl.clinipets.veterinaria.domain.*
import cl.clinipets.core.security.JwtPayload
import cl.clinipets.identity.domain.UserRole
import com.fasterxml.jackson.databind.ObjectMapper
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.mockito.ArgumentMatchers.any
import org.mockito.kotlin.doThrow
import org.mockito.kotlin.whenever
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.boot.test.mock.mockito.MockBean
import org.springframework.boot.test.mock.mockito.SpyBean
import org.springframework.http.MediaType
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.authentication
import org.springframework.test.context.ActiveProfiles
import org.springframework.test.web.servlet.MockMvc
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post
import org.springframework.test.web.servlet.result.MockMvcResultMatchers.*
import java.time.Instant
import java.time.LocalDate
import java.util.*
import java.util.concurrent.CompletableFuture
import java.util.concurrent.atomic.AtomicInteger

@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
class ClinipetsIntegrityTests {

    @Autowired
    private lateinit var mockMvc: MockMvc
    @Autowired
    private lateinit var objectMapper: ObjectMapper
    @Autowired
    private lateinit var citaRepository: CitaRepository
    @Autowired
    private lateinit var insumoRepository: InsumoRepository
    @Autowired
    private lateinit var servicioMedicoRepository: ServicioMedicoRepository
    @Autowired
    private lateinit var mascotaRepository: MascotaRepository
    @Autowired
    private lateinit var userRepository: cl.clinipets.identity.domain.UserRepository

    @MockBean
    private lateinit var storageService: cl.clinipets.core.storage.StorageService
    @SpyBean
    private lateinit var signosVitalesRepository: SignosVitalesRepository

    private lateinit var testMascotaId: UUID
    private lateinit var testServicioId: UUID
    private lateinit var testInsumoId: UUID
    private lateinit var testTutorId: UUID

    @BeforeEach
    fun setup() {
        citaRepository.deleteAll()
        servicioMedicoRepository.deleteAll()
        insumoRepository.deleteAll()
        mascotaRepository.deleteAll()
        userRepository.deleteAll()

        val tutor = userRepository.saveAndFlush(
            cl.clinipets.identity.domain.User(
                email = "tutor@test.com",
                name = "Tutor",
                passwordHash = "hash",
                role = UserRole.CLIENT
            )
        )
        testTutorId = tutor.id!!

        val insumo = insumoRepository.saveAndFlush(
            Insumo(
                nombre = "Gasas Esterilizadas",
                stockActual = 10.0,
                stockMinimo = 5,
                unidadMedida = "unidades"
            )
        )
        testInsumoId = insumo.id!!

        val servicio = servicioMedicoRepository.saveAndFlush(
            ServicioMedico(
                nombre = "Curaci√≥n Simple",
                precioBase = 5000,
                requierePeso = false,
                duracionMinutos = 15,
                activo = true
            )
        )
        testServicioId = servicio.id!!

        servicio.insumos.add(
            ServicioInsumo(
                servicio = servicio,
                insumo = insumo,
                cantidadRequerida = 1.0,
                critico = true
            )
        )
        servicioMedicoRepository.saveAndFlush(servicio)

        val mascota = mascotaRepository.saveAndFlush(
            Mascota(
                nombre = "Buddy",
                especie = Especie.PERRO,
                pesoActual = 10.0,
                raza = "Golden",
                sexo = Sexo.MACHO,
                fechaNacimiento = LocalDate.now().minusYears(2),
                tutor = tutor
            )
        )
        testMascotaId = mascota.id!!
    }

    private fun staffAuth() = authentication(
        UsernamePasswordAuthenticationToken(
            JwtPayload(UUID.randomUUID(), "staff@test.cl", UserRole.STAFF, Instant.now().plusSeconds(3600)),
            "token",
            listOf(org.springframework.security.core.authority.SimpleGrantedAuthority("ROLE_STAFF"))
        )
    )

    private fun userAuth() = authentication(
        UsernamePasswordAuthenticationToken(
            JwtPayload(UUID.randomUUID(), "user@test.cl", UserRole.CLIENT, Instant.now().plusSeconds(3600)),
            "token",
            listOf(org.springframework.security.core.authority.SimpleGrantedAuthority("ROLE_USER"))
        )
    )

    @Test
    fun `Test de Seguridad por Rol - Alertas de Inventario`() {
        mockMvc.perform(get("/api/v1/inventario/alertas").with(userAuth()))
            .andExpect(status().isForbidden)

        mockMvc.perform(get("/api/v1/inventario/alertas").with(staffAuth()))
            .andExpect(status().isOk)
    }

    @Test
    fun `Test de Integridad de Contrato - Pasaporte de Salud`() {
        mockMvc.perform(get("/api/mascotas/${testMascotaId}/pasaporte-salud").with(staffAuth()))
            .andExpect(status().isOk)
            .andExpect(content().contentType(MediaType.APPLICATION_JSON))
            .andExpect(jsonPath("$.mascotaId").value(testMascotaId.toString()))
    }

    @Test
    fun `Test de Atomicidad - Rollback si falla guardado clinico`() {
        val cita = citaRepository.saveAndFlush(
            Cita(
                fechaHoraInicio = Instant.now(),
                fechaHoraFin = Instant.now().plusSeconds(1800),
                estado = EstadoCita.CONFIRMADA,
                precioFinal = 5000,
                tutorId = testTutorId,
                origen = OrigenCita.APP
            )
        )
        cita.detalles.add(
            DetalleCita(
                cita = cita,
                servicio = servicioMedicoRepository.findById(testServicioId).get(),
                mascota = mascotaRepository.findById(testMascotaId).get(),
                precioUnitario = 5000
            )
        )
        citaRepository.saveAndFlush(cita)

        doThrow(RuntimeException("Error simulado")).whenever(signosVitalesRepository).save(any<SignosVitales>())

        val request = FinalizarCitaRequest(
            metodoPago = MetodoPago.EFECTIVO,
            signosVitales = mapOf(testMascotaId to SignosVitalesRequest(10.0, 38.5, "80bpm"))
        )

        mockMvc.perform(
            post("/api/v1/reservas/${cita.id}/finalizar")
                .with(staffAuth())
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request))
        )
            .andExpect(status().isInternalServerError)

        val insumo = insumoRepository.findById(testInsumoId).get()
        assertEquals(10.0, insumo.stockActual)
    }

    @Test
    fun `Test de Concurrencia - Stock nunca negativo`() {
        val insumo = insumoRepository.findById(testInsumoId).get()
        insumo.stockActual = 2.0
        insumoRepository.saveAndFlush(insumo)

        val citasIds = (1..5).map {
            val cita = citaRepository.saveAndFlush(
                Cita(
                    fechaHoraInicio = Instant.now(),
                    fechaHoraFin = Instant.now().plusSeconds(1800),
                    estado = EstadoCita.CONFIRMADA,
                    precioFinal = 5000,
                    tutorId = testTutorId,
                    origen = OrigenCita.APP
                )
            )
            cita.detalles.add(
                DetalleCita(
                    cita = cita,
                    servicio = servicioMedicoRepository.findById(testServicioId).get(),
                    mascota = mascotaRepository.findById(testMascotaId).get(),
                    precioUnitario = 5000
                )
            )
            citaRepository.saveAndFlush(cita).id!!
        }

        val successCount = AtomicInteger(0)
        val errorCount = AtomicInteger(0)

        val futures = citasIds.map { id ->
            CompletableFuture.runAsync {
                try {
                    val result = mockMvc.perform(
                        post("/api/v1/reservas/$id/finalizar")
                            .with(staffAuth())
                            .contentType(MediaType.APPLICATION_JSON)
                            .content(objectMapper.writeValueAsString(FinalizarCitaRequest(metodoPago = MetodoPago.EFECTIVO)))
                    )
                        .andReturn()

                    if (result.response.status == 200) successCount.incrementAndGet()
                    else errorCount.incrementAndGet()
                } catch (e: Exception) {
                    errorCount.incrementAndGet()
                }
            }
        }

        CompletableFuture.allOf(*futures.toTypedArray()).join()

        val stockFinal = insumoRepository.findById(testInsumoId).get().stockActual
        assertEquals(2, successCount.get())
        assertEquals(3, errorCount.get())
        assertEquals(0.0, stockFinal)
    }
}
</file>

<file path="src/test/kotlin/cl/clinipets/backend/agendamiento/application/TransactionalQAValidation.kt">
package cl.clinipets.backend.agendamiento.application

import cl.clinipets.agendamiento.api.FinalizarCitaRequest
import cl.clinipets.agendamiento.application.ReservaService
import cl.clinipets.agendamiento.domain.CitaRepository
import cl.clinipets.core.security.JwtPayload
import cl.clinipets.core.web.ConflictException
import cl.clinipets.identity.domain.UserRole
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.ActiveProfiles
import java.time.Instant
import java.util.*

@SpringBootTest
@ActiveProfiles("test")
class TransactionalQAValidation(
    @Autowired private val reservaService: ReservaService,
    @Autowired private val citaRepository: CitaRepository
) {

    @org.springframework.boot.test.mock.mockito.MockBean
    private lateinit var storageService: cl.clinipets.core.storage.StorageService

    @Test
    fun `finalizarCita debe fallar con ConflictException si no hay stock`() {
        // Escenario: Intentar finalizar una cita donde el servicio requiere 
        // m√°s insumos de los que hay disponibles f√≠sicamente en la DB.

        val staffPayload = JwtPayload(
            userId = UUID.randomUUID(),
            email = "staff@clinipets.cl",
            role = UserRole.STAFF,
            expiresAt = Instant.now().plusSeconds(3600)
        )

        // El test busca validar que la excepci√≥n lanzada sea ConflictException (409)
        // y no un Internal Server Error (500), cumpliendo el contrato de API.
        // Nota: En un test real, crear√≠amos la data necesaria aqu√≠.
    }
}
</file>

<file path="src/test/kotlin/cl/clinipets/backend/agendamiento/domain/PricingCalculatorTest.kt">
package cl.clinipets.backend.agendamiento.domain

import cl.clinipets.agendamiento.application.PrecioCalculado
import cl.clinipets.agendamiento.application.PricingCalculator
import cl.clinipets.agendamiento.api.DetalleReservaRequest
import cl.clinipets.servicios.application.DetalleCalculado
import cl.clinipets.servicios.application.PromoEngineService
import cl.clinipets.servicios.domain.CategoriaServicio
import cl.clinipets.servicios.domain.ServicioMedico
import cl.clinipets.veterinaria.domain.Especie
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertFalse
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test
import org.mockito.kotlin.any
import org.mockito.kotlin.mock
import org.mockito.kotlin.whenever
import java.time.LocalDate
import java.util.UUID

class PricingCalculatorTest {

    private val promoEngineService: PromoEngineService = mock()
    private val calculator = PricingCalculator(promoEngineService)

    @Test
    fun `calcula precio base sin descuentos`() {
        val servicioId = UUID.randomUUID()
        val servicio = ServicioMedico(
            id = servicioId,
            nombre = "Consulta General",
            precioBase = 1000,
            precioAbono = 200,
            requierePeso = false,
            duracionMinutos = 30,
            activo = true,
            categoria = CategoriaServicio.OTRO,
            especiesPermitidas = mutableSetOf(Especie.PERRO)
        )

        whenever(promoEngineService.calcularDescuentos(any(), any())).thenReturn(
            mapOf(
                servicioId to DetalleCalculado(
                    servicioId = servicioId,
                    precioFinal = 1000,
                    precioOriginal = 1000
                )
            )
        )

        val resultado = calculator.calcularPrecioFinal(servicio, null, LocalDate.now())

        assertEquals(PrecioCalculado(1000, 1000, 200, false, emptyList()), resultado)
    }

    @Test
    fun `aplica descuento desde promo engine`() {
        val servicioId = UUID.randomUUID()
        val servicio = ServicioMedico(
            id = servicioId,
            nombre = "Ba√±o Medicado",
            precioBase = 1000,
            precioAbono = 50,
            requierePeso = false,
            duracionMinutos = 20,
            activo = true,
            categoria = CategoriaServicio.OTRO,
            especiesPermitidas = mutableSetOf(Especie.GATO)
        )

        whenever(promoEngineService.calcularDescuentos(any(), any())).thenReturn(
            mapOf(
                servicioId to DetalleCalculado(
                    servicioId = servicioId,
                    precioFinal = 700,
                    precioOriginal = 1000,
                    notas = mutableListOf("Promo 30%")
                )
            )
        )

        val resultado = calculator.calcularPrecioFinal(servicio, null, LocalDate.now())

        assertEquals(700, resultado.precioFinal)
        assertEquals(1000, resultado.precioOriginal)
        assertEquals(50, resultado.abono)
        assertTrue(resultado.descuentoAplicado)
        assertEquals(listOf("Promo 30%"), resultado.notas)
    }
}
</file>

<file path="src/test/kotlin/cl/clinipets/core/api/InstantSerializationTest.kt">
package cl.clinipets.core.api

import com.fasterxml.jackson.databind.ObjectMapper
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.autoconfigure.json.JsonTest
import java.time.Instant

@JsonTest
class InstantSerializationTest {

    @Autowired
    lateinit var objectMapper: ObjectMapper

    @Test
    fun `Instant should serialize to ISO-8601 string`() {
        val now = Instant.now()
        val json = objectMapper.writeValueAsString(now)
        println("Serialized Instant: $json")
        
        // Check if it starts with a quote (string) or is a number
        assertTrue(json.startsWith("\""), "Instant should be serialized as a JSON string, but was: $json")
        // strict ISO check could be added but string check is enough to distinguish from timestamp
    }
}
</file>

<file path="src/test/kotlin/cl/clinipets/core/web/DomainExceptionsTest.kt">
package cl.clinipets.core.web

import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

class DomainExceptionsTest {

    @Test
    fun `DomainException should store the message correctly`() {
        val message = "This is a domain exception"
        val exception = DomainException(message)
        assertEquals(message, exception.message)
    }

    @Test
    fun `NotFoundException should store the message correctly`() {
        val message = "Resource not found"
        val exception = NotFoundException(message)
        assertEquals(message, exception.message)
    }

    @Test
    fun `ConflictException should store the message correctly`() {
        val message = "Conflict occurred"
        val exception = ConflictException(message)
        assertEquals(message, exception.message)
    }

    @Test
    fun `UnauthorizedException should store the message correctly`() {
        val message = "Unauthorized access"
        val exception = UnauthorizedException(message)
        assertEquals(message, exception.message)
    }

    @Test
    fun `BadRequestException should store the message correctly`() {
        val message = "Bad request received"
        val exception = BadRequestException(message)
        assertEquals(message, exception.message)
    }
}
</file>

<file path=".dockerignore">
# Archivos/carpetas que no se necesitan en el contexto de docker build
# Evitar borrar gradle/ ni gradlew, necesarios para el wrapper
auth/
.git
.git/**
.gitignore
.gitattributes
.idea
*.iml
**/.DS_Store

# Gradle caches y outputs
.gradle
.gradle/**
build
build/**
out
out/**

# Node (por si existe frontend dentro del repo)
node_modules
node_modules/**

# Logs y temporales
*.log
**/*.log
.tmp
**/.env
**/.env.*

# Mantener expl√≠citamente estos archivos en el contexto
!../clinipets-backend/Dockerfile
!.dockerignore
!gradlew
!gradlew.bat
!gradle/**
!settings.gradle.kts
!build.gradle.kts
!gradle.properties
!src/**
!build/libs/*.jar
</file>

<file path=".gitattributes">
/gradlew text eol=lf
*.bat text eol=crlf
*.jar binary
</file>

<file path="gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" -jar "%APP_HOME%\gradle\wrapper\gradle-wrapper.jar" %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="settings.gradle.kts">
rootProject.name = "backend"
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/api/BloqueoController.kt">
package cl.clinipets.agendamiento.api

import cl.clinipets.agendamiento.application.BloqueoService
import cl.clinipets.agendamiento.domain.BloqueoAgenda
import cl.clinipets.core.security.JwtPayload
import io.swagger.v3.oas.annotations.Operation
import jakarta.validation.Valid
import org.slf4j.LoggerFactory
import org.springframework.format.annotation.DateTimeFormat
import org.springframework.http.ResponseEntity
import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.web.bind.annotation.*
import java.time.Instant
import java.time.LocalDate
import java.util.UUID

data class BloqueoCreateRequest(
    val fechaHoraInicio: Instant,
    val fechaHoraFin: Instant,
    val motivo: String?
)

@RestController
@RequestMapping("/api/v1/bloqueos")
@PreAuthorize("hasAnyRole('STAFF', 'ADMIN')")
class BloqueoController(private val bloqueoService: BloqueoService) {
    private val logger = LoggerFactory.getLogger(BloqueoController::class.java)

    @Operation(summary = "Crear un bloqueo de agenda", operationId = "crearBloqueo")
    @PostMapping
    fun crear(
        @Valid @RequestBody request: BloqueoCreateRequest,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<BloqueoAgenda> {
        logger.info("[CREAR_BLOQUEO] Request. User: {}, Inicio: {}", principal.email, request.fechaHoraInicio)
        val bloqueo = bloqueoService.crearBloqueo(
            principal.userId,
            request.fechaHoraInicio,
            request.fechaHoraFin,
            request.motivo
        )
        logger.info("[CREAR_BLOQUEO] Fin request - Exitoso")
        return ResponseEntity.ok(bloqueo)
    }

    @Operation(summary = "Eliminar un bloqueo de agenda", operationId = "eliminarBloqueo")
    @DeleteMapping("/{id}")
    fun eliminar(@PathVariable id: UUID): ResponseEntity<Void> {
        logger.info("[ELIMINAR_BLOQUEO] Request. ID: {}", id)
        bloqueoService.eliminarBloqueo(id)
        logger.info("[ELIMINAR_BLOQUEO] Fin request - Exitoso")
        return ResponseEntity.noContent().build()
    }

    @Operation(summary = "Listar bloqueos por fecha", operationId = "listarBloqueos")
    @GetMapping
    fun listar(@RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) fecha: LocalDate): ResponseEntity<List<BloqueoAgenda>> {
        logger.info("[LISTAR_BLOQUEOS] Request. Fecha: {}", fecha)
        val bloqueos = bloqueoService.obtenerBloqueos(fecha)
        logger.info("[LISTAR_BLOQUEOS] Fin request - Encontrados: {}", bloqueos.size)
        return ResponseEntity.ok(bloqueos)
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/application/BloqueoService.kt">
package cl.clinipets.agendamiento.application

import cl.clinipets.agendamiento.domain.BloqueoAgenda
import cl.clinipets.agendamiento.domain.BloqueoAgendaRepository
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId
import java.util.UUID

@Service
class BloqueoService(
    private val bloqueoAgendaRepository: BloqueoAgendaRepository,
    private val clinicZoneId: ZoneId
) {
    private val logger = LoggerFactory.getLogger(BloqueoService::class.java)

    @Transactional
    fun crearBloqueo(vetId: UUID, inicio: Instant, fin: Instant, motivo: String?): BloqueoAgenda {
        logger.debug("[BLOQUEO_SERVICE] Creando bloqueo. VetID: {}, Inicio: {}, Fin: {}", vetId, inicio, fin)
        val bloqueo = BloqueoAgenda(
            veterinarioId = vetId,
            fechaHoraInicio = inicio,
            fechaHoraFin = fin,
            motivo = motivo
        )
        val saved = bloqueoAgendaRepository.save(bloqueo)
        logger.info("[BLOQUEO_SERVICE] Bloqueo creado con ID: {}", saved.id)
        return saved
    }

    @Transactional
    fun eliminarBloqueo(id: UUID) {
        logger.debug("[BLOQUEO_SERVICE] Eliminando bloqueo ID: {}", id)
        bloqueoAgendaRepository.deleteById(id)
        logger.info("[BLOQUEO_SERVICE] Bloqueo eliminado")
    }

    @Transactional(readOnly = true)
    fun obtenerBloqueos(fecha: LocalDate): List<BloqueoAgenda> {
        val inicioDia = fecha.atStartOfDay(clinicZoneId).toInstant()
        val finDia = fecha.plusDays(1).atStartOfDay(clinicZoneId).toInstant()
        logger.debug("[BLOQUEO_SERVICE] Buscando bloqueos para: {}", fecha)
        return bloqueoAgendaRepository.findByFechaHoraFinGreaterThanAndFechaHoraInicioLessThan(inicioDia, finDia)
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/config/TimeConfig.kt">
package cl.clinipets.core.config

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.data.auditing.DateTimeProvider
import org.springframework.data.jpa.repository.config.EnableJpaAuditing
import java.time.Clock
import java.time.Instant
import java.time.ZoneId
import java.util.Optional

@Configuration
@EnableJpaAuditing(dateTimeProviderRef = "auditingDateTimeProvider")
class TimeConfig {

    @Bean
    fun clock(): Clock {
        return Clock.systemUTC()
    }

    @Bean
    fun auditingDateTimeProvider(clock: Clock): DateTimeProvider {
        return DateTimeProvider { Optional.of(Instant.now(clock)) }
    }

    @Bean
    fun clinicZoneId(): ZoneId {
        return ZoneId.of("America/Santiago")
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/domain/AuditableEntity.kt">
package cl.clinipets.core.domain

import jakarta.persistence.Column
import jakarta.persistence.EntityListeners
import jakarta.persistence.MappedSuperclass
import org.springframework.data.annotation.CreatedDate
import org.springframework.data.annotation.LastModifiedDate
import org.springframework.data.jpa.domain.support.AuditingEntityListener
import java.time.Instant

@MappedSuperclass
@EntityListeners(AuditingEntityListener::class)
abstract class AuditableEntity {
    @CreatedDate
    @Column(nullable = false, updatable = false)
    var createdAt: Instant = Instant.EPOCH
        protected set

    @LastModifiedDate
    @Column(nullable = false)
    var updatedAt: Instant = Instant.EPOCH
        protected set
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/security/FirebaseFilter.kt">
package cl.clinipets.core.security

import cl.clinipets.identity.application.AuthService
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.FirebaseToken
import jakarta.servlet.FilterChain
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpServletResponse
import org.slf4j.LoggerFactory
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.core.authority.SimpleGrantedAuthority
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.stereotype.Component
import org.springframework.web.filter.OncePerRequestFilter
import java.time.Instant

@Component
class FirebaseFilter(
    private val authService: AuthService
) : OncePerRequestFilter() {

    private val logger = LoggerFactory.getLogger(FirebaseFilter::class.java)

    override fun doFilterInternal(
        request: HttpServletRequest,
        response: HttpServletResponse,
        filterChain: FilterChain
    ) {
        val header = request.getHeader("Authorization")
        if (header != null && header.startsWith("Bearer ")) {
            val token = header.substring(7)
            try {
                // 1. Verificar token con Firebase
                val decodedToken: FirebaseToken = FirebaseAuth.getInstance().verifyIdToken(token)

                // 2. Delegar sincronizaci√≥n/creaci√≥n al servicio
                // Esto asegura que el usuario exista en nuestra BD y tenga el rol correcto
                val user = authService.syncFirebaseUser(decodedToken)

                // 3. Construir Principal
                val principal = JwtPayload(
                    userId = user.id!!,
                    email = user.email,
                    role = user.role,
                    expiresAt = Instant.now().plusSeconds(3600) // Validez manejada por Firebase en realidad
                )

                val authorities = listOf(SimpleGrantedAuthority("ROLE_${user.role.name}"))
                val authentication = UsernamePasswordAuthenticationToken(principal, token, authorities)

                SecurityContextHolder.getContext().authentication = authentication

            } catch (e: Exception) {
                logger.error("[FIREBASE_AUTH] Error validando token: ${e.message}")
                SecurityContextHolder.clearContext()
                // Opcional: response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Invalid Token")
                // Pero dejamos que SecurityFilterChain maneje el rechazo si es necesario.
            }
        }
        filterChain.doFilter(request, response)
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/storage/MinioConfig.kt">
package cl.clinipets.core.storage

import io.minio.BucketExistsArgs
import io.minio.MakeBucketArgs
import io.minio.MinioClient
import org.springframework.boot.context.event.ApplicationReadyEvent
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Value
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.event.EventListener

@Configuration
@ConditionalOnProperty(name = ["minio.enabled"], havingValue = "true", matchIfMissing = true)
class MinioConfig {

    private val logger = LoggerFactory.getLogger(MinioConfig::class.java)

    @Value("\${minio.url}")
    private lateinit var url: String

    @Value("\${minio.access-key}")
    private lateinit var accessKey: String

    @Value("\${minio.secret-key}")
    private lateinit var secretKey: String

    @Value("\${minio.bucket-name}")
    private lateinit var bucketName: String

    @Bean
    fun minioClient(): MinioClient {
        return MinioClient.builder()
            .endpoint(url)
            .credentials(accessKey, secretKey)
            .build()
    }

    @EventListener(ApplicationReadyEvent::class)
    fun initBucket() {
        try {
            val client = minioClient()
            val exists = client.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build())
            if (!exists) {
                logger.info("[MINIO] Creando bucket: {}", bucketName)
                client.makeBucket(MakeBucketArgs.builder().bucket(bucketName).build())

                // Configurar pol√≠tica p√∫blica de lectura (opcional, para que las URLs sean accesibles sin firmar)
                // En un entorno real estricto, esto podr√≠a omitirse y usar URLs firmadas.
                // Aqu√≠ lo dejamos "privado" por defecto, el servicio generar√° URLs o stream.
            } else {
                logger.info("[MINIO] Bucket '{}' ya existe.", bucketName)
            }
        } catch (e: Exception) {
            logger.error("[MINIO] Error inicializando bucket: {}", e.message)
        }
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/web/ApiError.kt">
package cl.clinipets.core.web

import java.time.Instant

data class ApiError(
    val message: String,
    val code: String,
    val status: Int,
    val timestamp: Instant = Instant.now(),
    val path: String? = null,
    val validationErrors: List<String>? = null
)
</file>

<file path="src/main/kotlin/cl/clinipets/core/web/ConflictException.kt">
package cl.clinipets.core.web

import org.springframework.http.HttpStatus
import org.springframework.web.bind.annotation.ResponseStatus

@ResponseStatus(HttpStatus.CONFLICT)
class ConflictException(message: String) : RuntimeException(message)
</file>

<file path="src/main/kotlin/cl/clinipets/core/web/DomainExceptions.kt">
package cl.clinipets.core.web

open class DomainException(message: String) : RuntimeException(message)
class NotFoundException(message: String) : DomainException(message)
class UnauthorizedException(message: String) : DomainException(message)
class BadRequestException(message: String) : DomainException(message)
</file>

<file path="src/main/kotlin/cl/clinipets/identity/domain/AuthProvider.kt">
package cl.clinipets.identity.domain

enum class AuthProvider {
    GOOGLE,
    WHATSAPP,
    OTP,
    PHONE
}
</file>

<file path="src/main/kotlin/cl/clinipets/maestros/api/MaestrosController.kt">
package cl.clinipets.maestros.api

import cl.clinipets.maestros.application.RazasService
import cl.clinipets.veterinaria.domain.Especie
import io.swagger.v3.oas.annotations.Operation
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestParam
import org.slf4j.LoggerFactory
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/api/v1/maestros")
class MaestrosController(
    private val razasService: RazasService
) {
    private val logger = LoggerFactory.getLogger(MaestrosController::class.java)

    @Operation(summary = "Listar razas", description = "Devuelve una lista de razas, opcionalmente filtrada por especie")
    @GetMapping("/razas")
    fun listarRazas(
        @RequestParam(required = false) especie: Especie?
    ): ResponseEntity<List<String>> {
        logger.info("[LISTAR_RAZAS] Request recibida. Filtro Especie: {}", especie ?: "TODAS")
        val response = razasService.getRazas(especie)
        logger.info("[LISTAR_RAZAS] Fin request - Encontradas: {}", response.size)
        return ResponseEntity.ok(response)
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/maestros/application/RazasService.kt">
package cl.clinipets.maestros.application

import cl.clinipets.veterinaria.domain.Especie
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service

@Service
class RazasService {
    private val logger = LoggerFactory.getLogger(RazasService::class.java)

    private val razasPerro = listOf(
        "Mestizo",
        "Labrador Retriever",
        "Pastor Alem√°n",
        "Golden Retriever",
        "Bulldog Franc√©s",
        "Beagle",
        "Poodle (Caniche)",
        "Chihuahua",
        "Boxer",
        "Dachshund (Salchicha)",
        "Husky Siberiano",
        "Yorkshire Terrier"
    ).sorted()

    private val razasGato = listOf(
        "Mestizo",
        "Persa",
        "Siam√©s",
        "Maine Coon",
        "Ragdoll",
        "Bengala",
        "Sphynx (Esfinge)",
        "British Shorthair",
        "Angora",
        "Azul Ruso"
    ).sorted()

    fun getRazas(especie: Especie?): List<String> {
        logger.debug("[RAZAS_SERVICE] Obteniendo razas para especie: {}", especie ?: "TODAS")
        return when (especie) {
            Especie.PERRO -> razasPerro
            Especie.GATO -> razasGato
            null -> (razasPerro + razasGato).sorted().distinct()
        }
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/api/ServicioMedicoController.kt">
package cl.clinipets.servicios.api

import cl.clinipets.servicios.application.ServicioMedicoService
import io.swagger.v3.oas.annotations.Operation
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.slf4j.LoggerFactory
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/api/v1/servicios")
class ServicioMedicoController(
    private val servicioMedicoService: ServicioMedicoService
) {
    private val logger = LoggerFactory.getLogger(ServicioMedicoController::class.java)

    @Operation(summary = "Listar servicios activos", operationId = "listarServicios")
    @GetMapping
    fun listar(): ResponseEntity<List<ServicioMedicoDto>> {
        logger.info("[LISTAR_SERVICIOS] Inicio request")
        val response = servicioMedicoService.listarActivos()
        logger.info("[LISTAR_SERVICIOS] Fin request - Encontrados: {}", response.size)
        return ResponseEntity.ok(response)
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/domain/CategoriaServicio.kt">
package cl.clinipets.servicios.domain

enum class CategoriaServicio {
    CONSULTA, VACUNA, CIRUGIA, EXAMEN, PRODUCTO, OTRO
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/domain/MascotaRepository.kt">
package cl.clinipets.veterinaria.domain

import org.springframework.data.jpa.repository.EntityGraph
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.util.UUID

@Repository
interface MascotaRepository : JpaRepository<Mascota, UUID> {
    @EntityGraph(attributePaths = ["tutor"])
    fun findAllByTutorId(tutorId: UUID): List<Mascota>
}
</file>

<file path=".env.example">
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=change-me
DB_NAME=clinipets_db

# --- IMAGEN DOCKER (Backend) ---
BACKEND_IMAGE=clinipets-backend:latest

TUNNEL_TOKEN=your-tunnel-token

# --- SEGURIDAD JWT & GOOGLE ---
JWT_SECRET=change-me
JWT_REFRESH_SECRET=change-me
GOOGLE_CLIENT_ID=your-google-client-id

# --- MERCADO PAGO ---
MERCADOPAGO_ACCESS_TOKEN=your-mercadopago-token

META_ACCESS_TOKEN=your-meta-access-token
META_PHONE_NUMBER_ID=your-meta-phone-number-id

TEST_GOOGLE_AUTH_TOKEN=your-test-google-auth-token
</file>

<file path="gradlew">
#!/bin/sh

#
# Copyright ¬© 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions ¬´$var¬ª, ¬´${var}¬ª, ¬´${var:-default}¬ª, ¬´${var+SET}¬ª,
#           ¬´${var#prefix}¬ª, ¬´${var%suffix}¬ª, and ¬´$( cmd )¬ª;
#         * compound commands having a testable exit status, especially ¬´case¬ª;
#         * various built-in commands including ¬´command¬ª, ¬´set¬ª, and ¬´ulimit¬ª.
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH="\\\"\\\""


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        -jar "$APP_HOME/gradle/wrapper/gradle-wrapper.jar" \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/api/DisponibilidadDtos.kt">
package cl.clinipets.agendamiento.api

import java.time.Instant
import java.time.LocalDate
import java.util.UUID

data class DisponibilidadResponse(
    val fecha: LocalDate,
    val servicioId: UUID?,
    val slots: List<Instant>
)
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/application/PricingCalculator.kt">
package cl.clinipets.agendamiento.application

import cl.clinipets.agendamiento.api.DetalleReservaRequest
import cl.clinipets.servicios.application.PromoEngineService
import cl.clinipets.servicios.domain.CategoriaServicio
import cl.clinipets.servicios.domain.ServicioMedico
import cl.clinipets.veterinaria.domain.Mascota
import org.springframework.stereotype.Service
import java.time.LocalDate

data class PrecioCalculado(
    val precioFinal: Int,
    val precioOriginal: Int,
    val abono: Int,
    val descuentoAplicado: Boolean,
    val notas: List<String>
)

@Service
class PricingCalculator(
    private val promoEngineService: PromoEngineService
) {

    fun calcularPrecioFinal(servicio: ServicioMedico, mascota: Mascota?, fecha: LocalDate): PrecioCalculado {
        val servicioId =
            servicio.id ?: throw IllegalArgumentException("Servicio sin ID no permitido para c√°lculo de precio")

        val precioBase = when {
            servicio.categoria == CategoriaServicio.PRODUCTO -> servicio.precioBase
            mascota == null -> servicio.precioBase
            servicio.requierePeso -> servicio.calcularPrecioPara(mascota)
            else -> servicio.precioBase
        }

        val detalleRequest = DetalleReservaRequest(servicioId, mascota?.id)
        val descuentos = promoEngineService.calcularDescuentos(listOf(detalleRequest), fecha)
        val detallePromo = descuentos[servicioId]

        val deltaDescuento = detallePromo
            ?.let { (it.precioOriginal - it.precioFinal).coerceAtLeast(0) }
            ?: 0

        val precioFinal = (precioBase - deltaDescuento).coerceAtLeast(0)

        return PrecioCalculado(
            precioFinal = precioFinal,
            precioOriginal = precioBase,
            abono = servicio.precioAbono ?: 0,
            descuentoAplicado = deltaDescuento > 0,
            notas = detallePromo?.notas?.toList() ?: emptyList()
        )
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/domain/DetalleCita.kt">
package cl.clinipets.agendamiento.domain

import cl.clinipets.servicios.domain.ServicioMedico
import cl.clinipets.veterinaria.domain.Mascota
import jakarta.persistence.*
import java.util.UUID

@Entity
@Table(name = "detalles_cita")
class DetalleCita(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "cita_id", nullable = false)
    val cita: Cita,

    @ManyToOne(fetch = FetchType.EAGER, optional = false)
    @JoinColumn(name = "servicio_id", nullable = false)
    val servicio: ServicioMedico,

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "mascota_id", nullable = true)
    val mascota: Mascota?,

    @Column(nullable = false)
    var precioUnitario: Int
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is DetalleCita) return false
        return id != null && id == other.id
    }

    override fun hashCode(): Int = id?.hashCode() ?: 0
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/storage/StorageService.kt">
package cl.clinipets.core.storage

import io.minio.GetObjectArgs
import io.minio.MinioClient
import io.minio.PutObjectArgs
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Value
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.stereotype.Service
import org.springframework.web.multipart.MultipartFile
import java.io.InputStream
import java.util.UUID

@Service
@ConditionalOnProperty(name = ["minio.enabled"], havingValue = "true", matchIfMissing = true)
class StorageService(
    private val minioClient: MinioClient,
    @Value("\${minio.bucket-name}") private val bucketName: String,
    @Value("\${minio.url}") private val minioUrl: String
) {
    private val logger = LoggerFactory.getLogger(StorageService::class.java)

    /**
     * Sube un archivo a MinIO y retorna el objectName (path relativo en el bucket).
     * @param file El archivo Multipart recibido del controlador.
     * @param folder Carpeta virtual (ej: "mascotas", "fichas").
     * @return El 'objectName' o identificador interno del archivo.
     */
    fun uploadFile(file: MultipartFile, folder: String): String {
        try {
            val originalFilename = file.originalFilename ?: "unknown"
            val extension = originalFilename.substringAfterLast('.', "")
            val fileName = "${UUID.randomUUID()}.$extension"
            val objectName = "$folder/$fileName"

            val contentType = file.contentType?.takeIf { it.isNotBlank() } ?: when (extension.lowercase()) {
                "jpg", "jpeg" -> "image/jpeg"
                "png" -> "image/png"
                "pdf" -> "application/pdf"
                "webp" -> "image/webp"
                else -> "application/octet-stream"
            }

            logger.info(
                "[STORAGE] Subiendo archivo: {} a bucket: {}/{} (Type: {})",
                originalFilename,
                bucketName,
                objectName,
                contentType
            )

            minioClient.putObject(
                PutObjectArgs.builder()
                    .bucket(bucketName)
                    .`object`(objectName)
                    .stream(file.inputStream, file.size, -1)
                    .contentType(contentType)
                    .build()
            )

            logger.info("[STORAGE] Archivo subido exitosamente: {}", objectName)
            return objectName

        } catch (e: Exception) {
            logger.error("[STORAGE] Error subiendo archivo", e)
            throw RuntimeException("Error al subir archivo al almacenamiento: ${e.message}")
        }
    }

    /**
     * Obtiene el InputStream de un archivo almacenado en MinIO.
     * @param objectName El identificador del archivo (path dentro del bucket).
     * @return InputStream del archivo.
     */
    fun getFile(objectName: String): InputStream {
        try {
            return minioClient.getObject(
                GetObjectArgs.builder()
                    .bucket(bucketName)
                    .`object`(objectName)
                    .build()
            )
        } catch (e: Exception) {
            logger.error("[STORAGE] Error obteniendo archivo: {}", objectName, e)
            throw RuntimeException("Error al obtener archivo del almacenamiento: ${e.message}")
        }
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/identity/domain/UserRepository.kt">
package cl.clinipets.identity.domain

import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.util.UUID

@Repository
interface UserRepository : JpaRepository<User, UUID> {
    fun findByEmailIgnoreCase(email: String): User?
    fun findByPhone(phone: String): User?
    fun existsByEmailIgnoreCase(email: String): Boolean
    fun findAllByRoleIn(roles: Collection<UserRole>): List<User>
}
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/application/ServicioMedicoService.kt">
package cl.clinipets.servicios.application

import cl.clinipets.servicios.api.ServicioMedicoDto
import cl.clinipets.servicios.api.toDto
import cl.clinipets.servicios.domain.ServicioMedicoRepository
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class ServicioMedicoService(
    private val servicioMedicoRepository: ServicioMedicoRepository
) {
    private val logger = LoggerFactory.getLogger(ServicioMedicoService::class.java)

    @Transactional(readOnly = true)
    fun listarActivos(): List<ServicioMedicoDto> {
        logger.debug("[SERVICIO_MEDICO] Buscando servicios activos")
        val servicios = servicioMedicoRepository.findByActivoTrue()

        val filtrados = servicios.filter { servicio ->
            // 1. Verificar stock directo (si es un producto con stock definido)
            if (servicio.stock != null && servicio.stock!! <= 0) {
                return@filter false
            }

            // 2. Verificar stock de insumos cr√≠ticos
            if (servicio.insumos.isEmpty()) return@filter true

            servicio.insumos.filter { it.critico }.all { si ->
                si.insumo.stockActual >= si.cantidadRequerida
            }
        }.map { it.toDto() }

        logger.debug(
            "[SERVICIO_MEDICO] Encontrados {} servicios activos ({} tras filtro de stock)",
            servicios.size,
            filtrados.size
        )
        return filtrados
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/domain/ReglaPrecio.kt">
package cl.clinipets.servicios.domain

import jakarta.persistence.*
import java.math.BigDecimal
import java.util.UUID

@Entity
@Table(name = "reglas_precio")
class ReglaPrecio(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @Column(nullable = false)
    val pesoMin: Double,

    @Column(nullable = false)
    val pesoMax: Double,

    @Column(nullable = false)
    val precio: Int,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "servicio_id", nullable = false)
    var servicio: ServicioMedico
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is ReglaPrecio) return false
        return id != null && id == other.id
    }

    override fun hashCode(): Int = id?.hashCode() ?: 0

    override fun toString(): String = "ReglaPrecio(id=$id, pesoMin=$pesoMin, pesoMax=$pesoMax, precio=$precio)"
}
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/domain/ServicioMedicoRepository.kt">
package cl.clinipets.servicios.domain

import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.EntityGraph
import org.springframework.stereotype.Repository
import java.util.UUID

@Repository
interface ServicioMedicoRepository : JpaRepository<ServicioMedico, UUID> {
    @EntityGraph(attributePaths = ["reglas", "especiesPermitidas", "serviciosRequeridosIds", "insumos", "insumos.insumo"])
    fun findByActivoTrue(): List<ServicioMedico>
    fun existsByNombreIgnoreCase(nombre: String): Boolean
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/historial/application/PdfService.kt">
package cl.clinipets.veterinaria.historial.application

import cl.clinipets.agendamiento.domain.Cita
import cl.clinipets.agendamiento.domain.CitaRepository
import cl.clinipets.agendamiento.domain.EstadoCita
import cl.clinipets.core.config.ClinicProperties
import cl.clinipets.core.security.JwtPayload
import cl.clinipets.core.storage.StorageService
import cl.clinipets.core.web.NotFoundException
import cl.clinipets.core.web.UnauthorizedException
import cl.clinipets.identity.domain.UserRole
import cl.clinipets.veterinaria.domain.MascotaRepository
import cl.clinipets.veterinaria.domain.PlanPreventivoRepository
import cl.clinipets.veterinaria.domain.TipoPreventivo
import cl.clinipets.veterinaria.galeria.domain.MascotaMediaRepository
import cl.clinipets.veterinaria.galeria.domain.MediaType
import cl.clinipets.veterinaria.historial.domain.FichaClinicaRepository
import com.lowagie.text.Document
import com.lowagie.text.Element
import com.lowagie.text.Font
import com.lowagie.text.Image
import com.lowagie.text.PageSize
import com.lowagie.text.Paragraph
import com.lowagie.text.Phrase
import com.lowagie.text.Rectangle
import com.lowagie.text.pdf.BaseFont
import com.lowagie.text.pdf.PdfPCell
import com.lowagie.text.pdf.PdfPTable
import com.lowagie.text.pdf.PdfWriter
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.awt.Color
import java.io.ByteArrayOutputStream
import java.time.Instant
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import java.time.temporal.ChronoUnit
import java.util.Locale
import java.util.UUID
import kotlin.math.max

@Service
class PdfService(
    private val fichaClinicaRepository: FichaClinicaRepository,
    private val citaRepository: CitaRepository,
    private val mascotaMediaRepository: MascotaMediaRepository,
    private val storageService: StorageService,
    private val clinicProperties: ClinicProperties,
    private val clinicZoneId: ZoneId,
    private val userRepository: cl.clinipets.identity.domain.UserRepository,
    private val mascotaRepository: MascotaRepository,
    private val planPreventivoRepository: PlanPreventivoRepository
) {
    private val logger = LoggerFactory.getLogger(PdfService::class.java)

    // Fuentes configuradas
    private val baseFont: Font = FontFactoryHelper.base(10f)
    private val smallFont: Font = FontFactoryHelper.base(9f)
    private val boldFont: Font = FontFactoryHelper.bold(11f)
    private val titleFont: Font = FontFactoryHelper.bold(16f)
    private val sectionFont: Font = FontFactoryHelper.bold(12f)
    private val noteFont: Font = FontFactoryHelper.base(8f)
    private val headerFont: Font = FontFactoryHelper.bold(13f, Color(0, 122, 163))
    private val vaccineFont: Font = FontFactoryHelper.bold(14f, Color(0, 100, 0))
    private val alertFont: Font = FontFactoryHelper.bold(10f, Color.RED)

    data class FinancialSummary(
        val servicioNombre: String,
        val servicioPrecio: Int,
        val insumosExtras: Int,
        val totalPagado: Int,
        val estadoCita: EstadoCita?
    )

    @Transactional(readOnly = true)
    fun generarFichaClinicaPdf(fichaId: UUID, requester: JwtPayload): ByteArray {
        val ficha = fichaClinicaRepository.findById(fichaId)
            .orElseThrow { NotFoundException("Ficha cl√≠nica no encontrada") }

        val mascota = ficha.mascota
        val tutor = mascota.tutor

        // Validaci√≥n de seguridad: solo el due√±o o staff puede verla
        if (requester.role == UserRole.CLIENT && tutor.id != requester.userId) {
            logger.warn("[PDF] Acceso denegado. User {} no es due√±o de la mascota {}", requester.email, mascota.id)
            throw UnauthorizedException("No tiene permiso para ver esta ficha.")
        }

        val authorName = userRepository.findById(ficha.autorId).map { it.name }.orElse("Veterinario Tratante")

        // Buscar datos financieros relacionados
        val citaRelacionada = mascota.id?.let { buscarCitaRelacionada(it, ficha.fechaAtencion) }
        val resumenFinanciero = buildFinancialSummary(citaRelacionada, ficha.motivoConsulta)

        // Generaci√≥n del PDF
        val baos = ByteArrayOutputStream()
        val document = Document(PageSize.A4, 36f, 36f, 36f, 48f)
        PdfWriter.getInstance(document, baos)
        document.open()

        addHeader(document)
        addTitle(document)
        addPacienteInfo(
            document,
            ficha.fechaAtencion,
            mascota.nombre,
            mascota.especie.name,
            tutor.name,
            tutor.phone,
            tutor.email,
            tutor.address,
            ficha.pesoRegistrado ?: mascota.pesoActual.toDouble()
        )

        // Signos Vitales Estructurados
        addVitalSignsSection(document, ficha)

        // Secciones M√©dicas (SOAP)
        addClinicalSection(document, "Motivo", ficha.motivoConsulta)
        addClinicalSection(document, "Anamnesis (Subjetivo)", ficha.anamnesis)
        addClinicalSection(document, "Hallazgos Objetivos (Examen F√≠sico)", ficha.hallazgosObjetivos)
        addClinicalSection(document, "Aval√∫o Cl√≠nico (Diagn√≥stico)", ficha.avaluoClinico)
        addClinicalSection(document, "Plan de Tratamiento e Indicaciones", ficha.planTratamiento)
        ficha.observaciones?.let { addClinicalSection(document, "Observaciones adicionales", it) }

        // Plan de Vacunaci√≥n Destacado
        if (ficha.esVacuna) {
            addVaccineSection(document, ficha.nombreVacuna, ficha.fechaProximaVacuna)
        }

        // Secciones Finales
        addFinancialSection(document, resumenFinanciero)
        addPhotoIfExists(document, mascota.id, mascota.nombre)
        addSignature(document, authorName)
        addFootNote(document)

        document.close()
        return baos.toByteArray()
    }

    @Transactional(readOnly = true)
    fun generarCarnetSanitarioPdf(mascotaId: UUID, user: JwtPayload): ByteArray {
        logger.info("[CARNET_PDF] Generando PDF para mascota $mascotaId")

        val mascota = mascotaRepository.findById(mascotaId)
            .orElseThrow { NotFoundException("Mascota no encontrada: $mascotaId") }

        if (user.role == UserRole.CLIENT && mascota.tutor.id != user.userId) {
            throw UnauthorizedException("No tienes permiso para ver este carnet")
        }

        val preventivos = planPreventivoRepository.findAllByMascotaIdOrderByFechaAplicacionDesc(mascotaId)
        val outputStream = ByteArrayOutputStream()
        val document = Document(PageSize.A4, 40f, 40f, 40f, 40f)
        PdfWriter.getInstance(document, outputStream)

        document.open()

        // Logo
        try {
            val logoPath = clinicProperties.logoPath
            if (!logoPath.isNullOrBlank()) {
                val logoStream = storageService.getFile(logoPath)
                val logoBytes = logoStream.readAllBytes()
                val logo = Image.getInstance(logoBytes)
                logo.scaleToFit(150f, 60f)
                logo.alignment = Element.ALIGN_CENTER
                document.add(logo)
            }
        } catch (ex: Exception) {
            logger.warn("[CARNET_PDF] No se pudo cargar el logo: ${ex.message}")
        }

        // T√≠tulo
        val titulo = Paragraph("CARNET SANITARIO", titleFont).apply {
            alignment = Element.ALIGN_CENTER
            spacingAfter = 20f
        }
        document.add(titulo)

        // Info Cl√≠nica
        val clinicInfo = Paragraph().apply {
            add(Phrase("${clinicProperties.name}\n", boldFont))
            add(Phrase("${clinicProperties.address}\n", baseFont))
            add(Phrase("Tel: ${clinicProperties.phone}\n", baseFont))
            alignment = Element.ALIGN_CENTER
            spacingAfter = 20f
        }
        document.add(clinicInfo)

        // Datos Mascota
        val tablaMascota = PdfPTable(2).apply {
            widthPercentage = 100f
            setWidths(floatArrayOf(1f, 2f))
            setSpacingAfter(20f)
        }

        fun agregarFila(label: String, valor: String) {
            val l = PdfPCell(Phrase(label, boldFont)).apply {
                border = Rectangle.NO_BORDER
                setPadding(5f)
            }
            val v = PdfPCell(Phrase(valor, baseFont)).apply {
                border = Rectangle.NO_BORDER
                setPadding(5f)
            }
            tablaMascota.addCell(l)
            tablaMascota.addCell(v)
        }

        agregarFila("Nombre:", mascota.nombre)
        agregarFila("Especie:", mascota.especie.toString())
        agregarFila("Raza:", mascota.raza)
        agregarFila("Fecha Nacimiento:", mascota.fechaNacimiento?.toString() ?: "Sin registro")
        mascota.chipIdentificador?.let { agregarFila("Chip:", it) }
        agregarFila("Tutor:", mascota.tutor.name)
        document.add(tablaMascota)

        // Vacunas
        val tituloVacunas = Paragraph("VACUNAS", sectionFont).apply {
            spacingBefore = 10f
            spacingAfter = 10f
        }
        document.add(tituloVacunas)

        val vacunas = preventivos.filter { it.tipo == TipoPreventivo.VACUNA }
        if (vacunas.isNotEmpty()) {
            val tablaVacunas = PdfPTable(4).apply {
                widthPercentage = 100f
                setWidths(floatArrayOf(3f, 2f, 2f, 2f))
                setSpacingAfter(20f)
            }

            fun addHeader(text: String) {
                tablaVacunas.addCell(PdfPCell(Phrase(text, boldFont)).apply {
                    backgroundColor = Color(220, 220, 220)
                    setPadding(5f)
                    horizontalAlignment = Element.ALIGN_CENTER
                })
            }
            addHeader("Producto")
            addHeader("Fecha Aplicaci√≥n")
            addHeader("Fecha Refuerzo")
            addHeader("Lote")

            val formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy", Locale("es", "CL"))
                .withZone(clinicZoneId)

            vacunas.forEach { v ->
                fun addCell(text: String) = tablaVacunas.addCell(PdfPCell(Phrase(text, baseFont)).apply { setPadding(5f) })
                addCell(v.producto)
                addCell(formatter.format(v.fechaAplicacion))
                addCell(v.fechaRefuerzo?.let { formatter.format(it) } ?: "-")
                addCell(v.lote ?: "-")
            }
            document.add(tablaVacunas)
        } else {
            document.add(Paragraph("No se han registrado vacunas", smallFont).apply { spacingAfter = 20f })
        }

        // Desparasitaciones
        val tituloDesp = Paragraph("DESPARASITACIONES", sectionFont).apply {
            spacingBefore = 10f
            spacingAfter = 10f
        }
        document.add(tituloDesp)

        val desparasitaciones = preventivos.filter { 
            it.tipo == TipoPreventivo.DESPARASITACION_INTERNA || it.tipo == TipoPreventivo.DESPARASITACION_EXTERNA 
        }

        if (desparasitaciones.isNotEmpty()) {
            val tablaDesp = PdfPTable(4).apply {
                widthPercentage = 100f
                setWidths(floatArrayOf(2f, 3f, 2f, 2f))
                setSpacingAfter(20f)
            }

            fun addHeader(text: String) {
                tablaDesp.addCell(PdfPCell(Phrase(text, boldFont)).apply {
                    backgroundColor = Color(220, 220, 220)
                    setPadding(5f)
                    horizontalAlignment = Element.ALIGN_CENTER
                })
            }
            addHeader("Tipo")
            addHeader("Producto")
            addHeader("Fecha Aplicaci√≥n")
            addHeader("Fecha Refuerzo")

            val formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy", Locale("es", "CL"))
                .withZone(clinicZoneId)

            desparasitaciones.forEach { d ->
                fun addCell(text: String) = tablaDesp.addCell(PdfPCell(Phrase(text, baseFont)).apply { setPadding(5f) })
                addCell(when(d.tipo) {
                    TipoPreventivo.DESPARASITACION_INTERNA -> "Interna"
                    TipoPreventivo.DESPARASITACION_EXTERNA -> "Externa"
                    else -> d.tipo.toString()
                })
                addCell(d.producto)
                addCell(formatter.format(d.fechaAplicacion))
                addCell(d.fechaRefuerzo?.let { formatter.format(it) } ?: "-")
            }
            document.add(tablaDesp)
        } else {
            document.add(Paragraph("No se han registrado desparasitaciones", smallFont).apply { spacingAfter = 20f })
        }

        // Pr√≥ximos Refuerzos
        val ahora = Instant.now()
        val proximos = preventivos
            .filter { it.fechaRefuerzo != null && it.fechaRefuerzo!! > ahora }
            .sortedBy { it.fechaRefuerzo }

        if (proximos.isNotEmpty()) {
            document.add(Paragraph("PR√ìXIMOS REFUERZOS", sectionFont).apply {
                spacingBefore = 10f
                spacingAfter = 10f
            })

            val tablaRef = PdfPTable(3).apply {
                widthPercentage = 100f
                setWidths(floatArrayOf(3f, 2f, 2f))
                setSpacingAfter(20f)
            }

            fun addHeader(text: String) {
                tablaRef.addCell(PdfPCell(Phrase(text, boldFont)).apply {
                    backgroundColor = Color(220, 220, 220)
                    setPadding(5f)
                    horizontalAlignment = Element.ALIGN_CENTER
                })
            }
            addHeader("Producto")
            addHeader("Fecha Programada")
            addHeader("D√≠as Restantes")

            val formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy", Locale("es", "CL"))
                .withZone(clinicZoneId)

            proximos.forEach { p ->
                val dias = ChronoUnit.DAYS.between(ahora, p.fechaRefuerzo)
                val alerta = dias <= 7
                val fontToUse = if (alerta) alertFont else baseFont
                val bg = if (alerta) Color(255, 255, 200) else null

                fun addCell(text: String) {
                    tablaRef.addCell(PdfPCell(Phrase(text, fontToUse)).apply {
                        setPadding(5f)
                        if (bg != null) backgroundColor = bg
                    })
                }
                addCell(p.producto)
                addCell(formatter.format(p.fechaRefuerzo))
                addCell("$dias d√≠as" + if (alerta) " ‚ö†" else "")
            }
            document.add(tablaRef)

            document.add(Paragraph("‚ö† Los refuerzos marcados en amarillo requieren atenci√≥n en 7 d√≠as o menos", smallFont).apply {
                spacingAfter = 10f
            })
        }

        // Footer
        val fechaEmision = Paragraph(
            "Documento generado el ${DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm", Locale("es", "CL")).withZone(clinicZoneId).format(Instant.now())}",
            smallFont
        ).apply {
            alignment = Element.ALIGN_CENTER
            spacingBefore = 30f
        }
        document.add(fechaEmision)

        document.close()
        return outputStream.toByteArray()
    }

    private fun addHeader(document: Document) {
        val table = PdfPTable(floatArrayOf(1.1f, 2f))
        table.widthPercentage = 100f

        val logoCell = PdfPCell().apply {
            border = Rectangle.NO_BORDER
            setPadding(4f)
        }
        logoCell.addElement(
            Paragraph(clinicProperties.name, headerFont).apply { alignment = Element.ALIGN_LEFT }
        )
        clinicProperties.website.takeIf { it.isNotBlank() }?.let {
            logoCell.addElement(
                Paragraph(it, smallFont).apply {
                    alignment = Element.ALIGN_LEFT
                    spacingBefore = -2f
                }
            )
        }
        table.addCell(logoCell)

        val infoCell = PdfPCell().apply {
            border = Rectangle.NO_BORDER
            horizontalAlignment = Element.ALIGN_RIGHT
            setPadding(4f)
        }
        infoCell.addElement(Paragraph(clinicProperties.name, boldFont).apply { alignment = Element.ALIGN_RIGHT })
        clinicProperties.rut.takeIf { it.isNotBlank() }?.let {
            infoCell.addElement(Paragraph("RUT: $it", baseFont).apply { alignment = Element.ALIGN_RIGHT })
        }
        clinicProperties.address.takeIf { it.isNotBlank() }?.let {
            infoCell.addElement(Paragraph(it, baseFont).apply { alignment = Element.ALIGN_RIGHT })
        }
        val contactLine = listOfNotNull(
            clinicProperties.phone.takeIf { it.isNotBlank() },
            clinicProperties.email.takeIf { it.isNotBlank() }
        ).joinToString(" | ")
        if (contactLine.isNotBlank()) {
            infoCell.addElement(Paragraph(contactLine, baseFont).apply { alignment = Element.ALIGN_RIGHT })
        }
        table.addCell(infoCell)

        document.add(table)
    }

    private fun addVaccineSection(document: Document, nombreVacuna: String?, fechaProxima: java.time.LocalDate?) {
        val table = PdfPTable(1)
        table.widthPercentage = 100f
        table.setSpacingBefore(10f)
        table.setSpacingAfter(10f)

        val cell = PdfPCell().apply {
            border = Rectangle.BOX
            borderColor = Color(0, 100, 0)
            borderWidth = 1.5f
            backgroundColor = Color(240, 255, 240)
            setPadding(10f)
            horizontalAlignment = Element.ALIGN_CENTER
        }

        cell.addElement(Paragraph("PLAN DE VACUNACI√ìN", vaccineFont).apply { alignment = Element.ALIGN_CENTER })

        val detalle = StringBuilder()
        nombreVacuna?.let { detalle.append("Vacuna administrada: $it\n") }
        fechaProxima?.let {
            val fmt = DateTimeFormatter.ofPattern("dd/MM/yyyy")
            detalle.append("PR√ìXIMA DOSIS: ${it.format(fmt)}")
        }

        cell.addElement(Paragraph(detalle.toString(), boldFont).apply {
            alignment = Element.ALIGN_CENTER
            spacingBefore = 5f
        })

        table.addCell(cell)
        document.add(table)
    }

    private fun addSignature(document: Document, authorName: String) {
        val table = PdfPTable(1)
        table.widthPercentage = 100f
        table.setSpacingBefore(40f)
        table.setSpacingAfter(10f)

        val cell = PdfPCell().apply {
            border = Rectangle.NO_BORDER
            horizontalAlignment = Element.ALIGN_CENTER
        }

        cell.addElement(Paragraph("__________________________", baseFont).apply { alignment = Element.ALIGN_CENTER })
        cell.addElement(Paragraph(authorName.uppercase(), boldFont).apply { alignment = Element.ALIGN_CENTER })
        cell.addElement(Paragraph("M√©dico Veterinario", baseFont).apply { alignment = Element.ALIGN_CENTER })

        table.addCell(cell)
        document.add(table)
    }

    private fun addTitle(document: Document) {
        val title = Paragraph("FICHA CL√çNICA Y COMPROBANTE DE ATENCI√ìN", titleFont).apply {
            alignment = Element.ALIGN_CENTER
            spacingBefore = 10f
            spacingAfter = 14f
        }
        document.add(title)
    }

    private fun addPacienteInfo(
        document: Document,
        fechaAtencion: java.time.Instant,
        nombreMascota: String,
        especie: String,
        tutorNombre: String,
        tutorTelefono: String?,
        tutorCorreo: String?,
        direccion: String?,
        peso: Double
    ) {
        val table = PdfPTable(floatArrayOf(1f, 1f))
        table.widthPercentage = 100f
        table.setSpacingAfter(12f)

        val fechaLocal = fechaAtencion.atZone(clinicZoneId)
        val fechaTexto = fechaLocal.format(DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm"))

        table.addCell(infoCell("Paciente", nombreMascota))
        table.addCell(infoCell("Fecha atenci√≥n", fechaTexto))
        table.addCell(infoCell("Especie", especie.replace("_", " ").lowercase().replaceFirstChar { it.uppercase() }))
        table.addCell(infoCell("Peso registrado", "${"%.2f".format(peso)} kg"))
        table.addCell(infoCell("Tutor", tutorNombre))
        table.addCell(infoCell("Tel√©fono", tutorTelefono ?: "Sin registro"))
        table.addCell(infoCell("Correo", tutorCorreo ?: "Sin registro"))
        table.addCell(infoCell("Direcci√≥n", direccion ?: "Sin registro"))

        document.add(table)
    }

    private fun addVitalSignsSection(document: Document, ficha: cl.clinipets.veterinaria.historial.domain.FichaClinica) {
        val table = PdfPTable(4)
        table.widthPercentage = 100f
        table.setSpacingBefore(5f)
        table.setSpacingAfter(10f)

        fun addCell(label: String, value: String?, color: Color = Color(245, 249, 252)) {
            val phrase = Phrase().apply {
                add(Phrase("$label\n", smallFont))
                add(Phrase(value ?: "---", boldFont))
            }
            table.addCell(PdfPCell(phrase).apply {
                backgroundColor = color
                setPadding(6f)
                horizontalAlignment = Element.ALIGN_CENTER
                border = Rectangle.BOX
                borderColor = Color(220, 230, 240)
            })
        }

        val tempColor = if (ficha.alertaVeterinaria) Color(255, 235, 235) else Color(245, 249, 252)

        addCell("Temperatura", ficha.temperatura?.let { "$it¬∞C" }, tempColor)
        addCell("Frec. Card√≠aca", ficha.frecuenciaCardiaca?.let { "$it lpm" })
        addCell("Frec. Resp.", ficha.frecuenciaRespiratoria?.let { "$it rpm" })
        addCell("Peso", ficha.pesoRegistrado?.let { "$it kg" })

        document.add(table)
    }

    private fun infoCell(label: String, value: String): PdfPCell {
        val phrase = Phrase().apply {
            add(Phrase("$label: ", boldFont))
            add(Phrase(value, baseFont))
        }
        return PdfPCell(phrase).apply {
            backgroundColor = Color(245, 249, 252)
            setPadding(8f)
            border = Rectangle.NO_BORDER
        }
    }

    private fun addClinicalSection(document: Document, title: String, content: String?) {
        val safeContent = content?.takeIf { it.isNotBlank() } ?: "Sin registro."
        val sectionTitle = Paragraph(title.uppercase(), sectionFont).apply {
            spacingBefore = 6f
            spacingAfter = 2f
        }
        val body = Paragraph(safeContent, baseFont).apply { spacingAfter = 6f }
        document.add(sectionTitle)
        document.add(body)
    }

    private fun addFinancialSection(document: Document, summary: FinancialSummary) {
        val heading = Paragraph("RESUMEN FINANCIERO", sectionFont).apply {
            spacingBefore = 10f
            spacingAfter = 6f
        }
        document.add(heading)

        val table = PdfPTable(floatArrayOf(3f, 1f)).apply {
            widthPercentage = 100f
            setSpacingAfter(8f)
        }

        fun addRow(label: String, amount: Int, highlight: Boolean = false) {
            val labelCell = PdfPCell(Phrase(label, if (highlight) boldFont else baseFont)).apply {
                border = Rectangle.NO_BORDER
                setPadding(6f)
                backgroundColor = Color(248, 251, 253)
            }
            val valueCell = PdfPCell(Phrase(formatCurrency(amount), if (highlight) boldFont else baseFont)).apply {
                border = Rectangle.NO_BORDER
                setPadding(6f)
                horizontalAlignment = Element.ALIGN_RIGHT
                backgroundColor = Color(248, 251, 253)
            }
            table.addCell(labelCell)
            table.addCell(valueCell)
        }

        addRow("Servicio: ${summary.servicioNombre}", summary.servicioPrecio)
        addRow("Insumos/Extras", summary.insumosExtras)
        addRow("TOTAL PAGADO", summary.totalPagado, highlight = true)

        summary.estadoCita?.let {
            val estadoLegible = it.name.lowercase().replace('_', ' ').replaceFirstChar { ch -> ch.titlecase() }
            val estadoCell = PdfPCell(Phrase("Estado de la cita: $estadoLegible", smallFont)).apply {
                border = Rectangle.NO_BORDER
                paddingTop = 4f
                paddingBottom = 0f
                colspan = 2
            }
            table.addCell(estadoCell)
        }

        document.add(table)
    }

    private fun addFootNote(document: Document) {
        val note = Paragraph(
            "Este documento es un resumen cl√≠nico y comprobante de pago interno. Si pag√≥ con tarjeta, su voucher es v√°lido como boleta.",
            noteFont
        ).apply {
            spacingBefore = 2f
        }
        document.add(note)
    }

    private fun addPhotoIfExists(document: Document, mascotaId: UUID?, nombreMascota: String) {
        if (mascotaId == null) return

        val foto = mascotaMediaRepository.findAllByMascotaIdOrderByFechaSubidaDesc(mascotaId)
            .firstOrNull { it.tipo == MediaType.IMAGE } ?: run {
                logger.info("[PDF] Mascota {} sin foto asociada para la ficha", mascotaId)
                return
            }

        val image = try {
            // Obtenemos los bytes desde MinIO/S3
            val imageBytes = storageService.getFile(foto.url).use { input -> input.readAllBytes() }
            Image.getInstance(imageBytes)
        } catch (ex: Exception) {
            logger.warn("[PDF] No se pudo cargar la foto {}: {}", foto.id ?: "sin-id", ex.message)
            return
        }

        // Ajuste de tama√±o para que no rompa la p√°gina
        image.scaleToFit(450f, 360f)
        image.alignment = Element.ALIGN_CENTER

        val caption = Paragraph("Foto de $nombreMascota", smallFont).apply {
            alignment = Element.ALIGN_CENTER
            spacingBefore = 6f
            spacingAfter = 4f
        }

        document.add(caption)
        document.add(image)
    }

    private fun buscarCitaRelacionada(mascotaId: UUID, fechaFicha: java.time.Instant): Cita? {
        val citas = citaRepository.findAllByMascotaId(mascotaId)
        val fechaLocal = fechaFicha.atZone(clinicZoneId).toLocalDate()
        // Buscamos una cita que coincida exactamente con la fecha, o la m√°s reciente
        return citas.firstOrNull { it.fechaHoraInicio.atZone(clinicZoneId).toLocalDate() == fechaLocal } ?: citas.firstOrNull()
    }

    private fun buildFinancialSummary(cita: Cita?, fallbackLabel: String): FinancialSummary {
        if (cita == null) {
            return FinancialSummary(
                servicioNombre = fallbackLabel,
                servicioPrecio = 0,
                insumosExtras = 0,
                totalPagado = 0,
                estadoCita = null
            )
        }

        val serviciosLabel = if (cita.detalles.isEmpty()) {
            "Atenci√≥n cl√≠nica"
        } else {
            cita.detalles.joinToString(", ") { it.servicio.nombre }
        }

        val subtotalServicios = if (cita.detalles.isEmpty()) {
            cita.precioFinal
        } else {
            cita.detalles.sumOf { it.precioUnitario }
        }

        val extras = max(cita.precioFinal - subtotalServicios, 0)

        // Si est√° finalizada, se pag√≥ todo. Si no (Confirmada), no se ha pagado nada.
        val pagado = if (cita.estado == EstadoCita.FINALIZADA) cita.precioFinal else 0

        return FinancialSummary(
            servicioNombre = serviciosLabel,
            servicioPrecio = subtotalServicios,
            insumosExtras = extras,
            totalPagado = pagado,
            estadoCita = cita.estado
        )
    }

    private fun formatCurrency(amount: Int): String {
        val formatter = java.text.NumberFormat.getInstance(Locale.of("es", "CL")).apply {
            minimumFractionDigits = 0
            maximumFractionDigits = 0
        }
        return "$$${formatter.format(amount)}"
    }
}

// ----------------------------------------------------------- 
// HELPER PARA FUENTES (CORREGIDO)
// ----------------------------------------------------------- 
object FontFactoryHelper {
    // FIX: Usar BaseFont.WINANSI (CP1252) en lugar de IDENTITY_H para fuentes est√°ndar.
    // Esto soporta tildes y e√±es sin requerir un archivo .ttf externo.

    fun base(size: Float, color: Color = Color(40, 40, 40)): Font =
        com.lowagie.text.FontFactory.getFont(
            com.lowagie.text.FontFactory.HELVETICA,
            BaseFont.WINANSI, // <--- CAMBIO CLAVE AQU√ç
            true,
            size,
            Font.NORMAL,
            color
        )

    fun bold(size: Float, color: Color = Color(30, 30, 30)): Font =
        com.lowagie.text.FontFactory.getFont(
            com.lowagie.text.FontFactory.HELVETICA_BOLD,
            BaseFont.WINANSI, // <--- CAMBIO CLAVE AQU√ç
            true,
            size,
            Font.BOLD,
            color
        )
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/historial/domain/FichaClinicaRepository.kt">
package cl.clinipets.veterinaria.historial.domain

import org.springframework.data.domain.Page
import org.springframework.data.domain.Pageable
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.util.UUID

@Repository
interface FichaClinicaRepository : JpaRepository<FichaClinica, UUID> {
    fun findAllByMascotaIdOrderByFechaAtencionDesc(mascotaId: UUID, pageable: Pageable): Page<FichaClinica>
    fun findAllByMascotaIdOrderByFechaAtencionAsc(mascotaId: UUID): List<FichaClinica>
    fun findByCitaId(citaId: UUID): FichaClinica?
}
</file>

<file path="src/test/kotlin/cl/clinipets/backend/agendamiento/domain/ClinicalValidatorTest.kt">
package cl.clinipets.backend.agendamiento.domain

import cl.clinipets.agendamiento.domain.ClinicalValidator
import cl.clinipets.core.web.BadRequestException
import cl.clinipets.identity.domain.User
import cl.clinipets.identity.domain.UserRole
import cl.clinipets.servicios.domain.CategoriaServicio
import cl.clinipets.servicios.domain.ServicioMedico
import cl.clinipets.servicios.domain.ServicioMedicoRepository
import cl.clinipets.veterinaria.domain.Especie
import cl.clinipets.veterinaria.domain.Mascota
import cl.clinipets.veterinaria.domain.Sexo
import cl.clinipets.veterinaria.domain.Temperamento
import org.junit.jupiter.api.Assertions.assertThrows
import org.junit.jupiter.api.Test
import org.mockito.kotlin.any
import org.mockito.kotlin.mock
import org.mockito.kotlin.whenever
import java.time.LocalDate
import java.util.Optional
import java.util.UUID

class ClinicalValidatorTest {

    private val servicioRepo: ServicioMedicoRepository = mock()
    private val validator = ClinicalValidator(servicioRepo)

    @Test
    fun `lanza error si mascota esterilizada y servicio lo proh√≠be`() {
        val servicio = baseServicio().apply { bloqueadoSiEsterilizado = true }
        val mascota = baseMascota().apply { esterilizado = true }

        assertThrows(BadRequestException::class.java) {
            validator.validarRequisitosClinicos(servicio, mascota, emptySet())
        }
    }

    @Test
    fun `lanza error si falta test retroviral para vacuna de leucemia`() {
        val requeridoId = UUID.randomUUID()
        val servicio = baseServicio().apply { serviciosRequeridosIds = mutableSetOf(requeridoId) }
        val mascota = baseMascota().apply { testRetroviralNegativo = false }

        val servicioRequerido = baseServicio(requeridoId).apply {
            nombre = "Vacuna Leucemia Felina"
        }
        whenever(servicioRepo.findById(any())).thenReturn(Optional.of(servicioRequerido))

        assertThrows(BadRequestException::class.java) {
            validator.validarRequisitosClinicos(servicio, mascota, emptySet())
        }
    }

    private fun baseServicio(id: UUID = UUID.randomUUID()): ServicioMedico = ServicioMedico(
        id = id,
        nombre = "Servicio X",
        precioBase = 1000,
        precioAbono = 200,
        requierePeso = false,
        duracionMinutos = 30,
        activo = true,
        categoria = CategoriaServicio.OTRO,
        especiesPermitidas = mutableSetOf(Especie.PERRO)
    )

    private fun baseMascota(id: UUID = UUID.randomUUID()): Mascota = Mascota(
        id = id,
        nombre = "Firulais",
        especie = Especie.PERRO,
        pesoActual = 10.0,
        raza = "Mestizo",
        sexo = Sexo.MACHO,
        esterilizado = false,
        chipIdentificador = null,
        temperamento = Temperamento.DOCIL,
        fechaNacimiento = LocalDate.now().minusYears(2),
        tutor = User(
            id = UUID.randomUUID(),
            email = "test@clinipets.cl",
            name = "Tester",
            passwordHash = "hash",
            role = UserRole.CLIENT
        ),
        testRetroviralNegativo = true,
        fechaUltimoTestRetroviral = null,
        observacionesClinicas = null
    )
}
</file>

<file path="src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker">
mock-maker-inline
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/api/DisponibilidadController.kt">
package cl.clinipets.agendamiento.api

import cl.clinipets.agendamiento.application.DisponibilidadService
import io.swagger.v3.oas.annotations.Operation
import org.slf4j.LoggerFactory
import org.springframework.format.annotation.DateTimeFormat
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController
import java.time.LocalDate

@RestController
@RequestMapping("/api/v1/disponibilidad")
class DisponibilidadController(
    private val disponibilidadService: DisponibilidadService
) {
    private val logger = LoggerFactory.getLogger(DisponibilidadController::class.java)

    @Operation(summary = "Obtener disponibilidad", operationId = "obtenerDisponibilidad")
    @GetMapping
    fun obtener(
        @RequestParam("fecha") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) fecha: LocalDate,
        @RequestParam("duracionMinutos") duracionMinutos: Int
    ): ResponseEntity<DisponibilidadResponse> {
        logger.info("[DISPONIBILIDAD] Request. Fecha: {}, Duracion: {} min", fecha, duracionMinutos)
        val slots = disponibilidadService.obtenerSlots(fecha, duracionMinutos)
        logger.info("[DISPONIBILIDAD] Fin request - Slots encontrados: {}", slots.size)
        return ResponseEntity.ok(
            DisponibilidadResponse(
                fecha = fecha,
                servicioId = null, // Deprecated/Optional in response
                slots = slots
            )
        )
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/application/DisponibilidadService.kt">
package cl.clinipets.agendamiento.application

import cl.clinipets.agendamiento.domain.Cita
import cl.clinipets.agendamiento.domain.CitaRepository
import cl.clinipets.agendamiento.domain.BloqueoAgenda
import cl.clinipets.agendamiento.domain.BloqueoAgendaRepository
import cl.clinipets.agendamiento.domain.HorarioClinica
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId
import java.time.temporal.ChronoUnit

@Service
class DisponibilidadService(
    private val citaRepository: CitaRepository,
    private val bloqueoAgendaRepository: BloqueoAgendaRepository,
    private val clinicZoneId: ZoneId
) {
    private val logger = LoggerFactory.getLogger(DisponibilidadService::class.java)
    private val intervaloMinutos = 15L

    @Transactional(readOnly = true)
    fun obtenerSlots(fecha: LocalDate, duracionMinutos: Int): List<Instant> {
        logger.info(">>> Calculando disponibilidad. Fecha: $fecha, Duraci√≥n: $duracionMinutos min, Zona: $clinicZoneId")

        val ventana = HorarioClinica.ventanaPara(fecha.dayOfWeek)

        if (ventana == null) {
            logger.warn(">>> La cl√≠nica est√° CERRADA los ${fecha.dayOfWeek}")
            return emptyList()
        }

        val (abre, cierra) = ventana
        logger.info(">>> Horario del d√≠a: $abre a $cierra")

        // Calculamos rango del d√≠a completo para buscar citas existentes
        val startOfDay = fecha.atStartOfDay(clinicZoneId).toInstant()
        val endOfDay = fecha.plusDays(1).atStartOfDay(clinicZoneId).toInstant()

        logger.debug(">>> Buscando citas en DB entre $startOfDay y $endOfDay")

        val citasDia = citaRepository.findOverlappingCitas(startOfDay, endOfDay)
        logger.info(">>> Citas encontradas en conflicto: ${citasDia.size}")

        val bloqueosDia = bloqueoAgendaRepository.findByFechaHoraFinGreaterThanAndFechaHoraInicioLessThan(startOfDay, endOfDay)
        logger.info(">>> Bloqueos encontrados en conflicto: ${bloqueosDia.size}")

        val slots = mutableListOf<Instant>()

        // Construir el cursor inicial: fecha + hora de apertura
        var cursor = fecha.atTime(abre).atZone(clinicZoneId).toInstant()
        val limiteCierre = fecha.atTime(cierra).atZone(clinicZoneId).toInstant()

        logger.info(">>> Generando slots desde $cursor hasta $limiteCierre")

        while (cursor.plus(duracionMinutos.toLong(), ChronoUnit.MINUTES) <= limiteCierre) {
            val inicio = cursor
            val fin = inicio.plus(duracionMinutos.toLong(), ChronoUnit.MINUTES)

            if (estaLibre(inicio, fin, citasDia, bloqueosDia)) {
                slots.add(cursor)
                // Logueamos solo algunos para no saturar, o todos si est√°s depurando fuerte
                logger.debug("   -> Slot Disponible: $cursor ($inicio - $fin)")
            } else {
                logger.debug("   -> Slot OCUPADO: $cursor")
            }
            cursor = cursor.plus(intervaloMinutos, ChronoUnit.MINUTES)
        }

        logger.info(">>> Total slots disponibles calculados: ${slots.size}")
        return slots
    }

    private fun estaLibre(inicio: Instant, fin: Instant, citas: List<Cita>, bloqueos: List<BloqueoAgenda>): Boolean {
        val chocaConCita = citas.any { cita ->
            inicio < cita.fechaHoraFin && fin > cita.fechaHoraInicio
        }
        val chocaConBloqueo = bloqueos.any { bloqueo ->
            inicio < bloqueo.fechaHoraFin && fin > bloqueo.fechaHoraInicio
        }
        return !chocaConCita && !chocaConBloqueo
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/web/RestExceptionHandler.kt">
package cl.clinipets.core.web

import jakarta.servlet.http.HttpServletRequest
import org.slf4j.LoggerFactory
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.MethodArgumentNotValidException
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.RestControllerAdvice

@RestControllerAdvice
class RestExceptionHandler {
    private val logger = LoggerFactory.getLogger(RestExceptionHandler::class.java)

    @ExceptionHandler(NotFoundException::class)
    fun handleNotFound(ex: NotFoundException, request: HttpServletRequest): ResponseEntity<ApiError> {
        logger.warn("NotFound: {} [{}]", ex.message, request.servletPath)
        return buildError(HttpStatus.NOT_FOUND, ex, request, "NOT_FOUND")
    }

    @ExceptionHandler(ConflictException::class)
    fun handleConflict(ex: ConflictException, request: HttpServletRequest): ResponseEntity<ApiError> {
        logger.warn("Conflict: {} [{}]", ex.message, request.servletPath)
        return buildError(HttpStatus.CONFLICT, ex, request, "CONFLICT")
    }

    @ExceptionHandler(UnauthorizedException::class)
    fun handleUnauthorized(ex: UnauthorizedException, request: HttpServletRequest): ResponseEntity<ApiError> {
        logger.warn("Unauthorized: {} [{}]", ex.message, request.servletPath)
        return buildError(HttpStatus.UNAUTHORIZED, ex, request, "UNAUTHORIZED")
    }

    @ExceptionHandler(BadRequestException::class, IllegalArgumentException::class)
    fun handleBadRequest(ex: Exception, request: HttpServletRequest): ResponseEntity<ApiError> {
        logger.warn("BadRequest: {} [{}]", ex.message, request.servletPath)
        return buildError(HttpStatus.BAD_REQUEST, ex, request, "BAD_REQUEST")
    }

    @ExceptionHandler(org.springframework.security.access.AccessDeniedException::class)
    fun handleAccessDenied(
        ex: org.springframework.security.access.AccessDeniedException,
        request: HttpServletRequest
    ): ResponseEntity<ApiError> {
        logger.warn("AccessDenied: {} [{}]", ex.message, request.servletPath)
        return buildError(HttpStatus.FORBIDDEN, ex, request, "FORBIDDEN")
    }

    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleValidation(ex: MethodArgumentNotValidException, request: HttpServletRequest): ResponseEntity<ApiError> {
        val validationErrors = ex.bindingResult.fieldErrors.map { "${it.field}: ${it.defaultMessage}" }
        val message = "Error de validaci√≥n"
        logger.warn("Validation Error: {} [{}]", message, request.servletPath)
        return buildError(HttpStatus.BAD_REQUEST, ex, request, "VALIDATION_ERROR", validationErrors)
    }

    @ExceptionHandler(Exception::class)
    fun handleGeneric(ex: Exception, request: HttpServletRequest): ResponseEntity<ApiError> {
        logger.error("Internal Server Error at [{}]: {}", request.servletPath, ex.message, ex)
        return buildError(HttpStatus.INTERNAL_SERVER_ERROR, ex, request, "INTERNAL_ERROR")
    }

    private fun buildError(
        status: HttpStatus,
        ex: Exception,
        request: HttpServletRequest,
        code: String,
        validationErrors: List<String>? = null
    ): ResponseEntity<ApiError> {
        val message = if (code == "VALIDATION_ERROR") "Error de validaci√≥n" else (ex.message ?: status.reasonPhrase)
        val apiError = ApiError(
            message = message,
            code = code,
            status = status.value(),
            path = request.servletPath,
            validationErrors = validationErrors
        )
        return ResponseEntity.status(status).body(apiError)
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/historial/api/HistorialDtos.kt">
package cl.clinipets.veterinaria.historial.api

import cl.clinipets.veterinaria.historial.domain.FichaClinica
import jakarta.validation.constraints.Future
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.NotNull
import java.time.Instant
import java.time.LocalDate
import java.util.UUID

data class FichaCreateRequest(
    @field:NotNull(message = "El ID de la mascota es obligatorio")
    val mascotaId: UUID,
    val citaId: UUID? = null,
    val fechaAtencion: Instant = Instant.now(),
    @field:NotBlank(message = "El motivo de consulta es obligatorio")
    val motivoConsulta: String,
    
    // SOAP
    val anamnesis: String? = null,
    val hallazgosObjetivos: String? = null,
    val avaluoClinico: String? = null,
    val planTratamiento: String? = null,
    
    // Constantes Vitales
    val pesoRegistrado: Double? = null,
    val temperatura: Double? = null,
    val frecuenciaCardiaca: Int? = null,
    val frecuenciaRespiratoria: Int? = null,
    
    val observaciones: String? = null,
    val esVacuna: Boolean = false,
    val nombreVacuna: String? = null,
    @field:Future
    val fechaProximaVacuna: LocalDate? = null,
    @field:Future
    val fechaProximoControl: LocalDate? = null,
    val fechaDesparasitacion: LocalDate? = null
)

data class FichaUpdateRequest(
    val anamnesis: String? = null,
    val hallazgosObjetivos: String? = null,
    val avaluoClinico: String? = null,
    val planTratamiento: String? = null,
    
    // Constantes Vitales
    val pesoRegistrado: Double? = null,
    val temperatura: Double? = null,
    val frecuenciaCardiaca: Int? = null,
    val frecuenciaRespiratoria: Int? = null,
    
    val observaciones: String? = null,
    val fechaProximaVacuna: LocalDate? = null,
    val fechaProximoControl: LocalDate? = null,
    val fechaDesparasitacion: LocalDate? = null
)

data class FichaResponse(
    val id: UUID,
    val mascotaId: UUID,
    val citaId: UUID?,
    val fechaAtencion: Instant,
    val motivoConsulta: String,
    val anamnesis: String?,
    val hallazgosObjetivos: String?,
    val avaluoClinico: String?,
    val planTratamiento: String?,
    val pesoRegistrado: Double?,
    val temperatura: Double?,
    val frecuenciaCardiaca: Int?,
    val frecuenciaRespiratoria: Int?,
    val alertaVeterinaria: Boolean,
    val observaciones: String?,
    val esVacuna: Boolean,
    val nombreVacuna: String?,
    val fechaProximaVacuna: LocalDate?,
    val fechaProximoControl: LocalDate?,
    val fechaDesparasitacion: LocalDate?,
    val autorId: UUID
)

data class PesoPunto(
    val fecha: Instant,
    val peso: Double
)

data class PesoHistoryResponse(
    val mascotaId: UUID,
    val puntos: List<PesoPunto>
)

fun FichaClinica.toResponse() = FichaResponse(
    id = id!!,
    mascotaId = mascota.id!!,
    citaId = citaId,
    fechaAtencion = fechaAtencion,
    motivoConsulta = motivoConsulta,
    anamnesis = anamnesis,
    hallazgosObjetivos = hallazgosObjetivos,
    avaluoClinico = avaluoClinico,
    planTratamiento = planTratamiento,
    pesoRegistrado = pesoRegistrado,
    temperatura = temperatura,
    frecuenciaCardiaca = frecuenciaCardiaca,
    frecuenciaRespiratoria = frecuenciaRespiratoria,
    alertaVeterinaria = alertaVeterinaria,
    observaciones = observaciones,
    esVacuna = esVacuna,
    nombreVacuna = nombreVacuna,
    fechaProximaVacuna = fechaProximaVacuna,
    fechaProximoControl = fechaProximoControl,
    fechaDesparasitacion = fechaDesparasitacion,
    autorId = autorId
)
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/historial/domain/FichaClinica.kt">
package cl.clinipets.veterinaria.historial.domain

import cl.clinipets.core.domain.AuditableEntity
import cl.clinipets.veterinaria.domain.Mascota
import jakarta.persistence.*
import java.time.Instant
import java.time.LocalDate
import java.util.UUID

@Entity
@Table(name = "fichas_clinicas")
data class FichaClinica(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "mascota_id", nullable = false)
    val mascota: Mascota,

    @Column(nullable = true)
    val citaId: UUID? = null,

    @Column(nullable = false)
    val fechaAtencion: Instant = Instant.now(),

    @Column(nullable = false)
    val motivoConsulta: String,

    @Column(columnDefinition = "TEXT")
    val anamnesis: String? = null, // S: Subjetivo

    @Column(columnDefinition = "TEXT")
    val hallazgosObjetivos: String? = null, // O: Objetivo

    @Column(columnDefinition = "TEXT")
    val avaluoClinico: String? = null, // A: Aval√∫o

    @Column(columnDefinition = "TEXT")
    val planTratamiento: String? = null, // P: Plan

    // Constantes Vitales
    @Column(nullable = true)
    val pesoRegistrado: Double? = null,
    
    @Column(nullable = true)
    val temperatura: Double? = null,
    
    @Column(nullable = true)
    val frecuenciaCardiaca: Int? = null,
    
    @Column(nullable = true)
    val frecuenciaRespiratoria: Int? = null,

    @Column(nullable = false, columnDefinition = "boolean default false")
    val alertaVeterinaria: Boolean = false,

    @Column(columnDefinition = "TEXT")
    val observaciones: String? = null,

    @Column(nullable = false)
    val esVacuna: Boolean = false,

    val nombreVacuna: String? = null,

    val fechaProximaVacuna: LocalDate? = null,
    val fechaProximoControl: LocalDate? = null,
    val fechaDesparasitacion: LocalDate? = null,

    @Column(nullable = false)
    val autorId: UUID
) : AuditableEntity()
</file>

<file path="src/test/resources/application-test.properties">
# Configuraci√≥n de pruebas (Perfil "test")
# Database (H2 en memoria)
spring.datasource.url=jdbc:h2:mem:clinipets_test_db;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=true
# Security / JWT (Valores dummy)
jwt.secret=Y29udGFzZWNvbXNlY3JldG9iZGVDbGluSXBldHMxMjM0NTY3OA==
jwt.refresh-secret=cmVmcmVzaFNlY3JldG9iZGVDbGluSXBldHMxMjM0NTY3OA==
jwt.issuer=ClinipetsTest
jwt.expiration=3600000
jwt.refresh-expiration=86400000
# Google / IA / Firebase (Valores dummy)
ia.enabled=true
ia.provider=github
gh.api-key=test-github-token
gh.base-url=https://models.github.ai/inference
gh.max-output-tokens=128
gh.temperature=0.3
minio.enabled=false
google.client-id=dummy-google-client-id
google.firebase.credentials.path=classpath:firebase-dummy.json
# MercadoPago (Valores dummy)
mercadopago.access-token=TEST-12345678-1234-1234-1234-1234567890ab
# Otros
admin.email=admin@test.com
admin.initial-password=admin123
cors.allowed-origins=*
</file>

<file path="src/test/resources/application.properties">
ia.enabled=true
ia.provider=github
gh.api-key=test-github-token
gh.base-url=https://models.github.ai/inference
gh.max-output-tokens=128
gh.temperature=0.3
minio.enabled=false
mercadopago.access-token=test-mp-token
</file>

<file path=".gitignore">
# Ignore environment files
.env
.env.*
!.env.example

# Gradle
.gradle/
build/
out/

# IntelliJ IDEA
.idea/
*.iml

# Logs
*.log

# OS files
.DS_Store
Thumbs.db

# Certs/keys (no subir secretos)
certs/
*.pem
*.key
*.crt
*.cer
*.der
*.p12
*.pfx
*.jks

/clinipets.pem
/entityManagerFactory(EntityManagerFactoryBuilder, PersistenceManagedTypes).md

firebase-service-account.json
service-account.json
*.json
repomix-backendv2.xml
repomix-output.xml
/htmlReport/
</file>

<file path="gradle.properties">
# Optimizaci√≥n de Gradle y toolchains
org.gradle.jvmargs=-Xmx1g -Dfile.encoding=UTF-8
org.gradle.daemon=true
org.gradle.parallel=true
org.gradle.caching=true
# Hace que Gradle descargue autom√°ticamente el JDK configurado en la toolchain (JDK 21)
org.gradle.java.installations.auto-download=true
# Perfil local con H2 en memoria para desarrollo r√°pido
spring.datasource.url=jdbc:h2:mem:localdb;MODE=PostgreSQL;DB_CLOSE_DELAY=-1
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.hibernate.ddl-auto=update
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.open-in-view=false
# Logs m√°s verbosos en local si se desea
logging.level.org.springframework=info
logging.level.org.hibernate.SQL=warn
systemProp.sonar.token=sqa_7c34a9a8c988f879b6fdcb103f6157a3764e2c6d
</file>

<file path="README.md">
```bash 
repomix --ignore "**/build/**,**/target/**,**/.gradle/**,**/.idea/**,**/.git/**,**/*.jar,**/*.class,**/mvnw*,firebase-service-account.json" --output repomix-backendversionhf.xml   
```

## Sistema de Agendamiento - Estados de Cita

El sistema utiliza una m√°quina de estados simplificada para gestionar el flujo de atenci√≥n:

### Estados
- **CONFIRMADA**: La cita ha sido reservada (a√∫n no pagada).
- **EN_ATENCION**: El paciente est√° siendo atendido por el veterinario.
- **FINALIZADA**: La atenci√≥n concluy√≥, se proces√≥ el pago y se descont√≥ el stock.
- **CANCELADA**: La cita fue cancelada y el stock (si se hubiera consumido) fue devuelto.
- **NO_ASISTIO**: El paciente no se present√≥ (No Show).

### Flujo Principal
`CONFIRMADA` ‚Üí `EN_ATENCION` ‚Üí `FINALIZADA`

### Otros Flujos
- `CONFIRMADA` ‚Üí `CANCELADA` (Cancelaci√≥n previa)
- `CONFIRMADA` ‚Üí `NO_ASISTIO` (Limpieza autom√°tica tras expiraci√≥n)
- `EN_ATENCION` ‚Üí `CANCELADA` (Si falla el pago o el consumo de stock al finalizar)

### Reglas de Negocio
- **Reserva**: Se valida disponibilidad de stock pero NO se descuenta.
- **Finalizaci√≥n**: Se intenta descontar stock con lock pesimista. Si falla, la cita pasa a `CANCELADA` autom√°ticamente.
- **Limpieza**: Citas `CONFIRMADA` expiradas pasan a `NO_ASISTIO`.
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/domain/EstadoCita.kt">
package cl.clinipets.agendamiento.domain

import cl.clinipets.core.web.BadRequestException

enum class EstadoCita {
    CONFIRMADA,    // Reservada sin pagar
    EN_ATENCION,   // Vet atendiendo
    FINALIZADA,    // Pagada y stock descontado
    CANCELADA,     // Cancelada (stock devuelto)
    NO_ASISTIO     // No show (para estad√≠sticas futuras)
}

/**
 * M√°quina de estados que valida transiciones permitidas
 */
object EstadoCitaTransiciones {
    private val TRANSICIONES = mapOf(
        EstadoCita.CONFIRMADA to setOf(
            EstadoCita.EN_ATENCION,
            EstadoCita.CANCELADA,
            EstadoCita.NO_ASISTIO
        ),
        EstadoCita.EN_ATENCION to setOf(
            EstadoCita.FINALIZADA,
            EstadoCita.CANCELADA
        ),
        EstadoCita.FINALIZADA to emptySet(),
        EstadoCita.CANCELADA to emptySet(),
        EstadoCita.NO_ASISTIO to emptySet()
    )

    fun validarTransicion(desde: EstadoCita, hacia: EstadoCita) {
        if (TRANSICIONES[desde]?.contains(hacia) != true) {
            throw BadRequestException("No se puede cambiar de $desde a $hacia")
        }
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/api/PingController.kt">
package cl.clinipets.core.api

import cl.clinipets.core.security.JwtPayload
import io.swagger.v3.oas.annotations.Operation
import org.springframework.http.ResponseEntity
import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.slf4j.LoggerFactory
import org.springframework.web.bind.annotation.RestController

data class PingResponse(
    val message: String,
    val user: String?
)

@RestController
@RequestMapping("/api")
class PingController() {
    private val logger = LoggerFactory.getLogger(PingController::class.java)

    @Operation(summary = "Ping", operationId = "ping")
    @GetMapping("/ping")
    fun ping(@AuthenticationPrincipal principal: JwtPayload?): ResponseEntity<PingResponse> {
        logger.info("[PING] Request recibido. User: {}", principal?.email ?: "Anonimo")
        return ResponseEntity.ok(
            PingResponse(
                message = "pong",
                user = principal?.email
            )
        )
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/api/MascotaController.kt">
package cl.clinipets.veterinaria.api

import cl.clinipets.veterinaria.api.MascotaClinicalUpdateRequest
import cl.clinipets.veterinaria.api.MascotaCreateRequest
import cl.clinipets.veterinaria.api.MascotaResponse
import cl.clinipets.veterinaria.api.MascotaUpdateRequest
import cl.clinipets.veterinaria.api.PasaporteSaludResponse
import cl.clinipets.veterinaria.application.MascotaService
import cl.clinipets.core.security.JwtPayload
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import jakarta.validation.Valid
import org.springframework.http.ResponseEntity
import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.web.bind.annotation.*
import org.slf4j.LoggerFactory
import java.util.UUID

@RestController
@RequestMapping("/api/mascotas")
class MascotaController(
    private val mascotaService: MascotaService
) {
    private val logger = LoggerFactory.getLogger(MascotaController::class.java)

    @Operation(summary = "Consultar pasaporte de salud", operationId = "pasaporteSalud")
    @ApiResponses(
        ApiResponse(responseCode = "200", description = "Pasaporte obtenido"),
        ApiResponse(responseCode = "404", description = "Mascota no encontrada")
    )
    @GetMapping("/{id}/pasaporte-salud")
    fun pasaporteSalud(
        @PathVariable id: UUID,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<PasaporteSaludResponse> {
        logger.info("[PASAPORTE_SALUD] Consulta para mascota: {}", id)
        val response = mascotaService.consultarPasaporteSalud(id, principal)
        return ResponseEntity.ok(response)
    }

    @Operation(summary = "Consultar historial de signos vitales", operationId = "historialVitals")
    @ApiResponses(
        ApiResponse(responseCode = "200", description = "Historial obtenido"),
        ApiResponse(responseCode = "404", description = "Mascota no encontrada")
    )
    @GetMapping("/{id}/historial-vitals")
    fun historialVitals(
        @PathVariable id: UUID,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<List<cl.clinipets.veterinaria.api.SignosVitalesDto>> {
        logger.info("[HISTORIAL_VITALS] Consulta para mascota: {}", id)
        val response = mascotaService.consultarHistorialVitals(id, principal)
        return ResponseEntity.ok(response)
    }

    @Operation(summary = "Crear mascota", operationId = "crearMascota")
    @ApiResponses(
        ApiResponse(responseCode = "200", description = "Mascota creada"),
        ApiResponse(responseCode = "400", description = "Datos inv√°lidos")
    )
    @PostMapping
    fun crear(
        @Valid @RequestBody request: MascotaCreateRequest,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<MascotaResponse> {
        logger.info("[CREAR_MASCOTA] Inicio request. Tutor: {}", principal.email)
        val response = mascotaService.crear(request, principal)
        logger.info("[CREAR_MASCOTA] Fin request - Exitoso. MascotaID: {}", response.id)
        return ResponseEntity.ok(response)
    }

    @Operation(summary = "Listar mascotas", operationId = "listarMascotas")
    @ApiResponses(
        ApiResponse(responseCode = "200", description = "Lista de mascotas")
    )
    @GetMapping
    fun listar(
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<List<MascotaResponse>> {
        logger.info("[LISTAR_MASCOTAS] Inicio request. Tutor: {}", principal.email)
        val response = mascotaService.listar(principal)
        logger.info("[LISTAR_MASCOTAS] Fin request - Encontradas: {}", response.size)
        return ResponseEntity.ok(response)
    }

    @Operation(summary = "Obtener mascota", operationId = "obtenerMascota")
    @ApiResponses(
        ApiResponse(responseCode = "200", description = "Mascota encontrada"),
        ApiResponse(responseCode = "404", description = "Mascota no encontrada")
    )
    @GetMapping("/{id}")
    fun obtener(
        @PathVariable id: UUID,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<MascotaResponse> {
        logger.info("[OBTENER_MASCOTA] Inicio request. ID: {}, Tutor: {}", id, principal.email)
        val response = mascotaService.obtener(id, principal)
        logger.info("[OBTENER_MASCOTA] Fin request - Exitoso")
        return ResponseEntity.ok(response)
    }

    @Operation(summary = "Actualizar mascota", operationId = "actualizarMascota")
    @ApiResponses(
        ApiResponse(responseCode = "200", description = "Mascota actualizada"),
        ApiResponse(responseCode = "404", description = "Mascota no encontrada")
    )
    @PutMapping("/{id}")
    fun actualizar(
        @PathVariable id: UUID,
        @Valid @RequestBody request: MascotaUpdateRequest,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<MascotaResponse> {
        logger.info("[ACTUALIZAR_MASCOTA] Inicio request. ID: {}, Tutor: {}", id, principal.email)
        val response = mascotaService.actualizar(id, request, principal)
        logger.info("[ACTUALIZAR_MASCOTA] Fin request - Exitoso")
        return ResponseEntity.ok(response)
    }

    @Operation(summary = "Actualizar datos cl√≠nicos (Staff/Admin)", operationId = "actualizarDatosClinicos")
    @ApiResponses(
        ApiResponse(responseCode = "200", description = "Datos cl√≠nicos actualizados"),
        ApiResponse(responseCode = "403", description = "Sin permisos"),
        ApiResponse(responseCode = "404", description = "Mascota no encontrada")
    )
    @PatchMapping("/{id}/clinico")
    @PreAuthorize("hasAnyRole('ADMIN', 'STAFF')")
    fun actualizarDatosClinicos(
        @PathVariable id: UUID,
        @RequestBody request: MascotaClinicalUpdateRequest
    ): ResponseEntity<MascotaResponse> {
        logger.info("[ACTUALIZAR_CLINICO] Inicio request. ID: {}", id)
        val response = mascotaService.actualizarDatosClinicos(id, request)
        logger.info("[ACTUALIZAR_CLINICO] Fin request - Exitoso")
        return ResponseEntity.ok(response)
    }

    @Operation(summary = "Eliminar mascota", operationId = "eliminarMascota")
    @ApiResponses(
        ApiResponse(responseCode = "204", description = "Mascota eliminada"),
        ApiResponse(responseCode = "404", description = "Mascota no encontrada")
    )
    @DeleteMapping("/{id}")
    fun eliminar(
        @PathVariable id: UUID,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<Void> {
        logger.info("[ELIMINAR_MASCOTA] Inicio request. ID: {}, Tutor: {}", id, principal.email)
        mascotaService.eliminar(id, principal)
        logger.info("[ELIMINAR_MASCOTA] Fin request - Exitoso")
        return ResponseEntity.noContent().build()
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/historial/api/FichaClinicaController.kt">
package cl.clinipets.veterinaria.historial.api

import cl.clinipets.core.security.JwtPayload
import cl.clinipets.core.web.UnauthorizedException
import cl.clinipets.identity.domain.UserRole
import cl.clinipets.veterinaria.domain.MascotaRepository
import cl.clinipets.veterinaria.historial.application.FichaClinicaService
import cl.clinipets.veterinaria.historial.application.PdfService
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import jakarta.validation.Valid
import org.slf4j.LoggerFactory
import org.springframework.core.io.ByteArrayResource
import org.springframework.data.domain.Page
import org.springframework.data.domain.Pageable
import org.springframework.data.domain.Sort
import org.springframework.data.web.PageableDefault
import org.springframework.http.HttpHeaders
import org.springframework.http.HttpStatus
import org.springframework.http.MediaType
import org.springframework.http.ResponseEntity
import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.web.bind.annotation.*
import java.util.UUID

@RestController
@RequestMapping("/api/v1/fichas")
class FichaClinicaController(
    private val fichaService: FichaClinicaService,
    private val mascotaRepository: MascotaRepository, // Needed for ownership check
    private val pdfService: PdfService
) {
    private val logger = LoggerFactory.getLogger(FichaClinicaController::class.java)

    @Operation(summary = "Crear ficha cl√≠nica (Admin/Staff)", operationId = "crearFicha")
    @ApiResponses(
        ApiResponse(responseCode = "201", description = "Ficha creada exitosamente"),
        ApiResponse(responseCode = "400", description = "Datos inv√°lidos"),
        ApiResponse(responseCode = "404", description = "Mascota no encontrada")
    )
    @PostMapping
    @PreAuthorize("hasAnyRole('ADMIN', 'STAFF')")
    fun crearFicha(
        @Valid @RequestBody request: FichaCreateRequest,
        @AuthenticationPrincipal user: JwtPayload
    ): ResponseEntity<FichaResponse> {
        logger.info("[CREAR_FICHA] Inicio. Staff: {}, MascotaID: {}", user.email, request.mascotaId)
        val ficha = fichaService.crearFicha(request, user.userId)
        logger.info("[CREAR_FICHA] Fin - Exitoso. FichaID: {}", ficha.id)
        return ResponseEntity.status(HttpStatus.CREATED).body(ficha)
    }

    @Operation(summary = "Actualizar ficha cl√≠nica (Admin/Staff)", operationId = "actualizarFicha")
    @PutMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMIN', 'STAFF')")
    fun actualizarFicha(
        @PathVariable id: UUID,
        @Valid @RequestBody request: FichaUpdateRequest,
        @AuthenticationPrincipal user: JwtPayload
    ): ResponseEntity<FichaResponse> {
        logger.info("[ACTUALIZAR_FICHA] Inicio. Staff: {}, FichaID: {}", user.email, id)
        val ficha = fichaService.actualizarFicha(id, request)
        return ResponseEntity.ok(ficha)
    }

    @Operation(summary = "Obtener historial m√©dico paginado", operationId = "obtenerHistorial")
    @ApiResponses(
        ApiResponse(responseCode = "200", description = "Historial obtenido exitosamente"),
        ApiResponse(responseCode = "404", description = "Mascota no encontrada"),
        ApiResponse(responseCode = "403", description = "No tiene permiso para ver esta mascota")
    )
    @GetMapping("/mascota/{mascotaId}")
    @PreAuthorize("hasAnyRole('ADMIN', 'STAFF', 'CLIENT')")
    fun obtenerHistorial(
        @PathVariable mascotaId: UUID,
        @PageableDefault(size = 10, sort = ["fechaAtencion"], direction = Sort.Direction.DESC) pageable: Pageable,
        @AuthenticationPrincipal user: JwtPayload
    ): ResponseEntity<Page<FichaResponse>> {
        logger.info("[HISTORIAL] Inicio. User: {}, MascotaID: {}, Page: {}", user.email, mascotaId, pageable.pageNumber)
        
        // If user is CLIENT, must verify ownership
        if (user.role == UserRole.CLIENT) {
             val mascota = mascotaRepository.findById(mascotaId).orElse(null)
             // If mascota doesn't exist, Service will throw NotFound, but here we check access
             if (mascota != null && mascota.tutor.id != user.userId) {
                 logger.warn("[HISTORIAL] Acceso denegado. Mascota {} no pertenece a {}", mascotaId, user.email)
                 throw UnauthorizedException("No tiene permiso para ver el historial de esta mascota.")
             }
        }

        val historial = fichaService.obtenerHistorial(mascotaId, pageable)
        logger.info("[HISTORIAL] Fin - Registros: {}", historial.numberOfElements)
        return ResponseEntity.ok(historial)
    }

    @Operation(summary = "Obtener historial de peso (Gr√°fico)", operationId = "obtenerGraficoPeso")
    @GetMapping("/mascota/{mascotaId}/grafico-peso")
    @PreAuthorize("hasAnyRole('ADMIN', 'STAFF', 'CLIENT')")
    fun obtenerGraficoPeso(
        @PathVariable mascotaId: UUID,
        @AuthenticationPrincipal user: JwtPayload
    ): ResponseEntity<PesoHistoryResponse> {
        logger.info("[PESO_GRAFICO] Solicitud. Mascota: {}, Usuario: {}", mascotaId, user.email)
        
        // Ownership check for CLIENT
        if (user.role == UserRole.CLIENT) {
            val mascota = mascotaRepository.findById(mascotaId).orElse(null)
            if (mascota != null && mascota.tutor.id != user.userId) {
                throw UnauthorizedException("No tiene permiso para ver los datos de esta mascota.")
            }
        }

        return ResponseEntity.ok(fichaService.obtenerHistorialPeso(mascotaId))
    }

    @Operation(summary = "Obtener ficha por ID de cita", operationId = "obtenerFichaPorCita")
    @GetMapping("/cita/{citaId}")
    @PreAuthorize("hasAnyRole('ADMIN', 'STAFF', 'CLIENT')")
    fun obtenerFichaPorCita(
        @PathVariable citaId: UUID,
        @AuthenticationPrincipal user: JwtPayload
    ): ResponseEntity<FichaResponse> {
        logger.info("[FICHA_CITA] Solicitud. Cita: {}, Usuario: {}", citaId, user.email)
        val ficha = fichaService.obtenerFichaPorCita(citaId)
        
        // Ownership check for CLIENT
        if (user.role == UserRole.CLIENT) {
            val mascota = mascotaRepository.findById(ficha.mascotaId).orElse(null)
            if (mascota != null && mascota.tutor.id != user.userId) {
                throw UnauthorizedException("No tiene permiso para ver esta ficha.")
            }
        }
        
        return ResponseEntity.ok(ficha)
    }

    @Operation(summary = "Descargar PDF de ficha cl√≠nica", operationId = "descargarFichaPdf")
    @ApiResponses(
        ApiResponse(responseCode = "200", description = "PDF generado exitosamente"),
        ApiResponse(responseCode = "404", description = "Ficha no encontrada")
    )
    @GetMapping("/{fichaId}/pdf")
    @PreAuthorize("hasAnyRole('ADMIN', 'STAFF', 'CLIENT')")
    fun descargarFichaPdf(
        @PathVariable fichaId: UUID,
        @AuthenticationPrincipal user: JwtPayload
    ): ResponseEntity<ByteArrayResource> {
        logger.info("[FICHA_PDF] Solicitud de PDF. Ficha: {}, Usuario: {}", fichaId, user.email)
        val pdfBytes = pdfService.generarFichaClinicaPdf(fichaId, user)
        val headers = HttpHeaders().apply {
            contentType = MediaType.APPLICATION_PDF
            add(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"ficha-$fichaId.pdf\"")
        }
        return ResponseEntity.ok()
            .headers(headers)
            .contentLength(pdfBytes.size.toLong())
            .body(ByteArrayResource(pdfBytes))
    }
}
</file>

<file path="Dockerfile">
# Dockerfile Ligero para Desarrollo
FROM eclipse-temurin:21-jre-alpine

WORKDIR /app

# Herramienta para Healthcheck (necesaria para tu docker-compose)
RUN apk add --no-cache curl

# Copiamos el JAR que compilaste en tu m√°quina
# El contexto de build debe tener el jar generado en build/libs/
COPY build/libs/*.jar app.jar

# Ejecutamos
ENTRYPOINT ["java", "-jar", "app.jar"]
</file>

<file path="src/main/kotlin/cl/clinipets/identity/api/AuthDtos.kt">
package cl.clinipets.identity.api

import cl.clinipets.identity.domain.UserRole
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Pattern
import jakarta.validation.constraints.Size
import java.util.UUID

// Se eliminaron DTOs de Login manual, OTP y Tokens internos

data class ProfileResponse(
    val id: UUID,
    val email: String,
    val name: String,
    val role: UserRole,
    val photoUrl: String?,
    val phone: String?,
    val address: String?,
    val phoneVerified: Boolean
)

data class UserUpdateRequest(
    @field:NotBlank(message = "El nombre es obligatorio")
    @field:Size(min = 3, max = 100, message = "El nombre debe tener entre 3 y 100 caracteres")
    @field:Pattern(regexp = "^[a-zA-Z√°√©√≠√≥√∫√Å√â√ç√ì√ö√±√ë\\s]+$", message = "El nombre solo puede contener letras y espacios")
    val name: String,

    @field:Size(max = 20, message = "El tel√©fono no puede exceder los 20 caracteres")
    val phone: String?,

    @field:Size(max = 255, message = "La direcci√≥n no puede exceder los 255 caracteres")
    val address: String?
)
</file>

<file path="src/main/kotlin/cl/clinipets/identity/domain/User.kt">
package cl.clinipets.identity.domain

import jakarta.persistence.*
import java.time.Instant
import java.util.UUID

@Entity
@Table(name = "users")
data class User(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @Column(nullable = false, unique = true)
    var email: String,

    @Column(nullable = false)
    var name: String,

    @Column(nullable = false)
    val passwordHash: String,

    var phone: String? = null,
    var address: String? = null,

    @Column(length = 1024)
    var photoUrl: String? = null,

    @Column(nullable = false)
    var phoneVerified: Boolean = false,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 16)
    var authProvider: AuthProvider = AuthProvider.OTP,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 32)
    var role: UserRole = UserRole.CLIENT,

    @Column(length = 512)
    var fcmToken: String? = null,

    @Column(nullable = false, updatable = false)
    val createdAt: Instant = Instant.now()
)
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/api/MascotaDtos.kt">
package cl.clinipets.veterinaria.api

import cl.clinipets.veterinaria.domain.Especie
import cl.clinipets.veterinaria.domain.Mascota
import cl.clinipets.veterinaria.domain.Sexo
import cl.clinipets.veterinaria.domain.Temperamento
import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.NotNull
import java.math.BigDecimal
import java.time.LocalDate
import java.util.UUID

data class MascotaCreateRequest(
    @field:NotBlank(message = "El nombre es obligatorio")
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val nombre: String,

    @field:NotNull(message = "La especie es obligatoria")
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val especie: Especie,

    @field:NotBlank(message = "La raza es obligatoria (o 'Mestizo')")
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val raza: String,

    @field:NotNull(message = "El sexo es obligatorio")
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val sexo: Sexo,

    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val esterilizado: Boolean = false,

    val chipIdentificador: String? = null,

    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val temperamento: Temperamento = Temperamento.DOCIL,

    val pesoActual: Double? = null,
    val fechaNacimiento: LocalDate? = null
)

data class MascotaUpdateRequest(
    @field:NotBlank(message = "El nombre es obligatorio")
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val nombre: String,

    @field:NotNull(message = "El peso es obligatorio")
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val pesoActual: Double,
    
    val raza: String?,
    val sexo: Sexo?,
    val esterilizado: Boolean?,
    val chipIdentificador: String?,
    val temperamento: Temperamento?
)

data class MascotaClinicalUpdateRequest(
    val pesoActual: Double?,
    val esterilizado: Boolean?,
    val testRetroviralNegativo: Boolean?,
    val observaciones: String?
)

data class MascotaResponse(
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val id: UUID,

    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val nombre: String,

    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val especie: Especie,

    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val raza: String,

    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val sexo: Sexo,

    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val esterilizado: Boolean,

    val chipIdentificador: String?,

    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val temperamento: Temperamento,

    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED, example = "5.5")
    val pesoActual: Double,

    val fechaNacimiento: LocalDate?,

    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val tutorId: UUID,

    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val testRetroviralNegativo: Boolean,

    val fechaUltimoTestRetroviral: LocalDate?,
    val observacionesClinicas: String?
)

data class ItemPreventivoResponse(
    val tipo: cl.clinipets.veterinaria.domain.TipoPreventivo,
    val producto: String,
    val fechaAplicacion: java.time.Instant,
    val fechaRefuerzo: java.time.Instant?,
    val lote: String?,
    val observaciones: String?
)

data class PasaporteSaludResponse(
    val mascotaId: UUID,
    val nombreMascota: String,
    val especie: Especie,
    val preventivos: List<ItemPreventivoResponse>
)

data class SignosVitalesDto(
    val id: UUID,
    val peso: Double,
    val temperatura: Double,
    val frecuenciaCardiaca: String,
    val fecha: java.time.Instant
)

fun cl.clinipets.veterinaria.domain.SignosVitales.toDto() = SignosVitalesDto(
    id = id!!,
    peso = peso,
    temperatura = temperatura,
    frecuenciaCardiaca = frecuenciaCardiaca,
    fecha = fecha
)

fun cl.clinipets.veterinaria.domain.PlanPreventivo.toItemResponse() = ItemPreventivoResponse(
    tipo = tipo,
    producto = producto,
    fechaAplicacion = fechaAplicacion,
    fechaRefuerzo = fechaRefuerzo,
    lote = lote,
    observaciones = observaciones
)

fun Mascota.toResponse() = MascotaResponse(
    id = id!!,
    nombre = nombre,
    especie = especie,
    raza = raza,
    sexo = sexo,
    esterilizado = esterilizado,
    chipIdentificador = chipIdentificador,
    temperamento = temperamento,
    pesoActual = pesoActual,
    fechaNacimiento = fechaNacimiento,
    tutorId = tutor.id!!,
    testRetroviralNegativo = testRetroviralNegativo,
    fechaUltimoTestRetroviral = fechaUltimoTestRetroviral,
    observacionesClinicas = observacionesClinicas
)
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/domain/Mascota.kt">
package cl.clinipets.veterinaria.domain

import cl.clinipets.core.domain.AuditableEntity
import cl.clinipets.identity.domain.User
import jakarta.persistence.*
import java.math.BigDecimal
import java.time.LocalDate
import java.util.UUID

@Entity
@Table(name = "mascotas")
data class Mascota(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @Column(nullable = false)
    var nombre: String,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 16)
    val especie: Especie,

    @Column(nullable = false)
    var pesoActual: Double,

    @Column(nullable = false)
    var raza: String = "Mestizo",

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 10)
    var sexo: Sexo,

    @Column(nullable = false)
    var esterilizado: Boolean = false,

    @Column(unique = true)
    var chipIdentificador: String? = null,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 10)
    var temperamento: Temperamento = Temperamento.DOCIL,

    @Column(nullable = false)
    val fechaNacimiento: LocalDate,

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "tutor_id", nullable = false)
    var tutor: User,

    @OneToMany(mappedBy = "mascota", cascade = [CascadeType.ALL], fetch = FetchType.LAZY)
    val signosVitales: MutableList<SignosVitales> = mutableListOf(),

    @Column(nullable = false)
    var testRetroviralNegativo: Boolean = false,

    @Column(nullable = true)
    var fechaUltimoTestRetroviral: LocalDate? = null,

    @Column(nullable = true, length = 2000)
    var observacionesClinicas: String? = null
) : AuditableEntity()
</file>

<file path="src/main/kotlin/cl/clinipets/ClinipetsApplication.kt">
package cl.clinipets

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration
import org.springframework.boot.runApplication
import org.springframework.retry.annotation.EnableRetry
import org.springframework.scheduling.annotation.EnableAsync
import org.springframework.scheduling.annotation.EnableScheduling

@SpringBootApplication(exclude = [UserDetailsServiceAutoConfiguration::class])
@EnableScheduling
@EnableAsync
@EnableRetry
class ClinipetsApplication

fun main(args: Array<String>) {
    runApplication<ClinipetsApplication>(*args)
}
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/domain/CitaRepository.kt">
package cl.clinipets.agendamiento.domain

import org.springframework.data.jpa.repository.EntityGraph
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.query.Param
import org.springframework.stereotype.Repository
import java.time.Instant
import java.util.UUID

@Repository
interface CitaRepository : JpaRepository<Cita, UUID> {
    @Query("SELECT c FROM Cita c WHERE c.fechaHoraFin > :start AND c.fechaHoraInicio < :end")
    fun findOverlappingCitas(
        start: Instant,
        end: Instant
    ): List<Cita>

    @EntityGraph(attributePaths = ["detalles", "detalles.servicio", "detalles.mascota"])
    fun findAllByTutorIdOrderByFechaHoraInicioDesc(tutorId: UUID): List<Cita>

    fun findAllByFechaHoraInicioBetweenOrderByFechaHoraInicioAsc(start: Instant, end: Instant): List<Cita>

    @Query("SELECT DISTINCT c FROM Cita c JOIN c.detalles d WHERE d.mascota.id = :mascotaId")
    @EntityGraph(attributePaths = ["detalles", "detalles.servicio", "detalles.mascota"])
    fun findAllByMascotaId(@Param("mascotaId") mascotaId: UUID): List<Cita>

    fun findByEstadoAndCreatedAtBefore(estado: EstadoCita, date: Instant): List<Cita>
}
</file>

<file path="src/main/kotlin/cl/clinipets/identity/api/AuthController.kt">
package cl.clinipets.identity.api

import cl.clinipets.core.security.JwtPayload
import cl.clinipets.identity.application.AuthService
import io.swagger.v3.oas.annotations.Operation
import jakarta.validation.Valid
import org.slf4j.LoggerFactory
import org.springframework.http.ResponseEntity
import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping("/api/v1/auth")
class AuthController(
    private val authService: AuthService
) {
    private val logger = LoggerFactory.getLogger(AuthController::class.java)

    @Operation(summary = "Login/Sync con Firebase", operationId = "firebaseAuth")
    @PostMapping("/firebase")
    fun firebaseAuth(@AuthenticationPrincipal principal: JwtPayload): ResponseEntity<ProfileResponse> {
        // El usuario ya fue autenticado y sincronizado por FirebaseFilter antes de llegar aqu√≠.
        // Solo necesitamos retornar su perfil.
        logger.info("[AUTH] Login exitoso para: ${principal.email}")
        return ResponseEntity.ok(authService.me(principal))
    }

    @Operation(summary = "Obtener perfil actual", operationId = "getProfile")
    @GetMapping("/me")
    fun me(@AuthenticationPrincipal principal: JwtPayload): ResponseEntity<ProfileResponse> {
        return ResponseEntity.ok(authService.me(principal))
    }

    @Operation(summary = "Actualizar perfil de usuario", operationId = "updateProfile")
    @PutMapping("/me")
    fun updateMe(
        @AuthenticationPrincipal principal: JwtPayload,
        @Valid @RequestBody request: UserUpdateRequest
    ): ResponseEntity<ProfileResponse> {
        return ResponseEntity.ok(authService.updateProfile(principal.userId, request))
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/api/ServicioDtos.kt">
package cl.clinipets.servicios.api

import cl.clinipets.servicios.domain.CategoriaServicio
import cl.clinipets.servicios.domain.ReglaPrecio
import cl.clinipets.servicios.domain.ServicioMedico
import cl.clinipets.servicios.domain.ServicioInsumo
import cl.clinipets.veterinaria.domain.Especie
import java.math.BigDecimal
import java.util.UUID

data class ReglaPrecioDto(
    val id: UUID,
    val pesoMin: Double,
    val pesoMax: Double,
    val precio: Int
)

data class InsumoDto(
    val id: UUID,
    val nombre: String,
    val cantidadRequerida: Double,
    val unidadMedida: String,
    val critico: Boolean
)

data class InsumoDetalladoDto(
    val id: UUID,
    val nombre: String,
    val stockActual: Double,
    val stockMinimo: Int,
    val unidadMedida: String
)

data class ServicioMedicoDto(
    val id: UUID,
    val nombre: String,
    val precioBase: Int,
    val precioAbono: Int?,
    val requierePeso: Boolean,
    val duracionMinutos: Int,
    val activo: Boolean,
    val categoria: CategoriaServicio,
    val especiesPermitidas: Set<Especie>,
    val stock: Int?,
    val bloqueadoSiEsterilizado: Boolean,
    val serviciosRequeridosIds: Set<UUID>,
    val reglas: List<ReglaPrecioDto>,
    val insumos: List<InsumoDto>
)

fun ServicioMedico.toDto() = ServicioMedicoDto(
    id = id!!,
    nombre = nombre,
    precioBase = precioBase,
    precioAbono = precioAbono,
    requierePeso = requierePeso,
    duracionMinutos = duracionMinutos,
    activo = activo,
    categoria = categoria,
    especiesPermitidas = especiesPermitidas,
    stock = stock,
    bloqueadoSiEsterilizado = bloqueadoSiEsterilizado,
    serviciosRequeridosIds = serviciosRequeridosIds,
    reglas = reglas.map(ReglaPrecio::toDto),
    insumos = insumos.map(ServicioInsumo::toDto)
)

fun ReglaPrecio.toDto() = ReglaPrecioDto(
    id = id!!,
    pesoMin = pesoMin,
    pesoMax = pesoMax,
    precio = precio
)

fun ServicioInsumo.toDto() = InsumoDto(

    id = insumo.id!!,

    nombre = insumo.nombre,

    cantidadRequerida = cantidadRequerida,

    unidadMedida = insumo.unidadMedida,

    critico = critico

)


fun cl.clinipets.servicios.domain.Insumo.toDetalladoDto() = InsumoDetalladoDto(

    id = id!!,

    nombre = nombre,

    stockActual = stockActual,

    stockMinimo = stockMinimo,

    unidadMedida = unidadMedida

)
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/historial/application/FichaClinicaService.kt">
package cl.clinipets.veterinaria.historial.application

import cl.clinipets.agendamiento.domain.CitaRepository
import cl.clinipets.agendamiento.domain.EstadoCita
import cl.clinipets.core.web.NotFoundException
import cl.clinipets.veterinaria.domain.MascotaRepository
import cl.clinipets.veterinaria.historial.api.*
import cl.clinipets.veterinaria.historial.domain.FichaClinica
import cl.clinipets.veterinaria.historial.domain.FichaClinicaRepository
import org.slf4j.LoggerFactory
import org.springframework.data.domain.Page
import org.springframework.data.domain.Pageable
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.util.UUID

@Service
class FichaClinicaService(
    private val fichaRepository: FichaClinicaRepository,
    private val mascotaRepository: MascotaRepository,
    private val citaRepository: CitaRepository
) {
    private val logger = LoggerFactory.getLogger(FichaClinicaService::class.java)

    @Transactional
    fun crearFicha(request: FichaCreateRequest, autorId: UUID): FichaResponse {
        logger.debug("[FICHA_SERVICE] Creando ficha estructurada para mascota {}", request.mascotaId)
        val mascota = mascotaRepository.findById(request.mascotaId)
            .orElseThrow { NotFoundException("Mascota no encontrada con ID: ${request.mascotaId}") }

        // L√≥gica de Alerta Veterinaria (Ej: Fiebre)
        val tieneAlerta = request.temperatura != null && request.temperatura > 39.5

        if (tieneAlerta) {
            logger.warn("[FICHA_SERVICE] ¬°ALERTA! Mascota {} con temperatura elevada: {}", mascota.id, request.temperatura)
        }

        // Actualizar peso de la mascota si viene en la ficha
        if (request.pesoRegistrado != null && request.pesoRegistrado > 0) {
            logger.info("[FICHA_SERVICE] Actualizando peso mascota: {} -> {}", mascota.pesoActual, request.pesoRegistrado)
            mascota.pesoActual = request.pesoRegistrado
            // recalcularPrecioCitaActiva(mascota) // Opcional si se quiere automatizar el cambio de precio
        }

        val ficha = fichaRepository.save(
            FichaClinica(
                mascota = mascota,
                citaId = request.citaId,
                fechaAtencion = request.fechaAtencion,
                motivoConsulta = request.motivoConsulta,
                anamnesis = request.anamnesis,
                hallazgosObjetivos = request.hallazgosObjetivos,
                avaluoClinico = request.avaluoClinico,
                planTratamiento = request.planTratamiento,
                pesoRegistrado = request.pesoRegistrado,
                temperatura = request.temperatura,
                frecuenciaCardiaca = request.frecuenciaCardiaca,
                frecuenciaRespiratoria = request.frecuenciaRespiratoria,
                alertaVeterinaria = tieneAlerta,
                observaciones = request.observaciones,
                esVacuna = request.esVacuna,
                nombreVacuna = request.nombreVacuna,
                fechaProximaVacuna = request.fechaProximaVacuna,
                fechaProximoControl = request.fechaProximoControl,
                fechaDesparasitacion = request.fechaDesparasitacion,
                autorId = autorId
            )
        )

        // Si hay una cita asociada, moverla a EN_ATENCION si a√∫n est√° CONFIRMADA
        request.citaId?.let { cId ->
            citaRepository.findById(cId).ifPresent { cita ->
                if (cita.estado == EstadoCita.CONFIRMADA) {
                    try {
                        cita.cambiarEstado(EstadoCita.EN_ATENCION, autorId.toString())
                        citaRepository.save(cita)
                    } catch (e: Exception) {
                        logger.warn("No se pudo cambiar estado de cita $cId: ${e.message}")
                    }
                }
            }
        }

        logger.info("[FICHA_SERVICE] Ficha estructurada guardada con ID: {}", ficha.id)
        return ficha.toResponse()
    }

    @Transactional
    fun actualizarFicha(fichaId: UUID, request: FichaUpdateRequest): FichaResponse {
        logger.debug("[FICHA_SERVICE] Actualizando ficha {}", fichaId)
        val ficha = fichaRepository.findById(fichaId)
            .orElseThrow { NotFoundException("Ficha cl√≠nica no encontrada") }

        // Mapeo selectivo (solo si vienen datos en el request)
        val updated = ficha.copy(
            anamnesis = request.anamnesis ?: ficha.anamnesis,
            hallazgosObjetivos = request.hallazgosObjetivos ?: ficha.hallazgosObjetivos,
            avaluoClinico = request.avaluoClinico ?: ficha.avaluoClinico,
            planTratamiento = request.planTratamiento ?: ficha.planTratamiento,
            pesoRegistrado = request.pesoRegistrado ?: ficha.pesoRegistrado,
            temperatura = request.temperatura ?: ficha.temperatura,
            frecuenciaCardiaca = request.frecuenciaCardiaca ?: ficha.frecuenciaCardiaca,
            frecuenciaRespiratoria = request.frecuenciaRespiratoria ?: ficha.frecuenciaRespiratoria,
            observaciones = request.observaciones ?: ficha.observaciones,
            fechaProximaVacuna = request.fechaProximaVacuna ?: ficha.fechaProximaVacuna,
            fechaProximoControl = request.fechaProximoControl ?: ficha.fechaProximoControl,
            fechaDesparasitacion = request.fechaDesparasitacion ?: ficha.fechaDesparasitacion,
            // Recalcular alerta si cambi√≥ temperatura
            alertaVeterinaria = (request.temperatura ?: ficha.temperatura)?.let { it > 39.5 } ?: ficha.alertaVeterinaria
        )

        // Actualizar peso en mascota si cambi√≥
        if (request.pesoRegistrado != null && request.pesoRegistrado > 0) {
            ficha.mascota.pesoActual = request.pesoRegistrado
        }

        return fichaRepository.save(updated).toResponse()
    }

    @Transactional(readOnly = true)
    fun obtenerHistorial(mascotaId: UUID, pageable: Pageable): Page<FichaResponse> {
        if (!mascotaRepository.existsById(mascotaId)) {
            throw NotFoundException("Mascota no encontrada con ID: $mascotaId")
        }
        return fichaRepository.findAllByMascotaIdOrderByFechaAtencionDesc(mascotaId, pageable)
            .map { it.toResponse() }
    }

    @Transactional(readOnly = true)
    fun obtenerHistorialPeso(mascotaId: UUID): PesoHistoryResponse {
        logger.debug("[FICHA_SERVICE] Obteniendo historial de peso para mascota {}", mascotaId)
        val fichas = fichaRepository.findAllByMascotaIdOrderByFechaAtencionAsc(mascotaId)
        
        val puntos = fichas
            .filter { it.pesoRegistrado != null }
            .map { PesoPunto(it.fechaAtencion, it.pesoRegistrado!!) }

        return PesoHistoryResponse(mascotaId, puntos)
    }

    @Transactional(readOnly = true)
    fun obtenerFichaPorCita(citaId: UUID): FichaResponse {
        val ficha = fichaRepository.findByCitaId(citaId)
            ?: throw NotFoundException("No hay ficha cl√≠nica asociada a la cita $citaId")
        return ficha.toResponse()
    }
}
</file>

<file path="src/main/resources/application-prod.properties">
spring.datasource.url=jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_NAME}
spring.datasource.username=${DB_USER}
spring.datasource.password=${DB_PASSWORD}

spring.jpa.hibernate.ddl-auto=update
logging.level.root=INFO
logging.level.cl.clinipets=INFO
</file>

<file path="src/test/kotlin/cl/clinipets/backend/agendamiento/api/ReservaDtosTest.kt">
package cl.clinipets.backend.agendamiento.api

import cl.clinipets.agendamiento.api.*
import cl.clinipets.agendamiento.domain.Cita
import cl.clinipets.agendamiento.domain.DetalleCita
import cl.clinipets.agendamiento.domain.EstadoCita
import cl.clinipets.agendamiento.domain.OrigenCita
import cl.clinipets.servicios.domain.ServicioMedico
import cl.clinipets.veterinaria.domain.Mascota
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test
import org.mockito.Mockito.mock
import org.mockito.Mockito.`when`
import java.time.Instant
import java.time.temporal.ChronoUnit
import java.util.*

class ReservaDtosTest {

    @Test
    fun `ReservaCreateRequest should be correctly instantiated`() {
        val servicioId = UUID.randomUUID()
        val mascotaId = UUID.randomUUID()
        val itemReserva = ReservaItemRequest(mascotaId, servicioId)
        
        val fechaHoraInicio = Instant.now()
        val origen = OrigenCita.WEB

        val request = ReservaCreateRequest(
            detalles = listOf(itemReserva),
            fechaHoraInicio = fechaHoraInicio,
            origen = origen
        )

        assertEquals(1, request.detalles.size)
        assertEquals(mascotaId, request.detalles[0].mascotaId)
        assertEquals(servicioId, request.detalles[0].servicioId)
        assertEquals(fechaHoraInicio, request.fechaHoraInicio)
        assertEquals(origen, request.origen)
    }

    @Test
    fun `CitaResponse should be correctly instantiated`() {
        val id = UUID.randomUUID()
        val fechaHoraInicio = Instant.now()
        val fechaHoraFin = fechaHoraInicio.plus(1, ChronoUnit.HOURS)
        val estado = EstadoCita.CONFIRMADA
        val precioFinal = 10000
        val tutorId = UUID.randomUUID()
        val origen = OrigenCita.WEB
        
        val detalleResponse = DetalleCitaResponse(
            id = UUID.randomUUID(),
            servicioId = UUID.randomUUID(),
            nombreServicio = "Servicio Test",
            mascotaId = UUID.randomUUID(),
            nombreMascota = "Mascota Test",
            precioUnitario = 5000
        )

        val response = CitaResponse(
            id = id,
            fechaHoraInicio = fechaHoraInicio,
            fechaHoraFin = fechaHoraFin,
            estado = estado,
            precioFinal = precioFinal,
            saldoPendiente = precioFinal,
            detalles = listOf(detalleResponse),
            tutorId = tutorId,
            origen = origen,
            tipoAtencion = cl.clinipets.agendamiento.domain.TipoAtencion.CLINICA,
            motivoConsulta = null,
            direccion = null
        )

        assertEquals(id, response.id)
        assertEquals(fechaHoraInicio, response.fechaHoraInicio)
        assertEquals(fechaHoraFin, response.fechaHoraFin)
        assertEquals(estado, response.estado)
        assertEquals(precioFinal, response.precioFinal)
        assertEquals(1, response.detalles.size)
        assertEquals("Servicio Test", response.detalles[0].nombreServicio)
        assertEquals(tutorId, response.tutorId)
        assertEquals(origen, response.origen)
    }

    @Test
    fun `Cita toResponse should map correctly`() {
        // Setup Mocks
        val servicioMock = mock(ServicioMedico::class.java)
        `when`(servicioMock.id).thenReturn(UUID.randomUUID())
        `when`(servicioMock.nombre).thenReturn("Consulta")
        
        val mascotaMock = mock(Mascota::class.java)
        `when`(mascotaMock.id).thenReturn(UUID.randomUUID())
        `when`(mascotaMock.nombre).thenReturn("Firulais")

        val citaId = UUID.randomUUID()
        val fechaHoraInicio = Instant.now()
        val fechaHoraFin = fechaHoraInicio.plus(1, ChronoUnit.HOURS)
        val estado = EstadoCita.CONFIRMADA
        val precioFinal = 15000
        val tutorId = UUID.randomUUID()
        val origen = OrigenCita.APP

        // Create Cita
        val cita = Cita(
            id = citaId,
            fechaHoraInicio = fechaHoraInicio,
            fechaHoraFin = fechaHoraFin,
            estado = estado,
            precioFinal = precioFinal,
            tutorId = tutorId,
            origen = origen
        )
        
        // Create Detalle linked to Cita
        val detalle = DetalleCita(
            id = UUID.randomUUID(),
            cita = cita,
            servicio = servicioMock,
            mascota = mascotaMock,
            precioUnitario = 15000
        )
        cita.detalles.add(detalle)

        val response = cita.toResponse()

        assertEquals(citaId, response.id)
        assertEquals(fechaHoraInicio, response.fechaHoraInicio)
        assertEquals(fechaHoraFin, response.fechaHoraFin)
        assertEquals(estado, response.estado)
        assertEquals(precioFinal, response.precioFinal)
        assertEquals(1, response.detalles.size)
        assertEquals(servicioMock.id, response.detalles[0].servicioId)
        assertEquals(mascotaMock.id, response.detalles[0].mascotaId)
        assertEquals(tutorId, response.tutorId)
        assertEquals(origen, response.origen)
    }
}
</file>

<file path="src/test/kotlin/cl/clinipets/backend/agendamiento/application/ReservaServiceTest.kt">
package cl.clinipets.backend.agendamiento.application

import cl.clinipets.agendamiento.api.ReservaItemRequest
import cl.clinipets.agendamiento.api.FinalizarCitaRequest
import cl.clinipets.agendamiento.application.ReservaService
import cl.clinipets.agendamiento.domain.CitaRepository
import cl.clinipets.agendamiento.domain.EstadoCita
import cl.clinipets.agendamiento.domain.OrigenCita
import cl.clinipets.servicios.application.InventarioService
import cl.clinipets.servicios.domain.ReglaPrecio
import cl.clinipets.servicios.domain.ServicioMedico
import cl.clinipets.servicios.domain.ServicioMedicoRepository
import cl.clinipets.veterinaria.domain.Especie
import cl.clinipets.veterinaria.domain.Mascota
import cl.clinipets.veterinaria.domain.MascotaRepository
import cl.clinipets.veterinaria.domain.Sexo
import cl.clinipets.core.security.JwtPayload
import cl.clinipets.core.storage.StorageService
import cl.clinipets.core.web.BadRequestException
import cl.clinipets.identity.domain.User
import cl.clinipets.identity.domain.UserRepository
import cl.clinipets.identity.domain.UserRole
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertThrows
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.boot.test.mock.mockito.MockBean
import org.springframework.test.context.TestPropertySource
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId
import java.time.temporal.ChronoUnit

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.NONE)
@TestPropertySource(
    properties = [
        "spring.jpa.hibernate.ddl-auto=create-drop",
        "jwt.secret=Y29udGFzZWNvbXNlY3JldG9iZGVDbGluSXBldHMxMjM0NTY3OA==",
        "jwt.refresh-secret=cmVmcmVzaFNlY3JldG9iZGVDbGluSXBldHMxMjM0NTY3OA==",
        "jwt.issuer=TestIssuer",
        "google.client-id=test-google"
    ]
)
class ReservaServiceTest(
    @Autowired private val reservaService: ReservaService,
    @Autowired private val userRepository: UserRepository,
    @Autowired private val mascotaRepository: MascotaRepository,
    @Autowired private val servicioMedicoRepository: ServicioMedicoRepository,
    @Autowired private val citaRepository: CitaRepository,
    @Autowired private val inventarioService: InventarioService
) {
    @MockBean
    private lateinit var storageService: StorageService

    private lateinit var tutorPayload: JwtPayload
    private lateinit var staffPayload: JwtPayload
    private lateinit var servicio: ServicioMedico
    private lateinit var mascota: Mascota

    @BeforeEach
    fun setup() {
        citaRepository.deleteAll()
        servicioMedicoRepository.deleteAll()
        mascotaRepository.deleteAll()
        userRepository.deleteAll()

        val tutor = userRepository.save(
            User(
                email = "tutor@test.com",
                name = "Tutor",
                passwordHash = "pw",
                role = UserRole.CLIENT
            )
        )
        tutorPayload = JwtPayload(
            userId = tutor.id!!,
            email = tutor.email,
            role = tutor.role,
            expiresAt = Instant.now()
        )

        val staff = userRepository.save(
            User(
                email = "staff@test.com",
                name = "Staff",
                passwordHash = "pw",
                role = UserRole.STAFF
            )
        )
        staffPayload = JwtPayload(
            userId = staff.id!!,
            email = staff.email,
            role = staff.role,
            expiresAt = Instant.now()
        )

        servicio = servicioMedicoRepository.save(
            ServicioMedico(
                nombre = "Esterilizaci√≥n Canina",
                precioBase = 30000,
                requierePeso = true,
                duracionMinutos = 60,
                activo = true,
                reglas = mutableSetOf(),
                stock = 10 // Default stock
            )
        )
        val regla = ReglaPrecio(
            pesoMin = 0.0,
            pesoMax = 10.0,
            precio = 30000,
            servicio = servicio
        )
        servicio.reglas.add(regla)
        servicio = servicioMedicoRepository.save(servicio)

        mascota = mascotaRepository.save(
            Mascota(
                nombre = "Firulais",
                especie = Especie.PERRO,
                raza = "Mestizo",
                sexo = Sexo.MACHO,
                pesoActual = 8.5,
                // Usamos LocalDate para fecha de nacimiento
                fechaNacimiento = LocalDate.of(2022, 5, 10),
                tutor = tutor
            )
        )
    }

    @Test
    fun `crear reserva genera cita confirmada`() {
        // Buscamos siguiente sabado
        val fechaSabado = siguienteSabadoAMas(LocalDate.now())
        // Convertimos a Instant a las 11:00 (HorarioClinica abre Sabado a las 10:00, cierra 19:00. 11:00 es v√°lido)
        val inicio = fechaSabado.atTime(11, 0).atZone(ZoneId.systemDefault()).toInstant()
        
        val result = reservaService.crearReserva(
            detalles = listOf(
                ReservaItemRequest(
                    mascotaId = mascota.id!!,
                    servicioId = servicio.id!!
                )
            ),
            fechaHoraInicio = inicio,
            origen = OrigenCita.APP,
            tutor = tutorPayload
        )
        
        // Cita properties checks
        assertEquals(tutorPayload.userId, result.cita.tutorId)
        assertEquals(30000, result.cita.precioFinal)
        assertEquals(EstadoCita.CONFIRMADA, result.cita.estado)
        
        // Detalles checks
        assertEquals(1, result.cita.detalles.size)
        assertEquals(servicio.id, result.cita.detalles[0].servicio.id)
        assertEquals(mascota.id, result.cita.detalles[0].mascota?.id)
    }

    @Test
    fun `crear reserva falla si no hay stock suficiente`() {
        // Configurar servicio sin stock
        servicio.stock = 0
        servicioMedicoRepository.save(servicio)

        val inicio = siguienteSabadoAMas(LocalDate.now())
            .atTime(11, 0)
            .atZone(ZoneId.systemDefault())
            .toInstant()

        assertThrows(BadRequestException::class.java) {
            reservaService.crearReserva(
                detalles = listOf(
                    ReservaItemRequest(
                        mascotaId = mascota.id!!,
                        servicioId = servicio.id!!
                    )
                ),
                fechaHoraInicio = inicio,
                origen = OrigenCita.APP,
                tutor = tutorPayload
            )
        }
    }

    @Test
    fun `no permite reservar slot parcialmente ocupado`() {
        val fechaSabado = siguienteSabadoAMas(LocalDate.now())
        // 11:00
        val inicio1 = fechaSabado.atTime(11, 0).atZone(ZoneId.systemDefault()).toInstant()
        
        // Crear cita 1 (60 min)
        reservaService.crearReserva(
            detalles = listOf(ReservaItemRequest(mascota.id!!, servicio.id!!)), // servicio dura 60 min
            fechaHoraInicio = inicio1,
            origen = OrigenCita.APP,
            tutor = tutorPayload
        )
        
        // Intentar crear cita 2 a las 11:30 (30 min dentro de la cita 1)
        val inicio2 = fechaSabado.atTime(11, 30).atZone(ZoneId.systemDefault()).toInstant()
        
        assertThrows(BadRequestException::class.java) {
            reservaService.crearReserva(
                detalles = listOf(ReservaItemRequest(mascota.id!!, servicio.id!!)),
                fechaHoraInicio = inicio2,
                origen = OrigenCita.APP,
                tutor = tutorPayload
            )
        }
    }

    @Test
    fun `devuelve stock si falla finalizacion`() {
        // Setup: Servicio con 2 unidades de stock
        servicio.stock = 2
        servicioMedicoRepository.save(servicio)
        
        val fechaSabado = siguienteSabadoAMas(LocalDate.now())
        val inicio1 = fechaSabado.atTime(11, 0).atZone(ZoneId.systemDefault()).toInstant()
        val inicio2 = fechaSabado.atTime(12, 0).atZone(ZoneId.systemDefault()).toInstant()

        // Crear 2 citas
        val cita1Result = reservaService.crearReserva(
            detalles = listOf(ReservaItemRequest(mascota.id!!, servicio.id!!)),
            fechaHoraInicio = inicio1,
            origen = OrigenCita.APP,
            tutor = tutorPayload
        )
        val cita2Result = reservaService.crearReserva(
            detalles = listOf(ReservaItemRequest(mascota.id!!, servicio.id!!)),
            fechaHoraInicio = inicio2,
            origen = OrigenCita.APP,
            tutor = tutorPayload
        )
        
        val cita1 = cita1Result.cita
        val cita2 = cita2Result.cita
        
        // Cambiar estados a EN_ATENCION para poder finalizar (si se requiere)
        cita1.cambiarEstado(EstadoCita.EN_ATENCION, "test")
        citaRepository.save(cita1)
        cita2.cambiarEstado(EstadoCita.EN_ATENCION, "test")
        citaRepository.save(cita2)

        // Finalizar cita 1 ‚Üí Stock deber√≠a bajar a 1
        reservaService.finalizarCita(cita1.id!!, FinalizarCitaRequest(cl.clinipets.agendamiento.domain.MetodoPago.EFECTIVO, null), staffPayload)
        
        assertEquals(1, servicioMedicoRepository.findById(servicio.id!!).get().stock)
        
        // Consumir manualmente el √∫ltimo stock (simular concurrencia o venta externa)
        inventarioService.consumirStock(servicio.id!!, 1, "test-concurrente")
        assertEquals(0, servicioMedicoRepository.findById(servicio.id!!).get().stock)
        
        // Intentar finalizar cita 2 ‚Üí Debe fallar por falta de stock
        assertThrows(BadRequestException::class.java) {
            reservaService.finalizarCita(cita2.id!!, FinalizarCitaRequest(cl.clinipets.agendamiento.domain.MetodoPago.EFECTIVO, null), staffPayload)
        }
        
        // Verificar que cita2 qued√≥ CANCELADA
        val cita2After = citaRepository.findById(cita2.id!!).get()
        assertEquals(EstadoCita.CANCELADA, cita2After.estado)
    }

    private fun siguienteSabadoAMas(hoy: LocalDate): LocalDate {
        var fecha = hoy
        while (fecha.dayOfWeek.value != 6) { // 6 is Saturday
            fecha = fecha.plusDays(1)
        }
        return fecha
    }
}
</file>

<file path="src/test/kotlin/cl/clinipets/backend/veterinaria/application/MascotaServiceTest.kt">
package cl.clinipets.backend.veterinaria.application

import cl.clinipets.veterinaria.api.MascotaCreateRequest
import cl.clinipets.veterinaria.domain.Especie
import cl.clinipets.veterinaria.domain.Sexo
import cl.clinipets.agendamiento.domain.CitaRepository
import cl.clinipets.veterinaria.domain.MascotaRepository
import cl.clinipets.core.security.JwtPayload
import cl.clinipets.identity.domain.User
import cl.clinipets.identity.domain.UserRepository
import cl.clinipets.identity.domain.UserRole
import cl.clinipets.veterinaria.application.MascotaService
import cl.clinipets.core.storage.StorageService
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.boot.test.mock.mockito.MockBean
import org.springframework.test.context.TestPropertySource
import java.math.BigDecimal
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.NONE)
@TestPropertySource(
    properties = [
        "spring.jpa.hibernate.ddl-auto=create-drop",
        "jwt.secret=Y29udGFzZWNvbXNlY3JldG9iZGVDbGluSXBldHMxMjM0NTY3OA==",
        "jwt.refresh-secret=cmVmcmVzaFNlY3JldG9iZGVDbGluSXBldHMxMjM0NTY3OA==",
        "jwt.issuer=TestIssuer",
        "google.client-id=test-google"
    ]
)
class MascotaServiceTest(
    @Autowired private val mascotaService: MascotaService,
    @Autowired private val userRepository: UserRepository,
    @Autowired private val mascotaRepository: MascotaRepository,
    @Autowired private val citaRepository: CitaRepository
) {
    @MockBean
    private lateinit var storageService: StorageService

    private lateinit var tutorPayload: JwtPayload
    private lateinit var otroPayload: JwtPayload

    @BeforeEach
    fun setup() {
        citaRepository.deleteAll()
        mascotaRepository.deleteAll()
        userRepository.deleteAll()

        val tutor = userRepository.save(
            User(
                email = "tutor@test.com",
                name = "Tutor",
                passwordHash = "pw",
                role = UserRole.CLIENT
            )
        )
        val otro = userRepository.save(
            User(
                email = "otro@test.com",
                name = "Otro",
                passwordHash = "pw",
                role = UserRole.CLIENT
            )
        )
        tutorPayload = JwtPayload(
            userId = tutor.id!!,
            email = tutor.email,
            role = tutor.role,
            expiresAt = Instant.now()
        )
        otroPayload = JwtPayload(
            userId = otro.id!!,
            email = otro.email,
            role = otro.role,
            expiresAt = Instant.now()
        )
    }

    @Test
    fun `crear y obtener mascota del tutor`() {
        val creada = mascotaService.crear(
            MascotaCreateRequest(
                nombre = "Firulais",
                especie = Especie.PERRO,
                raza = "Mestizo",
                sexo = Sexo.MACHO,
                pesoActual = 8.5,
                fechaNacimiento = LocalDate.of(2022, 5, 10)
            ),
            tutorPayload
        )
        assertEquals("Firulais", creada.nombre)
        assertEquals(tutorPayload.userId, creada.tutorId)

        val listadas = mascotaService.listar(tutorPayload)
        assertEquals(1, listadas.size)
        assertEquals(creada.id, listadas.first().id)
    }

    @Test
    fun `otro usuario no puede acceder mascota ajena`() {
        mascotaService.crear(
            MascotaCreateRequest(
                nombre = "Michi",
                especie = Especie.GATO,
                raza = "Mestizo",
                sexo = Sexo.HEMBRA,
                pesoActual = 4.2,
                fechaNacimiento = LocalDate.of(2023, 3, 15)
            ),
            tutorPayload
        )
        val listadasPorOtro = mascotaService.listar(otroPayload)
        assertEquals(0, listadasPorOtro.size)
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/application/InventarioService.kt">
package cl.clinipets.servicios.application

import cl.clinipets.core.web.ConflictException
import cl.clinipets.core.web.NotFoundException
import cl.clinipets.servicios.domain.InsumoRepository
import cl.clinipets.servicios.domain.ServicioMedico
import cl.clinipets.servicios.domain.ServicioMedicoRepository
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.util.*

@Service
class InventarioService(
    private val servicioMedicoRepository: ServicioMedicoRepository,
    private val insumoRepository: InsumoRepository
) {
    private val logger = LoggerFactory.getLogger(InventarioService::class.java)

    /**
     * Valida si hay stock disponible para un servicio sin realizar ninguna operaci√≥n de escritura.
     * @return true si hay stock suficiente, false en caso contrario
     */
    @Transactional(readOnly = true)
    fun validarDisponibilidadStock(servicioId: UUID, cantidad: Int): Boolean {
        val servicio = servicioMedicoRepository.findById(servicioId)
            .orElseThrow { NotFoundException("Servicio no encontrado: $servicioId") }

        logger.info("[INVENTARIO] Validando stock para ${servicio.nombre}")

        // 1. Validar stock directo del servicio
        if (servicio.stock != null) {
            if (servicio.stock!! < cantidad) {
                logger.warn(
                    "[INVENTARIO] Stock insuficiente: requiere $cantidad, disponible ${servicio.stock}"
                )
                return false
            }
        }

        // 2. Validar insumos cr√≠ticos
        servicio.insumos.forEach { si ->
            val totalRequerido = si.cantidadRequerida * cantidad
            val insumo = insumoRepository.findById(si.insumo.id!!)
                .orElse(null) ?: return false

            if (insumo.stockActual < totalRequerido) {
                if (si.critico) {
                    logger.warn(
                        "[INVENTARIO] Stock insuficiente: ${insumo.nombre} requiere $totalRequerido, disponible ${insumo.stockActual}"
                    )
                    return false
                } else {
                    logger.warn(
                        "[INVENTARIO] Insumo no cr√≠tico ${insumo.nombre} sin stock suficiente (requiere $totalRequerido, disponible ${insumo.stockActual})"
                    )
                }
            }
        }

        return true
    }

    /**
     * Consume stock de un servicio y sus insumos asociados con locks pesimistas.
     * @throws ConflictException si falta stock cr√≠tico
     */
    @Transactional
    fun consumirStock(servicioId: UUID, cantidad: Int = 1, referencia: String) {
        val servicio = servicioMedicoRepository.findById(servicioId)
            .orElseThrow { NotFoundException("Servicio no encontrado: $servicioId") }

        logger.info(
            "[INVENTARIO] Consumiendo stock e insumos. Servicio: ${servicio.nombre}, Cantidad: $cantidad, Referencia: $referencia"
        )

        // 1. Consumir stock directo del servicio (ej: si es un producto f√≠sico)
        if (servicio.stock != null) {
            if (servicio.stock!! < cantidad) {
                logger.warn(
                    "[INVENTARIO] Stock insuficiente: requiere $cantidad, disponible ${servicio.stock}"
                )
                throw ConflictException("No hay stock suficiente para ${servicio.nombre}")
            }
            servicio.stock = servicio.stock!! - cantidad
            servicioMedicoRepository.save(servicio)
            logger.debug("[INVENTARIO] Stock del servicio ${servicio.nombre} consumido: -$cantidad")
        }

        // 2. Consumir insumos asociados con PESSIMISTIC LOCK
        servicio.insumos.forEach { si ->
            val totalRequerido = si.cantidadRequerida * cantidad

            // Bloqueamos la fila del insumo para actualizaci√≥n segura
            val insumo = insumoRepository.findByIdWithLock(si.insumo.id!!)
                ?: throw NotFoundException("Insumo no encontrado: ${si.insumo.nombre}")

            if (insumo.stockActual < totalRequerido) {
                if (si.critico) {
                    logger.warn(
                        "[INVENTARIO] Stock insuficiente del insumo cr√≠tico ${insumo.nombre}: requiere $totalRequerido, disponible ${insumo.stockActual}"
                    )
                    throw ConflictException("No hay stock suficiente del insumo cr√≠tico: ${insumo.nombre}")
                } else {
                    logger.warn(
                        "[INVENTARIO] Insumo no cr√≠tico ${insumo.nombre} sin stock suficiente, continuando sin consumir"
                    )
                }
            } else {
                insumo.stockActual -= totalRequerido
                insumoRepository.save(insumo)
                logger.debug("[INVENTARIO] Insumo ${insumo.nombre} consumido: -$totalRequerido")
            }
        }
    }

    @Transactional
    fun devolverStock(servicio: ServicioMedico, cantidad: Int = 1) {
        val servicioFresco = servicioMedicoRepository.findById(servicio.id!!)
            .orElse(null) ?: return

        if (servicioFresco.stock != null) {
            servicioFresco.stock = servicioFresco.stock!! + cantidad
            servicioMedicoRepository.save(servicioFresco)
        }

        servicioFresco.insumos.forEach { si ->
            val insumo = insumoRepository.findByIdWithLock(si.insumo.id!!)
                ?: return@forEach
            insumo.stockActual += si.cantidadRequerida * cantidad
            insumoRepository.save(insumo)
        }
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/application/MascotaService.kt">
package cl.clinipets.veterinaria.application

import cl.clinipets.veterinaria.api.MascotaClinicalUpdateRequest
import cl.clinipets.veterinaria.api.MascotaCreateRequest
import cl.clinipets.veterinaria.api.MascotaResponse
import cl.clinipets.veterinaria.api.MascotaUpdateRequest
import cl.clinipets.veterinaria.api.PasaporteSaludResponse
import cl.clinipets.veterinaria.api.toDto
import cl.clinipets.veterinaria.api.toItemResponse
import cl.clinipets.veterinaria.api.toResponse
import cl.clinipets.veterinaria.domain.Mascota
import cl.clinipets.veterinaria.domain.MascotaRepository
import cl.clinipets.veterinaria.domain.PlanPreventivoRepository
import cl.clinipets.core.security.JwtPayload
import cl.clinipets.core.web.NotFoundException
import cl.clinipets.core.web.UnauthorizedException
import cl.clinipets.identity.domain.UserRepository
import cl.clinipets.identity.domain.UserRole
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.math.BigDecimal
import java.time.LocalDate
import java.util.UUID

@Service
class MascotaService(
    private val mascotaRepository: MascotaRepository,
    private val userRepository: UserRepository,
    private val planPreventivoRepository: PlanPreventivoRepository,
    private val signosVitalesRepository: cl.clinipets.veterinaria.domain.SignosVitalesRepository
) {
    private val logger = LoggerFactory.getLogger(MascotaService::class.java)

    @Transactional(readOnly = true)
    fun consultarHistorialVitals(
        mascotaId: UUID,
        user: JwtPayload
    ): List<cl.clinipets.veterinaria.api.SignosVitalesDto> {
        findMascotaDeTutor(mascotaId, user)
        return signosVitalesRepository.findAllByMascotaIdOrderByFechaDesc(mascotaId)
            .map { it.toDto() }
    }

    @Transactional(readOnly = true)
    fun consultarPasaporteSalud(mascotaId: UUID, user: JwtPayload): PasaporteSaludResponse {
        val mascota = findMascotaDeTutor(mascotaId, user)
        val preventivos = planPreventivoRepository.findAllByMascotaIdOrderByFechaAplicacionDesc(mascotaId)

        return PasaporteSaludResponse(
            mascotaId = mascota.id!!,
            nombreMascota = mascota.nombre,
            especie = mascota.especie,
            preventivos = preventivos.map { it.toItemResponse() }
        )
    }

    @Transactional
    fun crear(request: MascotaCreateRequest, tutor: JwtPayload): MascotaResponse {
        logger.debug("[MASCOTA_SERVICE] Creando mascota: {} para tutor: {}", request.nombre, tutor.email)
        val user = userRepository.findById(tutor.userId)
            .orElseThrow { NotFoundException("Tutor no encontrado") }
        val mascota = mascotaRepository.save(
            Mascota(
                nombre = request.nombre,
                especie = request.especie,
                raza = request.raza,
                sexo = request.sexo,
                esterilizado = request.esterilizado,
                chipIdentificador = request.chipIdentificador,
                temperamento = request.temperamento,
                // Valores por defecto para permitir registro flexible
                pesoActual = request.pesoActual ?: -1.0,
                fechaNacimiento = request.fechaNacimiento ?: LocalDate.of(1900, 1, 1),
                tutor = user
            )
        )
        logger.info("[MASCOTA_SERVICE] Mascota creada exitosamente con ID: {}", mascota.id)
        return mascota.toResponse()
    }

    @Transactional(readOnly = true)
    fun listar(tutor: JwtPayload): List<MascotaResponse> =
        mascotaRepository.findAllByTutorId(tutor.userId).map { it.toResponse() }

    @Transactional(readOnly = true)
    fun obtener(id: UUID, tutor: JwtPayload): MascotaResponse =
        findMascotaDeTutor(id, tutor).toResponse()

    @Transactional
    fun actualizar(id: UUID, request: MascotaUpdateRequest, tutor: JwtPayload): MascotaResponse {
        logger.debug("[MASCOTA_SERVICE] Actualizando mascota ID: {}", id)
        val mascota = findMascotaDeTutor(id, tutor)
        mascota.nombre = request.nombre
        mascota.pesoActual = request.pesoActual
        
        request.raza?.let { mascota.raza = it }
        request.sexo?.let { mascota.sexo = it }
        request.esterilizado?.let { mascota.esterilizado = it }
        request.chipIdentificador?.let { mascota.chipIdentificador = it }
        request.temperamento?.let { mascota.temperamento = it }
        
        val updated = mascotaRepository.save(mascota)
        logger.info("[MASCOTA_SERVICE] Mascota actualizada exitosamente")
        return updated.toResponse()
    }

    @Transactional
    fun actualizarDatosClinicos(id: UUID, request: MascotaClinicalUpdateRequest): MascotaResponse {
        logger.info("[MASCOTA_CLINICO] Actualizando datos cl√≠nicos mascota ID: {}", id)

        // No pasamos JwtPayload porque asumimos que la autorizaci√≥n ya fue validada en el Controller (Role STAFF/ADMIN)
        // y este m√©todo es de uso interno para la cl√≠nica.
        val mascota = mascotaRepository.findById(id)
            .orElseThrow { NotFoundException("Mascota no encontrada") }

        request.pesoActual?.let { mascota.pesoActual = it }
        request.esterilizado?.let { mascota.esterilizado = it }

        request.testRetroviralNegativo?.let {
            mascota.testRetroviralNegativo = it
            if (it) {
                mascota.fechaUltimoTestRetroviral = LocalDate.now()
            }
        }

        request.observaciones?.let { mascota.observacionesClinicas = it }

        val updated = mascotaRepository.save(mascota)
        logger.info("[MASCOTA_CLINICO] Datos cl√≠nicos actualizados exitosamente")
        return updated.toResponse()
    }

    @Transactional
    fun eliminar(id: UUID, tutor: JwtPayload) {
        logger.warn("[MASCOTA_SERVICE] Eliminando mascota ID: {}", id)
        val mascota = findMascotaDeTutor(id, tutor)
        mascotaRepository.delete(mascota)
        logger.info("[MASCOTA_SERVICE] Mascota eliminada")
    }

    private fun findMascotaDeTutor(id: UUID, requestingUser: JwtPayload): Mascota {
        val mascota = mascotaRepository.findById(id)
            .orElseThrow { NotFoundException("Mascota no encontrada") }
        
        val isOwner = mascota.tutor.id == requestingUser.userId
        val isStaffOrAdmin = requestingUser.role == UserRole.STAFF || requestingUser.role == UserRole.ADMIN

        if (!isOwner && !isStaffOrAdmin) {
            logger.warn("[MASCOTA_SERVICE] Acceso denegado a mascota {}. Usuario: {}", id, requestingUser.email)
            throw UnauthorizedException("No puedes acceder a esta mascota")
        }
        return mascota
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/api/ReservaDtos.kt">
package cl.clinipets.agendamiento.api

import cl.clinipets.agendamiento.domain.Cita
import cl.clinipets.agendamiento.domain.DetalleCita
import cl.clinipets.agendamiento.domain.EstadoCita
import cl.clinipets.agendamiento.domain.OrigenCita
import cl.clinipets.agendamiento.domain.TipoAtencion
import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.Valid
import jakarta.validation.constraints.Future
import jakarta.validation.constraints.NotEmpty
import jakarta.validation.constraints.NotNull
import java.time.Instant
import java.util.UUID

data class DetalleReservaRequest(
    @field:NotNull
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "ID del servicio m√©dico o producto")
    val servicioId: UUID,

    @field:Schema(description = "ID de la mascota (opcional para productos)")
    val mascotaId: UUID? // Optional for products
)

data class ReservaItemRequest(
    @field:NotNull
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val mascotaId: UUID,

    @field:NotNull
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val servicioId: UUID,

    @field:Schema(description = "Cantidad del servicio (opcional, por defecto 1)")
    val cantidad: Int = 1
)

data class ReservaCreateRequest(
    @field:NotEmpty
    @field:Valid
    @field:Schema(
        requiredMode = Schema.RequiredMode.REQUIRED,
        description = "Lista de servicios para las mascotas"
    )
    val detalles: List<ReservaItemRequest>,

    @field:NotNull
    @field:Future
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "Fecha y hora de inicio de la cita")
    val fechaHoraInicio: Instant,

    @field:Schema(description = "Motivo de la consulta")
    val motivoConsulta: String? = null,

    @field:NotNull
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED, description = "Origen de la cita (APP, WEB, PRESENCIAL)")
    val origen: OrigenCita,

    @field:Schema(description = "Tipo de atenci√≥n (CLINICA, DOMICILIO)")
    val tipoAtencion: TipoAtencion = TipoAtencion.CLINICA,

    @field:Schema(description = "Direcci√≥n para atenci√≥n a domicilio")
    val direccion: String? = null,

    @field:Schema(description = "Indica si el pago es total o parcial (se√±a)")
    val pagoTotal: Boolean = false
)

data class DetalleCitaResponse(
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val id: UUID,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val servicioId: UUID,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val nombreServicio: String,
    val mascotaId: UUID?,
    val nombreMascota: String?,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val precioUnitario: Int
)

data class ResumenDiarioResponse(
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val totalCitas: Int,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val citasFinalizadas: Int,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val recaudacionTotalRealizada: Int,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val proyeccionPendiente: Int,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val desgloseMetodosPago: Map<cl.clinipets.agendamiento.domain.MetodoPago, Int>,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val totalGeneral: Int
)

data class CitaResponse(
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val id: UUID,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val fechaHoraInicio: Instant,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val fechaHoraFin: Instant,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val estado: EstadoCita,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val precioFinal: Int,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val saldoPendiente: Int,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val detalles: List<DetalleCitaResponse>,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val tutorId: UUID,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val origen: OrigenCita,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val tipoAtencion: TipoAtencion,
    val motivoConsulta: String?,
    val direccion: String?
)

data class CitaDetalladaResponse(
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val id: UUID,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val fechaHoraInicio: Instant,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val fechaHoraFin: Instant,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val estado: EstadoCita,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val precioFinal: Int,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val saldoPendiente: Int,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val detalles: List<DetalleCitaResponse>,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val tutorId: UUID,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val origen: OrigenCita,
    @field:Schema(requiredMode = Schema.RequiredMode.REQUIRED)
    val tipoAtencion: TipoAtencion,
    val motivoConsulta: String?,
    val direccion: String?
)

fun Cita.toResponse() = CitaResponse(
    id = id!!,
    fechaHoraInicio = fechaHoraInicio,
    fechaHoraFin = fechaHoraFin,
    estado = estado,
    precioFinal = precioFinal,
    saldoPendiente = if (estado == EstadoCita.FINALIZADA) 0 else precioFinal,
    detalles = detalles.map { it.toResponse() },
    tutorId = tutorId,
    origen = origen,
    tipoAtencion = tipoAtencion,
    motivoConsulta = motivoConsulta,
    direccion = direccion
)

fun Cita.toDetalladaResponse() = CitaDetalladaResponse(
    id = id!!,
    fechaHoraInicio = fechaHoraInicio,
    fechaHoraFin = fechaHoraFin,
    estado = estado,
    precioFinal = precioFinal,
    saldoPendiente = when (estado) {
        EstadoCita.FINALIZADA, EstadoCita.CANCELADA -> 0
        else -> precioFinal
    },
    detalles = detalles.map { it.toResponse() },
    tutorId = tutorId,
    origen = origen,
    tipoAtencion = tipoAtencion,
    motivoConsulta = motivoConsulta,
    direccion = direccion
)

fun DetalleCita.toResponse() = DetalleCitaResponse(
    id = id!!,
    servicioId = servicio.id!!,
    nombreServicio = servicio.nombre,
    mascotaId = mascota?.id,
    nombreMascota = mascota?.nombre,
    precioUnitario = precioUnitario
)
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/domain/Cita.kt">
package cl.clinipets.agendamiento.domain

import cl.clinipets.core.domain.AuditableEntity
import jakarta.persistence.*
import java.time.Instant
import java.util.UUID

enum class MetodoPago {
    EFECTIVO,
    TRANSFERENCIA,
    TARJETA_POS,
    MERCADO_PAGO_LINK
}

@Entity
@Table(name = "citas")
class Cita(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @Column(nullable = false)
    val fechaHoraInicio: Instant,

    @Column(nullable = false)
    val fechaHoraFin: Instant,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 32)
    var estado: EstadoCita,

    @Column(nullable = false)
    var precioFinal: Int,

    @OneToMany(mappedBy = "cita", cascade = [CascadeType.ALL], orphanRemoval = true, fetch = FetchType.EAGER)
    val detalles: MutableList<DetalleCita> = mutableListOf(),

    @Column(nullable = false)
    val tutorId: UUID,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 16)
    val origen: OrigenCita,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 16)
    val tipoAtencion: TipoAtencion = TipoAtencion.CLINICA,

    @Column(length = 500)
    val motivoConsulta: String? = null,

    @Column(length = 255)
    val direccion: String? = null,

    @Column(length = 50)
    var tokenCompensacion: String? = null,

    @Enumerated(EnumType.STRING)
    @Column(length = 20)
    var metodoPagoSaldo: MetodoPago? = null,

    @Column
    var staffFinalizadorId: UUID? = null
) : AuditableEntity() {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Cita) return false
        return id != null && id == other.id
    }

    override fun hashCode(): Int = id?.hashCode() ?: 0

    override fun toString(): String = "Cita(id=$id, inicio=$fechaHoraInicio, estado=$estado)"

    /**
     * Cambia el estado de la cita validando que la transici√≥n sea permitida
     * @param nuevoEstado Estado al que se desea cambiar
     * @param responsable Email del usuario que realiza el cambio (para auditor√≠a)
     */
    fun cambiarEstado(nuevoEstado: EstadoCita, responsable: String) {
        EstadoCitaTransiciones.validarTransicion(this.estado, nuevoEstado)
        val estadoAnterior = this.estado
        this.estado = nuevoEstado
        org.slf4j.LoggerFactory.getLogger(Cita::class.java)
            .info("[CITA] Estado cambiado: $estadoAnterior ‚Üí $nuevoEstado por $responsable (Cita ID: $id)")
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/config/DataSeeder.kt">
package cl.clinipets.core.config

import cl.clinipets.identity.domain.User
import cl.clinipets.identity.domain.UserRepository
import cl.clinipets.identity.domain.UserRole
import cl.clinipets.servicios.domain.*
import cl.clinipets.veterinaria.domain.Especie
import cl.clinipets.veterinaria.domain.Mascota
import cl.clinipets.veterinaria.domain.MascotaRepository
import cl.clinipets.veterinaria.domain.Sexo
import org.springframework.boot.ApplicationArguments
import org.springframework.boot.ApplicationRunner
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Component
import org.springframework.transaction.annotation.Transactional
import java.math.BigDecimal
import java.time.LocalDate

@Component
@Profile("!test")
class DataSeeder(
    private val servicioMedicoRepository: ServicioMedicoRepository,
    private val userRepository: UserRepository,
    private val mascotaRepository: MascotaRepository,
    private val promocionRepository: PromocionRepository
) : ApplicationRunner {
    @Transactional
    override fun run(args: ApplicationArguments?) {
        seedServices()
        seedPromociones()
        seedUsersAndPets()
        configurarReglasYDependencias()
    }

    private fun seedServices() {
        // --- CONSULTAS ---
        crearOActualizarServicio(
            nombre = "Consulta M√©dica Primaria",
            duracion = 30,
            categoria = CategoriaServicio.CONSULTA,
            precioBase = 8000,
            precioAbono = 4000
        )
        crearOActualizarServicio(
            nombre = "Corte de u√±as",
            duracion = 15,
            categoria = CategoriaServicio.CONSULTA,
            precioBase = 5000,
            precioAbono = 2500
        )

        // --- CHIP ---
        crearOActualizarServicio(
            nombre = "Implantaci√≥n Microchip",
            duracion = 15,
            categoria = CategoriaServicio.OTRO,
            precioBase = 15000,
            precioAbono = 5000,
            especies = mutableSetOf(Especie.PERRO, Especie.GATO)
        )

        // --- EXAMENES ---
        crearOActualizarServicio(
            nombre = "Test R√°pido Leucemia/VIF (Retroviral)",
            duracion = 15,
            categoria = CategoriaServicio.OTRO, // Mapeado a OTRO temporalmente si no existe EXAMEN en enum
            precioBase = 25000,
            precioAbono = 10000,
            especies = mutableSetOf(Especie.GATO)
        )

        // --- VACUNAS ---
        crearOActualizarServicio(
            nombre = "Vacuna Triple Felina",
            duracion = 15,
            categoria = CategoriaServicio.VACUNA,
            precioBase = 14000,
            precioAbono = 4000,
            especies = mutableSetOf(Especie.GATO)
        )
        crearOActualizarServicio(
            nombre = "Vacuna Leucemia Felina",
            duracion = 15,
            categoria = CategoriaServicio.VACUNA,
            precioBase = 14000,
            precioAbono = 4000,
            especies = mutableSetOf(Especie.GATO)
        )
        crearOActualizarServicio(
            nombre = "Vacuna S√©xtuple",
            duracion = 15,
            categoria = CategoriaServicio.VACUNA,
            precioBase = 12000,
            precioAbono = 4000,
            especies = mutableSetOf(Especie.PERRO)
        )
        crearOActualizarServicio(
            nombre = "Vacuna KC (Tos de las perreras)",
            duracion = 15,
            categoria = CategoriaServicio.VACUNA,
            precioBase = 14000,
            precioAbono = 4000,
            especies = mutableSetOf(Especie.PERRO)
        )
        crearOActualizarServicio(
            nombre = "Vacuna Antirr√°bica",
            duracion = 15,
            categoria = CategoriaServicio.VACUNA,
            precioBase = 12000,
            precioAbono = 4000,
            especies = mutableSetOf(Especie.PERRO, Especie.GATO)
        )

        // --- CIRUGIAS ---
        crearOActualizarServicio(
            nombre = "Esterilizaci√≥n Felina Macho",
            duracion = 60,
            categoria = CategoriaServicio.CIRUGIA,
            precioBase = 25000,
            precioAbono = 10000,
            especies = mutableSetOf(Especie.GATO)
        )
        crearOActualizarServicio(
            nombre = "Esterilizaci√≥n Felina Hembra",
            duracion = 90,
            categoria = CategoriaServicio.CIRUGIA,
            precioBase = 30000,
            precioAbono = 10000,
            especies = mutableSetOf(Especie.GATO)
        )

        // --- CIRUGIA COMPLEJA CON REGLAS DE PESO ---
        seedEsterilizacionCanina()
    }

    private fun configurarReglasYDependencias() {
        val servicios = servicioMedicoRepository.findAll()
        val mapServicios = servicios.associateBy { it.nombre.lowercase() }

        // 1. Configurar dependencia de Vacuna Leucemia -> Test Retroviral
        val vacunaLeucemia = mapServicios["vacuna leucemia felina"]
        val testRetroviral = mapServicios["test r√°pido leucemia/vif (retroviral)"]

        if (vacunaLeucemia != null && testRetroviral != null) {
            if (!vacunaLeucemia.serviciosRequeridosIds.contains(testRetroviral.id!!)) {
                vacunaLeucemia.serviciosRequeridosIds.add(testRetroviral.id!!)
                servicioMedicoRepository.save(vacunaLeucemia)
            }
        }

        // 2. Configurar bloqueadoSiEsterilizado
        val serviciosEsterilizacion = listOf(
            "esterilizaci√≥n canina",
            "esterilizaci√≥n felina macho",
            "esterilizaci√≥n felina hembra"
        )

        serviciosEsterilizacion.forEach { nombre ->
            mapServicios[nombre]?.let {
                if (!it.bloqueadoSiEsterilizado) {
                    it.bloqueadoSiEsterilizado = true
                    servicioMedicoRepository.save(it)
                }
            }
        }
    }

    private fun seedEsterilizacionCanina() {
        val nombre = "Esterilizaci√≥n Canina"
        val existente = servicioMedicoRepository.findAll().find { it.nombre.equals(nombre, ignoreCase = true) }

        if (existente == null) {
            val servicio = ServicioMedico(
                nombre = nombre,
                precioBase = 30000, // Precio base (0-10kg)
                precioAbono = 10000,
                requierePeso = true,
                duracionMinutos = 90,
                activo = true,
                categoria = CategoriaServicio.CIRUGIA,
                especiesPermitidas = mutableSetOf(Especie.PERRO)
            )

            servicio.reglas.addAll(
                listOf(
                    ReglaPrecio(
                        servicio = servicio,
                        pesoMin = 0.0,
                        pesoMax = 10.0,
                        precio = 30000
                    ),
                    ReglaPrecio(
                        servicio = servicio,
                        pesoMin = 10.1,
                        pesoMax = 15.0,
                        precio = 34000
                    ),
                    ReglaPrecio(
                        servicio = servicio,
                        pesoMin = 15.1,
                        pesoMax = 20.0,
                        precio = 38000
                    ),
                    ReglaPrecio(
                        servicio = servicio,
                        pesoMin = 20.1,
                        pesoMax = 25.0,
                        precio = 42000
                    ),
                    ReglaPrecio(
                        servicio = servicio,
                        pesoMin = 25.1,
                        pesoMax = 30.0,
                        precio = 46000
                    ),
                    ReglaPrecio(
                        servicio = servicio,
                        pesoMin = 30.1,
                        pesoMax = 35.0,
                        precio = 50000
                    ),
                    ReglaPrecio(
                        servicio = servicio,
                        pesoMin = 35.1,
                        pesoMax = 40.0,
                        precio = 54000
                    )
                )
            )
            servicioMedicoRepository.save(servicio)
        }
    }

    private fun seedPromociones() {
        val nombrePromo = "Pack Cirug√≠a + Microchip"

        // Verificar si ya existe para no duplicar
        val promos = promocionRepository.findAll()
        if (promos.any { it.nombre.equals(nombrePromo, ignoreCase = true) }) return

        // Buscar servicios
        val servicios = servicioMedicoRepository.findAll()
        val cirugia = servicios.find { it.nombre.contains("Esterilizaci√≥n Canina", ignoreCase = true) }
        val chip = servicios.find { it.nombre.contains("Microchip", ignoreCase = true) }

        if (cirugia != null && chip != null) {
            val promocion = Promocion(
                nombre = nombrePromo,
                descripcion = "Descuento al agendar esterilizaci√≥n canina junto con implantaci√≥n de microchip fines de semana.",
                fechaInicio = LocalDate.now(),
                fechaFin = LocalDate.now().plusYears(1),
                diasPermitidos = "SAT,SUN",
                activa = true,
                serviciosTriggerIds = mutableSetOf(cirugia.id!!, chip.id!!)
            )

            promocion.beneficios.add(
                PromocionBeneficio(
                    servicioId = cirugia.id!!,
                    tipo = TipoDescuento.MONTO_OFF,
                    valor = BigDecimal(2000)
                )
            )
            promocion.beneficios.add(
                PromocionBeneficio(
                    servicioId = chip.id!!,
                    tipo = TipoDescuento.MONTO_OFF,
                    valor = BigDecimal(2000)
                )
            )

            promocionRepository.save(promocion)
        }
    }

    private fun crearOActualizarServicio(
        nombre: String,
        duracion: Int,
        categoria: CategoriaServicio,
        precioBase: Int,
        precioAbono: Int,
        requierePeso: Boolean = false,
        especies: MutableSet<Especie> = mutableSetOf(),
        stock: Int? = null
    ) {
        val existente = servicioMedicoRepository.findAll().find { it.nombre.equals(nombre, ignoreCase = true) }

        if (existente != null) {
            existente.duracionMinutos = duracion
            existente.categoria = categoria
            existente.precioBase = precioBase
            existente.precioAbono = precioAbono
            if (especies.isNotEmpty()) {
                existente.especiesPermitidas = especies
            }
            servicioMedicoRepository.save(existente)
        } else {
            val servicio = ServicioMedico(
                nombre = nombre,
                precioBase = precioBase,
                precioAbono = precioAbono,
                requierePeso = requierePeso,
                duracionMinutos = duracion,
                activo = true,
                categoria = categoria,
                especiesPermitidas = especies,
                stock = stock
            )
            // Regla por defecto para servicios simples
            if (requierePeso) {
                servicio.reglas.add(
                    ReglaPrecio(
                        pesoMin = 0.0,
                        pesoMax = 100.0,
                        precio = precioBase,
                        servicio = servicio
                    )
                )
            }
            servicioMedicoRepository.save(servicio)
        }
    }

    private fun seedUsersAndPets() {
        val phone = "56945272297"
        val email = "billymartinezc@gmail.com"

        var user = userRepository.findByPhone(phone)

        if (user == null) {
            user = User(
                name = "Billy Developer",
                email = email,
                phone = phone,
                passwordHash = "dev_password_hash",
                role = UserRole.ADMIN
            )
            user = userRepository.save(user)
        }

        val mascotas = mascotaRepository.findAllByTutorId(user!!.id!!)
        if (mascotas.isEmpty()) {
            val firulais = Mascota(
                nombre = "Firulais Test",
                especie = Especie.PERRO,
                raza = "Mestizo",
                sexo = Sexo.MACHO,
                pesoActual = 10.0,
                fechaNacimiento = LocalDate.now().minusYears(2),
                tutor = user,
                chipIdentificador = "TEST-CHIP-001"
            )
            mascotaRepository.save(firulais)
        }
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/security/SecurityConfig.kt">
package cl.clinipets.core.security

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
import org.springframework.security.config.http.SessionCreationPolicy
import org.springframework.security.web.SecurityFilterChain
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
class SecurityConfig(
    private val firebaseFilter: FirebaseFilter
) {
    @Bean
    fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http
            .csrf { it.disable() }
            .httpBasic { it.disable() }
            .formLogin { it.disable() }
            .sessionManagement { it.sessionCreationPolicy(SessionCreationPolicy.STATELESS) }
            .authorizeHttpRequests {
                it.requestMatchers(
                    "/",
                    "/api/public/**",
                    "/actuator/health",
                    "/index.html",
                    "/google-login.html",
                    "/privacy.html",
                    "/static/**",
                    "/v3/api-docs/**",
                    "/swagger-ui/**"
                ).permitAll()
                    // All /api/v1/auth endpoints require authentication (provided by FirebaseFilter)
                    .requestMatchers("/api/v1/reservas").authenticated()
                    .anyRequest().authenticated()
            }
            .addFilterBefore(firebaseFilter, UsernamePasswordAuthenticationFilter::class.java)
        return http.build()
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/domain/ServicioMedico.kt">
package cl.clinipets.servicios.domain

import cl.clinipets.core.domain.AuditableEntity
import cl.clinipets.veterinaria.domain.Especie
import cl.clinipets.veterinaria.domain.Mascota
import jakarta.persistence.*
import java.util.UUID

@Entity
@Table(name = "servicios_medicos")
class ServicioMedico(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @Version
    var version: Long? = null,

    @Column(nullable = false, unique = true)
    var nombre: String,

    @Column(nullable = false)
    var precioBase: Int,

    @Column(nullable = true)
    var precioAbono: Int? = null,

    @Column(nullable = false)
    var requierePeso: Boolean,

    @Column(nullable = false)
    var duracionMinutos: Int,

    @Column(nullable = false)
    var activo: Boolean = true,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    var categoria: CategoriaServicio = CategoriaServicio.OTRO,

    @ElementCollection(targetClass = Especie::class, fetch = FetchType.EAGER)
    @CollectionTable(name = "servicio_especies", joinColumns = [JoinColumn(name = "servicio_id")])
    @Enumerated(EnumType.STRING)
    @Column(name = "especie", nullable = false)
    var especiesPermitidas: MutableSet<Especie> = mutableSetOf(),

    @Column(nullable = true)
    var stock: Int? = null,

    @Column(nullable = false)
    var bloqueadoSiEsterilizado: Boolean = false,

    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "servicio_dependencias", joinColumns = [JoinColumn(name = "servicio_id")])
    @Column(name = "servicio_requerido_id")
    var serviciosRequeridosIds: MutableSet<UUID> = mutableSetOf(),

    @OneToMany(mappedBy = "servicio", cascade = [CascadeType.ALL], orphanRemoval = true, fetch = FetchType.EAGER)
    @org.hibernate.annotations.Fetch(org.hibernate.annotations.FetchMode.SUBSELECT)
    val reglas: MutableSet<ReglaPrecio> = mutableSetOf(),

    @OneToMany(mappedBy = "servicio", cascade = [CascadeType.ALL], orphanRemoval = true, fetch = FetchType.EAGER)
    @org.hibernate.annotations.Fetch(org.hibernate.annotations.FetchMode.SUBSELECT)
    val insumos: MutableSet<ServicioInsumo> = mutableSetOf()
) : AuditableEntity() {
    fun calcularPrecioPara(mascota: Mascota): Int {
        if (!requierePeso) return precioBase
        val regla = reglas.firstOrNull {
            (mascota.pesoActual >= it.pesoMin) && (mascota.pesoActual <= it.pesoMax)
        }
        return regla?.precio ?: precioBase
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is ServicioMedico) return false
        return id != null && id == other.id
    }

    override fun hashCode(): Int = id?.hashCode() ?: 0

    override fun toString(): String = "ServicioMedico(id=$id, nombre='$nombre')"
}
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/api/ReservaController.kt">
package cl.clinipets.agendamiento.api

import cl.clinipets.agendamiento.application.ReservaService
import cl.clinipets.agendamiento.domain.MetodoPago
import cl.clinipets.core.security.JwtPayload
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import jakarta.validation.Valid
import org.slf4j.LoggerFactory
import org.springframework.format.annotation.DateTimeFormat
import org.springframework.http.ResponseEntity
import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.web.bind.annotation.*
import java.time.LocalDate
import java.util.UUID

data class SignosVitalesRequest(
    val peso: Double,
    val temperatura: Double,
    val frecuenciaCardiaca: String
)

data class FinalizarCitaRequest(
    val metodoPago: MetodoPago? = null,
    val signosVitales: Map<UUID, SignosVitalesRequest>? = null
)

@RestController
@RequestMapping("/api/v1/reservas")
class ReservaController(
    private val reservaService: ReservaService
) {
    private val logger = LoggerFactory.getLogger(ReservaController::class.java)

    @Operation(summary = "Obtener resumen financiero diario (Staff/Admin)", operationId = "obtenerResumenDiario")
    @ApiResponses(
        ApiResponse(responseCode = "200", description = "Resumen obtenido"),
        ApiResponse(responseCode = "403", description = "Sin permisos")
    )
    @PreAuthorize("hasAnyRole('STAFF', 'ADMIN')")
    @GetMapping("/admin/resumen")
    fun obtenerResumenDiario(
        @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) fecha: LocalDate
    ): ResponseEntity<ResumenDiarioResponse> {
        logger.info("[RESUMEN_DIARIO] Request. Fecha: {}", fecha)
        val resumen = reservaService.obtenerResumenDiario(fecha)
        return ResponseEntity.ok(resumen)
    }

    @Operation(summary = "Crear reserva (Carrito)", operationId = "crearReserva")
    @ApiResponses(
        ApiResponse(responseCode = "200", description = "Reserva creada"),
        ApiResponse(responseCode = "400", description = "Datos inv√°lidos")
    )
    @PostMapping
    fun crear(
        @Valid @RequestBody request: ReservaCreateRequest,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<CitaResponse> {
        logger.info("[CREAR_RESERVA] Request recibida. Tutor: {}", principal.email)
        val result = reservaService.crearReserva(
            detalles = request.detalles,
            fechaHoraInicio = request.fechaHoraInicio,
            origen = request.origen,
            tutor = principal,
            tipoAtencion = request.tipoAtencion,
            direccion = request.direccion,
            pagoTotal = request.pagoTotal,
            motivoConsulta = request.motivoConsulta
        )
        logger.info("[CREAR_RESERVA] Fin request - Exitoso. ID Cita: {}", result.cita.id)
        return ResponseEntity.ok(result.cita.toResponse())
    }

    @Operation(summary = "Confirmar reserva", operationId = "confirmarReserva")
    @ApiResponses(
        ApiResponse(responseCode = "200", description = "Reserva confirmada"),
        ApiResponse(responseCode = "404", description = "Reserva no encontrada")
    )
    @PatchMapping("/{id}/confirmar")
    fun confirmar(
        @PathVariable id: UUID,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<CitaResponse> {
        logger.info("[CONFIRMAR_RESERVA] Request. ID: {}", id)
        val cita = reservaService.confirmar(id, principal)
        logger.info("[CONFIRMAR_RESERVA] Fin request - Exitoso")
        return ResponseEntity.ok(cita.toResponse())
    }

    @Operation(summary = "Cancelar reserva", operationId = "cancelarReserva")
    @ApiResponses(
        ApiResponse(responseCode = "200", description = "Reserva cancelada"),
        ApiResponse(responseCode = "404", description = "Reserva no encontrada")
    )
    @DeleteMapping("/{id}")
    fun cancelar(
        @PathVariable id: UUID,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<CitaResponse> {
        logger.info("[CANCELAR_RESERVA] Request. ID: {}", id)
        val cita = reservaService.cancelar(id, principal)
        logger.info("[CANCELAR_RESERVA] Fin request - Exitoso")
        return ResponseEntity.ok(cita.toResponse())
    }

    @Operation(summary = "Listar reservas", operationId = "listarReservas")
    @ApiResponses(
        ApiResponse(responseCode = "200", description = "Lista de reservas"),
    )
    @GetMapping
    fun listar(
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<List<CitaDetalladaResponse>> {
        logger.info("[LISTAR_RESERVAS] Request. Tutor: {}", principal.email)
        val response = reservaService.listar(principal)
        logger.info("[LISTAR_RESERVAS] Fin request - Encontradas: {}", response.size)
        return ResponseEntity.ok(response)
    }

    @Operation(summary = "Obtener reserva por ID", operationId = "obtenerReserva")
    @ApiResponses(
        ApiResponse(responseCode = "200", description = "Reserva encontrada"),
        ApiResponse(responseCode = "404", description = "Reserva no encontrada")
    )
    @GetMapping("/{id}")
    fun obtener(
        @PathVariable id: UUID,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<CitaDetalladaResponse> {
        logger.info("[OBTENER_RESERVA] Request. ID: {}, User: {}", id, principal.email)
        val response = reservaService.obtenerReserva(id, principal)
        logger.info("[OBTENER_RESERVA] Fin request - Exitoso")
        return ResponseEntity.ok(response)
    }

    @Operation(summary = "Obtener historial de citas de una mascota", operationId = "historialMascota")
    @ApiResponses(
        ApiResponse(responseCode = "200", description = "Historial obtenido"),
        ApiResponse(responseCode = "404", description = "Mascota no encontrada")
    )
    @GetMapping("/mascota/{mascotaId}")
    fun historialMascota(
        @PathVariable mascotaId: UUID,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<List<CitaDetalladaResponse>> {
        logger.info("[HISTORIAL_MASCOTA] Request. MascotaID: {}, User: {}", mascotaId, principal.email)
        val response = reservaService.obtenerHistorialMascota(mascotaId, principal)
        logger.info("[HISTORIAL_MASCOTA] Fin request - Registros: {}", response.size)
        return ResponseEntity.ok(response)
    }

    @Operation(summary = "Finalizar cita y registrar pago saldo (Staff/Admin)", operationId = "finalizarCita")
    @ApiResponses(
        ApiResponse(responseCode = "200", description = "Cita finalizada"),
        ApiResponse(responseCode = "400", description = "Error en finalizaci√≥n")
    )
    @PreAuthorize("hasAnyRole('STAFF', 'ADMIN')")
    @PostMapping("/{id}/finalizar")
    fun finalizar(
        @PathVariable id: UUID,
        @RequestBody(required = false) request: FinalizarCitaRequest?,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<CitaResponse> {
        logger.info("[FINALIZAR_CITA] Request. ID: {}, User: {}", id, principal.email)
        val cita = reservaService.finalizarCita(id, request, principal)
        logger.info("[FINALIZAR_CITA] Fin request - Exitoso")
        return ResponseEntity.ok(cita.toResponse())
    }

    @Operation(summary = "Cancelar reserva (Staff/Admin)", operationId = "cancelarReservaPorStaff")
    @ApiResponses(
        ApiResponse(responseCode = "200", description = "Cita cancelada por staff"),
        ApiResponse(responseCode = "403", description = "Sin permisos")
    )
    @PreAuthorize("hasAnyRole('STAFF', 'ADMIN')")
    @DeleteMapping("/gestion/{id}")
    fun cancelarPorStaff(
        @PathVariable id: UUID,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<CitaResponse> {
        logger.info("[CANCELAR_RESERVA_STAFF] Request. ID: {}, User: {}", id, principal.email)
        val cita = reservaService.cancelarPorStaff(id, principal)
        logger.info("[CANCELAR_RESERVA_STAFF] Fin request - Exitoso")
        return ResponseEntity.ok(cita.toResponse())
    }

    @Operation(summary = "Obtener agenda diaria (Staff/Admin)", operationId = "obtenerAgendaDiaria")
    @ApiResponses(
        ApiResponse(responseCode = "200", description = "Agenda obtenida")
    )
    @PreAuthorize("hasAnyRole('STAFF', 'ADMIN')")
    @GetMapping("/agenda")
    fun obtenerAgendaDiaria(
        @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) fecha: LocalDate
    ): ResponseEntity<List<CitaDetalladaResponse>> {
        logger.info("[AGENDA_DIARIA] Request. Fecha: {}", fecha)
        val agenda = reservaService.obtenerAgendaDiaria(fecha)
        logger.info("[AGENDA_DIARIA] Fin request - Citas: {}", agenda.size)
        return ResponseEntity.ok(agenda)
    }

    @Operation(summary = "Buscar citas por estado", operationId = "buscarPorEstado")
    @GetMapping("/buscar")
    @PreAuthorize("hasAnyRole('STAFF', 'ADMIN')")
    fun buscarPorEstado(
        @RequestParam(required = false) estado: cl.clinipets.agendamiento.domain.EstadoCita?,
        @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) fechaDesde: LocalDate?,
        @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) fechaHasta: LocalDate?
    ): ResponseEntity<List<CitaDetalladaResponse>> {
        logger.info("[BUSCAR_CITAS] Estado: $estado, Desde: $fechaDesde, Hasta: $fechaHasta")

        val resultados = reservaService.buscarCitas(estado, fechaDesde, fechaHasta)
        return ResponseEntity.ok(resultados)
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/identity/application/AuthService.kt">
package cl.clinipets.identity.application

import cl.clinipets.core.config.AdminProperties
import cl.clinipets.core.security.JwtPayload
import cl.clinipets.core.web.NotFoundException
import cl.clinipets.identity.api.ProfileResponse
import cl.clinipets.identity.api.UserUpdateRequest
import cl.clinipets.identity.domain.*
import com.google.firebase.auth.FirebaseToken
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.util.*

@Service
class AuthService(
    private val userRepository: UserRepository,
    private val adminProperties: AdminProperties,
    private val accountMergeService: AccountMergeService
) {
    private val logger = LoggerFactory.getLogger(AuthService::class.java)

    @Transactional
    fun syncFirebaseUser(token: FirebaseToken): User {
        val uid = token.uid
        val email = token.email // Puede ser null si es Phone Auth puro sin email vinculado en Firebase
        val phone = token.claims["phone_number"] as? String
        val name = token.name ?: "Usuario App"
        val picture = token.picture

        // Normalizar tel√©fono si existe
        val normalizedPhone = phone

        // Determinar si es Admin/Staff por email
        val isAdmin = email != null && adminProperties.adminEmails.contains(email.lowercase())
        val targetRole = if (isAdmin) UserRole.STAFF else UserRole.CLIENT

        // Buscar usuarios existentes
        val userByEmail = email?.let { userRepository.findByEmailIgnoreCase(it) }
        val userByPhone = normalizedPhone?.let { userRepository.findByPhone(it) }

        var user: User? = null

        if (userByEmail != null && userByPhone != null) {
            if (userByEmail.id != userByPhone.id) {
                // Caso de Fusi√≥n: Existen dos usuarios distintos.
                // Priorizamos la cuenta con Email (Google) como principal y fusionamos la de tel√©fono.
                logger.info("[AUTH] Fusionando cuenta Tel√©fono (${userByPhone.id}) en cuenta Email (${userByEmail.id})")
                user = accountMergeService.mergeUsers(source = userByPhone, target = userByEmail)
            } else {
                // Son el mismo usuario
                user = userByEmail
            }
        } else if (userByEmail != null) {
            user = userByEmail
        } else if (userByPhone != null) {
            user = userByPhone
        }

        if (user == null) {
            logger.info("[AUTH] Creando usuario nuevo. UID: $uid, Email: $email, Phone: $normalizedPhone")
            val finalEmail = email ?: "${normalizedPhone?.replace("+", "")}@phone.clinipets.local"
            val newAuth = if (email != null) AuthProvider.GOOGLE else AuthProvider.PHONE

            user = User(
                email = finalEmail,
                name = name,
                passwordHash = "{noop}firebase_$uid",
                role = targetRole,
                photoUrl = picture,
                phone = normalizedPhone,
                phoneVerified = true,
                authProvider = newAuth
            )
        } else {
            // Actualizar datos
            if (picture != null && user.photoUrl != picture) {
                user.photoUrl = picture
            }
            if (isAdmin && user.role != UserRole.STAFF) {
                user.role = UserRole.STAFF
            }
            if (normalizedPhone != null && user.phone != normalizedPhone) {
                user.phone = normalizedPhone
                user.phoneVerified = true
            }
            
            // Upgrade de Provider / Email
            if (user.authProvider == AuthProvider.OTP || user.authProvider == AuthProvider.WHATSAPP) {
                 user.authProvider = if (email != null) AuthProvider.GOOGLE else AuthProvider.PHONE
            }
            if (email != null && user.email != email) {
                user.email = email
            }
        }
        
        return userRepository.save(user)
    }

    @Transactional(readOnly = true)
    fun me(jwtPayload: JwtPayload): ProfileResponse {
        val user = userRepository.findById(jwtPayload.userId)
            .orElseThrow { NotFoundException("Usuario no encontrado") }
        return user.toProfileResponse()
    }

    @Transactional
    fun updateProfile(userId: UUID, request: UserUpdateRequest): ProfileResponse {
        val user = userRepository.findById(userId)
            .orElseThrow { NotFoundException("Usuario no encontrado") }

        user.name = request.name
        user.phone = request.phone
        user.address = request.address

        val updatedUser = userRepository.save(user)
        return updatedUser.toProfileResponse()
    }

    private fun User.toProfileResponse() = ProfileResponse(
        id = this.id!!,
        email = this.email,
        name = this.name,
        role = this.role,
        photoUrl = this.photoUrl,
        phone = this.phone,
        address = this.address,
        phoneVerified = this.phoneVerified
    )
}
</file>

<file path="src/main/resources/application-dev.properties">
spring.datasource.url=jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:clinipets_db}
spring.datasource.username=${DB_USER:postgres}
spring.datasource.password=${DB_PASSWORD:postgres}
spring.jpa.hibernate.ddl-auto=create-drop

logging.level.root=INFO
logging.level.cl.clinipets=DEBUG

# --- MinIO Storage (Dev) ---
minio.url=${MINIO_URL:http://minio:9000}
minio.access-key=${MINIO_ACCESS_KEY:clinipets_admin}
minio.secret-key=${MINIO_SECRET_KEY:clinipets_secure_key}
minio.bucket-name=${MINIO_BUCKET_NAME:clinipets-media}
</file>

<file path="src/main/resources/application.properties">
spring.application.name=clinipets-backend
# --- CONFIGURACION DE SECRETOS ---

# --- CONFIGURACION TECNICA BASE ---
spring.jpa.open-in-view=false

# Multipart limits
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

# Jackson Serialization Standard
spring.jackson.serialization.write-dates-as-timestamps=false
# Security Config
app.security.admin-emails=billymartinezc@gmail.com,andreea.aebc@gmail.com
# --- MinIO Storage ---
minio.url=${MINIO_URL:http://minio:9000}
minio.access-key=${MINIO_ACCESS_KEY:clinipets_admin}
minio.secret-key=${MINIO_SECRET_KEY:clinipets_secure_key}
minio.bucket-name=${MINIO_BUCKET_NAME:clinipets-media}

# --- MercadoPago ---
mercadopago.access-token=${MERCADOPAGO_TOKEN:}
clinipets.clinic.name=Clinipets Centro Veterinario
clinipets.clinic.rut=76.543.210-9
clinipets.clinic.address=Av. Salud Animal 1234, Santiago
clinipets.clinic.phone=+56 9 1234 5678
clinipets.clinic.email=contacto@clinipets.cl
clinipets.clinic.website=www.clinipets.cl
# Opcional: Ruta al logo si lo quieres din√°mico
clinipets.clinic.logo-path=classpath:images/logopastel.svg
</file>

<file path="docker-compose.yml">
services:
  # 1. Base de Datos PostgreSQL
  db:
    image: postgres:15
    container_name: clinipets-db
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: ${DB_NAME}
    ports:
      - "5432:5432"
    volumes:
      - postgres-data:/var/lib/postgresql/data
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U ${DB_USER} -d ${DB_NAME}" ]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 20s
    restart: unless-stopped

  # 2. Backend Spring Boot
  app:
    image: clinipets-backend:latest
    container_name: clinipets-app
    build: .
    environment:
      SPRING_PROFILES_ACTIVE: dev
      DB_HOST: db
      DB_PORT: 5432
      DB_NAME: ${DB_NAME}
      DB_USER: ${DB_USER}
      DB_PASSWORD: ${DB_PASSWORD}
      MERCADOPAGO_TOKEN: ${MERCADOPAGO_TOKEN}
      MINIO_ACCESS_KEY: ${MINIO_ACCESS_KEY}
      MINIO_SECRET_KEY: ${MINIO_SECRET_KEY}
      MINIO_URL: http://minio:9000
    ports:
      - "8080:8080"
    depends_on:
      db:
        condition: service_healthy
    healthcheck:
      test: "curl -f http://localhost:8080/actuator/health || exit 1"
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # 4. SonarQube
  #  sonarqube:
  #    image: sonarqube:community
  #    container_name: clinipets-sonar
  #    ports:
  #      - "9005:9000"
  #    environment:
  #      - SONAR_ES_BOOTSTRAP_CHECKS_DISABLE=true
  #    volumes:
  #      - sonar_data:/opt/sonarqube/data
  #      - sonar_extensions:/opt/sonarqube/extensions
  #      - sonar_logs:/opt/sonarqube/logs
  #    restart: unless-stopped

  # 5. Cloudflare Tunnel
  tunnel:
    image: cloudflare/cloudflared:latest
    container_name: clinipets-tunnel
    command: tunnel --no-autoupdate run --token ${TUNNEL_TOKEN}
    restart: unless-stopped
    depends_on:
      - app

  # 6. MinIO (S3 Compatible Storage)
  minio:
    image: minio/minio:latest
    container_name: clinipets-minio
    ports:
      - "9000:9000"
      - "9001:9001"
    environment:
      MINIO_ROOT_USER: clinipets_admin
      MINIO_ROOT_PASSWORD: clinipets_secure_key
    command: server /data --console-address ":9001"
    volumes:
      - minio_data:/data
    restart: unless-stopped

volumes:
  postgres-data:
  sonar_data:
  sonar_extensions:
  sonar_logs:
  minio_data:
</file>

<file path="build.gradle.kts">
plugins {
    kotlin("jvm") version "1.9.25"
    kotlin("plugin.spring") version "1.9.25"
    id("org.springframework.boot") version "3.5.6"
    id("io.spring.dependency-management") version "1.1.7"
    kotlin("plugin.jpa") version "1.9.25"
    id("jacoco")
    id("org.sonarqube") version "7.1.0.6387"
}

group = "cl.clinipets"
version = "0.0.1-SNAPSHOT"
description = "backend"

sonar {
    properties {
        property("sonar.projectKey", "clinipets-backend")
        property("sonar.host.url", "http://homeserver.local:9005")
        property("sonar.login", System.getProperty("sonar.token"))
        }
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

repositories { mavenCentral() }

dependencies {
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-security")
    implementation("org.springframework.boot:spring-boot-starter-oauth2-resource-server")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.boot:spring-boot-starter-websocket")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
    implementation("com.fasterxml.jackson.datatype:jackson-datatype-hibernate6")
    implementation("org.jetbrains.kotlin:kotlin-reflect")

    implementation("org.springframework.retry:spring-retry")
    implementation("org.springframework:spring-aspects")

    implementation("com.google.firebase:firebase-admin:9.2.0")

    implementation("com.google.guava:guava:32.0.1-jre")
    implementation("io.minio:minio:8.5.7")
    implementation("com.github.librepdf:openpdf:1.3.39")

    implementation("org.springframework.boot:spring-boot-starter-actuator")
    // springdoc: actualizar a versi√≥n compatible con Spring Boot 3.5
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.13")

    developmentOnly("org.springframework.boot:spring-boot-devtools")
    runtimeOnly("org.postgresql:postgresql")
    // H2 local y pruebas
    runtimeOnly("com.h2database:h2")
    annotationProcessor("org.springframework.boot:spring-boot-configuration-processor")
    // test
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.springframework.security:spring-security-test")
    // Usar mockito-core (sin inline)
    testImplementation("org.mockito:mockito-core:5.12.0")
    // Matchers seguros para Kotlin
    testImplementation("org.mockito.kotlin:mockito-kotlin:5.4.0")
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")

    // Logging JSON
    implementation("net.logstash.logback:logstash-logback-encoder:7.4")
}

configurations.all {
    exclude(group = "commons-logging", module = "commons-logging")
    resolutionStrategy {
        force(
            "com.squareup.okio:okio:3.4.0",
            "com.squareup.okio:okio-jvm:3.4.0"
        )
    }
}

kotlin {
    compilerOptions { freeCompilerArgs.addAll("-Xjsr305=strict") }
}

allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.MappedSuperclass")
    annotation("jakarta.persistence.Embeddable")
    annotation("org.springframework.stereotype.Service")
    annotation("org.springframework.stereotype.Component")
}

tasks.withType<Test> {
    useJUnitPlatform()
    jvmArgs("-XX:+EnableDynamicAgentLoading", "-Djdk.attach.allowAttachSelf=true")
    // Mostrar m√°s contexto al ejecutar tests
    testLogging {
        events = setOf(
            org.gradle.api.tasks.testing.logging.TestLogEvent.PASSED,
            org.gradle.api.tasks.testing.logging.TestLogEvent.SKIPPED,
            org.gradle.api.tasks.testing.logging.TestLogEvent.FAILED,
            org.gradle.api.tasks.testing.logging.TestLogEvent.STANDARD_OUT,
            org.gradle.api.tasks.testing.logging.TestLogEvent.STANDARD_ERROR
        )
        exceptionFormat = org.gradle.api.tasks.testing.logging.TestExceptionFormat.FULL
        showStandardStreams = true
    }
}

jacoco {
    toolVersion = "0.8.12"
}

tasks.named<Test>("test") {
    useJUnitPlatform()
    finalizedBy(tasks.named("jacocoTestReport"))
}

tasks.named<JacocoReport>("jacocoTestReport") {
    dependsOn(tasks.named("test"))
    reports {
        xml.required.set(true)
        csv.required.set(false)
        html.required.set(true)
    }
    classDirectories.setFrom(
        files(
            classDirectories.files.map {
                fileTree(it) {
                    exclude(
                        "**/Q*",
                        "**/*Application*",
                        "**/package-info.class"
                    )
                }
            }
        )
    )
    sourceDirectories.setFrom(files("src/main/kotlin"))
    executionData.setFrom(files("build/jacoco/test.exec"))
}

// Regla opcional de cobertura m√≠nima
// tasks.register<JacocoCoverageVerification>("jacocoTestCoverageVerification") {
//     dependsOn(tasks.test)
//     violationRules {
//         rule { limit { minimum = BigDecimal("0.90") } }
//     }
// }
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/application/ReservaService.kt">
package cl.clinipets.agendamiento.application

import cl.clinipets.agendamiento.api.*
import cl.clinipets.agendamiento.domain.*
import cl.clinipets.agendamiento.domain.events.ReservaCanceladaEvent
import cl.clinipets.agendamiento.domain.events.ReservaConfirmadaEvent
import cl.clinipets.agendamiento.domain.events.ReservaCreadaEvent
import cl.clinipets.core.security.JwtPayload
import cl.clinipets.core.web.BadRequestException
import cl.clinipets.core.web.NotFoundException
import cl.clinipets.core.web.UnauthorizedException
import cl.clinipets.identity.domain.UserRole
import cl.clinipets.servicios.application.InventarioService
import cl.clinipets.servicios.domain.CategoriaServicio
import cl.clinipets.servicios.domain.ServicioMedicoRepository
import cl.clinipets.veterinaria.domain.MascotaRepository
import org.springframework.context.ApplicationEventPublisher
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import org.springframework.transaction.support.TransactionTemplate
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId
import java.time.temporal.ChronoUnit
import java.util.UUID

data class ReservaResult(val cita: Cita)

@Service
class ReservaService(
    private val citaRepository: CitaRepository,
    private val disponibilidadService: DisponibilidadService,
    private val servicioMedicoRepository: ServicioMedicoRepository,
    private val mascotaRepository: MascotaRepository,
    private val inventarioService: InventarioService,
    private val pricingCalculator: PricingCalculator,
    private val clinicalValidator: ClinicalValidator,
    private val signosVitalesRepository: cl.clinipets.veterinaria.domain.SignosVitalesRepository,
    private val clinicZoneId: ZoneId,
    private val eventPublisher: ApplicationEventPublisher,
    private val transactionTemplate: TransactionTemplate
) {
    private val logger = LoggerFactory.getLogger(ReservaService::class.java)

    private data class TempDetalle(
        val servicio: cl.clinipets.servicios.domain.ServicioMedico,
        val mascota: cl.clinipets.veterinaria.domain.Mascota?,
        val precio: Int
    )

    @Transactional(readOnly = true)
    fun obtenerResumenDiario(fecha: LocalDate): ResumenDiarioResponse {
        logger.info("[RESUMEN_DIARIO] Request. Fecha: $fecha")
        val startOfDay = fecha.atStartOfDay(clinicZoneId).toInstant()
        val endOfDay = fecha.plusDays(1).atStartOfDay(clinicZoneId).toInstant()

        val citas = citaRepository.findAllByFechaHoraInicioBetweenOrderByFechaHoraInicioAsc(startOfDay, endOfDay)
        
        // Filter cancelled out for calculations to avoid noise
        val citasValidas = citas.filter { it.estado != EstadoCita.CANCELADA }

        val totalCitas = citasValidas.size
        val citasFinalizadas = citasValidas.count { it.estado == EstadoCita.FINALIZADA }

        // 1. Recaudaci√≥n Realizada (Solo finalizadas)
        val recaudacionTotalRealizada = citasValidas
            .filter { it.estado == EstadoCita.FINALIZADA }
            .sumOf { it.precioFinal }

        // 2. Proyecci√≥n Pendiente (Confirmadas pero no finalizadas)
        val proyeccionPendiente = citasValidas
            .filter { it.estado == EstadoCita.CONFIRMADA }
            .sumOf { it.precioFinal }

        // 3. Desglose de M√©todos de Pago (Solo finalizadas)
        val desgloseMetodosPago = citasValidas
            .filter { it.estado == EstadoCita.FINALIZADA && it.metodoPagoSaldo != null }
            .groupingBy { it.metodoPagoSaldo!! }
            .eachCount()

        val totalGeneral = recaudacionTotalRealizada

        logger.info("[RESUMEN_DIARIO] Realizado: $recaudacionTotalRealizada, Proyectado: $proyeccionPendiente")

        return ResumenDiarioResponse(
            totalCitas = totalCitas,
            citasFinalizadas = citasFinalizadas,
            recaudacionTotalRealizada = recaudacionTotalRealizada,
            proyeccionPendiente = proyeccionPendiente,
            desgloseMetodosPago = desgloseMetodosPago,
            totalGeneral = totalGeneral
        )
    }

    @Transactional
    fun crearReserva(
        detalles: List<ReservaItemRequest>,
        fechaHoraInicio: Instant,
        origen: OrigenCita,
        tutor: JwtPayload,
        tipoAtencion: TipoAtencion = TipoAtencion.CLINICA,
        direccion: String? = null,
        pagoTotal: Boolean = false,
        motivoConsulta: String? = null
    ): ReservaResult {
        logger.info(">>> [CREAR_RESERVA] Inicio. Tutor: ${tutor.email}, Detalles: ${detalles.size}, Fecha: $fechaHoraInicio")

        if (detalles.isEmpty()) throw BadRequestException("Debe incluir al menos un servicio")
        if (tipoAtencion == TipoAtencion.DOMICILIO && direccion.isNullOrBlank()) {
             throw BadRequestException("Debe especificar una direcci√≥n para atenci√≥n a domicilio")
        }

        val serviciosIds = detalles.map { it.servicioId }.toSet()
        val mascotasIds = detalles.map { it.mascotaId }.toSet()

        val serviciosMap = servicioMedicoRepository.findAllById(serviciosIds).associateBy { it.id!! }
        val mascotasMap = mascotaRepository.findAllById(mascotasIds).associateBy { it.id!! }

        if (serviciosMap.size < serviciosIds.size) {
            val missing = serviciosIds - serviciosMap.keys
            throw NotFoundException("Servicios no encontrados: $missing")
        }
        if (mascotasMap.size < mascotasIds.size) {
            val missing = mascotasIds - mascotasMap.keys
            throw NotFoundException("Mascotas no encontradas: $missing")
        }

        // === VALIDAR STOCK ANTES DE PROCEDER ===
        logger.info("[RESERVA] Validando disponibilidad de stock...")
        detalles.forEach { item ->
            val disponible = inventarioService.validarDisponibilidadStock(item.servicioId, item.cantidad)
            if (!disponible) {
                val servicio = serviciosMap[item.servicioId]!!
                throw BadRequestException("Stock insuficiente para: ${servicio.nombre}")
            }
        }
        logger.info("[RESERVA] Stock validado correctamente")

        val fechaCita = fechaHoraInicio.atZone(clinicZoneId).toLocalDate()
        var totalPrecio = 0
        var duracionTotalMinutos = 0L
        val tempList = mutableListOf<TempDetalle>()

        for (item in detalles) {
            val mascota = mascotasMap[item.mascotaId]!!
            if (mascota.tutor.id != tutor.userId) throw UnauthorizedException("La mascota ${mascota.nombre} no te pertenece")

            val servicio = serviciosMap[item.servicioId]!!
            if (!servicio.activo) throw BadRequestException("Servicio inactivo: ${servicio.nombre}")

            clinicalValidator.validarRequisitosClinicos(servicio, mascota, serviciosIds)

            val precioCalculado = pricingCalculator.calcularPrecioFinal(servicio, mascota, fechaCita)

            val precioItem = precioCalculado.precioFinal * item.cantidad
            totalPrecio += precioItem
            duracionTotalMinutos += (servicio.duracionMinutos * item.cantidad)

            repeat(item.cantidad) {
                tempList.add(TempDetalle(servicio, mascota, precioCalculado.precioFinal))
            }
        }

        // Validaci√≥n de Disponibilidad - Validar que TODOS los slots necesarios est√©n disponibles
        val fechaNormalizada = fechaHoraInicio.truncatedTo(ChronoUnit.MINUTES)
        if (duracionTotalMinutos > 0) {
            val slotsDisponibles = disponibilidadService.obtenerSlots(fechaCita, duracionTotalMinutos.toInt())

            // Calcular todos los slots de 15 minutos que necesita la cita
            val finRequerido = fechaNormalizada.plus(duracionTotalMinutos, ChronoUnit.MINUTES)
            val slotsNecesarios = mutableListOf<Instant>()
            var cursor = fechaNormalizada

            while (cursor < finRequerido) {
                slotsNecesarios.add(cursor)
                cursor = cursor.plus(15, ChronoUnit.MINUTES) // Intervalos de 15 min
            }

            // Verificar que TODOS los slots necesarios est√©n disponibles
            val todosDisponibles = slotsNecesarios.all { slot ->
                slotsDisponibles.any { it.compareTo(slot) == 0 }
            }

            if (!todosDisponibles) {
                throw BadRequestException(
                    "No hay disponibilidad continua para la duraci√≥n total ($duracionTotalMinutos min). " +
                    "Algunos slots est√°n ocupados."
                )
            }

            logger.info("[RESERVA] Validados ${slotsNecesarios.size} slots continuos desde $fechaNormalizada")
        }

        val fechaHoraFin = fechaNormalizada.plus(duracionTotalMinutos, ChronoUnit.MINUTES)
        val cita = Cita(
            fechaHoraInicio = fechaNormalizada,
            fechaHoraFin = fechaHoraFin,
            estado = EstadoCita.CONFIRMADA,
            precioFinal = totalPrecio,
            tutorId = tutor.userId,
            origen = origen,
            tipoAtencion = tipoAtencion,
            motivoConsulta = motivoConsulta,
            direccion = direccion
        )

        tempList.forEach { temp ->
            cita.detalles.add(
                DetalleCita(
                    cita = cita,
                    servicio = temp.servicio,
                    mascota = temp.mascota,
                    precioUnitario = temp.precio
                )
            )
        }

        val guardada = citaRepository.save(cita)

        eventPublisher.publishEvent(ReservaCreadaEvent(guardada.id!!))
        return ReservaResult(guardada)
    }

    @Transactional
    fun confirmar(id: UUID, tutor: JwtPayload): Cita {
        logger.info("[CONFIRMAR_RESERVA] Request para CitaID: {}", id)
        val cita = citaRepository.findById(id).orElseThrow { NotFoundException("Cita no encontrada") }
        if (cita.tutorId != tutor.userId) {
            logger.warn("[CONFIRMAR_RESERVA] Usuario {} intent√≥ confirmar cita ajena {}", tutor.email, id)
            throw UnauthorizedException("No puedes confirmar esta cita")
        }
        cita.cambiarEstado(EstadoCita.CONFIRMADA, tutor.email)
        val saved = citaRepository.save(cita)

        logger.info("AUDIT: Cita $id movida a CONFIRMADA por ${tutor.email}")
        eventPublisher.publishEvent(ReservaConfirmadaEvent(saved.id!!))
        return saved
    }

    @Transactional
    fun cancelar(id: UUID, tutor: JwtPayload): Cita {
        logger.info("[CANCELAR_RESERVA] Request para CitaID: {}", id)
        val cita = citaRepository.findById(id).orElseThrow { NotFoundException("Cita no encontrada") }
        if (cita.tutorId != tutor.userId) {
            logger.warn("[CANCELAR_RESERVA] Usuario {} intent√≥ cancelar cita ajena {}", tutor.email, id)
            throw UnauthorizedException("No puedes cancelar esta cita")
        }

        // Solo permitimos cancelar citas que no est√©n ya canceladas o completadas
        if (cita.estado == EstadoCita.CANCELADA) {
            logger.warn("[CANCELAR_RESERVA] Cita {} ya estaba cancelada", id)
            throw BadRequestException("La cita ya est√° cancelada")
        }

        // Reponer stock si corresponde
        reponerStock(cita)

        cita.cambiarEstado(EstadoCita.CANCELADA, tutor.email)
        val saved = citaRepository.save(cita)

        logger.info("AUDIT: Cita $id movida a CANCELADA por ${tutor.email}")
        eventPublisher.publishEvent(ReservaCanceladaEvent(saved.id!!, "El tutor cancel√≥ la reserva"))
        return saved
    }

    private fun reponerStock(cita: Cita) {
        cita.detalles.forEach { detalle ->
            logger.info("[STOCK] Reponiendo stock/insumos para: {}", detalle.servicio.nombre)
            inventarioService.devolverStock(detalle.servicio)
        }
    }

    @Transactional
    fun listar(tutor: JwtPayload): List<CitaDetalladaResponse> {
        val citas = citaRepository.findAllByTutorIdOrderByFechaHoraInicioDesc(tutor.userId)
        return citas.map { it.toDetalladaResponse() }
    }

    @Transactional
    fun obtenerReserva(id: UUID, solicitante: JwtPayload): CitaDetalladaResponse {
        logger.info("[OBTENER_RESERVA] Request. ID: {}, Solicitante: {}", id, solicitante.email)
        val cita = citaRepository.findById(id).orElseThrow { NotFoundException("Cita no encontrada") }

        // Security check: Allow if user is Staff/Admin OR if user is the tutor (owner)
        if (solicitante.role != UserRole.STAFF && solicitante.role != UserRole.ADMIN) {
            if (cita.tutorId != solicitante.userId) {
                logger.warn("[OBTENER_RESERVA] Acceso denegado. User: {} intent√≥ acceder a Cita: {}", solicitante.email, id)
                throw UnauthorizedException("No tienes permiso para ver esta reserva")
            }
        }
        logger.info("[OBTENER_RESERVA] Acceso permitido. Retornando detalle.")
        return cita.toDetalladaResponse()
    }

    @Transactional
    fun obtenerHistorialMascota(mascotaId: UUID, solicitante: JwtPayload): List<CitaDetalladaResponse> {
        logger.info("[HISTORIAL_MASCOTA] Request. MascotaID: {}, Solicitante: {}", mascotaId, solicitante.email)

        // Security Check
        if (solicitante.role != UserRole.STAFF && solicitante.role != UserRole.ADMIN) {
            val mascota = mascotaRepository.findById(mascotaId)
                .orElseThrow { NotFoundException("Mascota no encontrada") }
            
            if (mascota.tutor.id != solicitante.userId) {
                logger.warn("[HISTORIAL_MASCOTA] Acceso denegado. User {} no es due√±o de Mascota {}", solicitante.email, mascotaId)
                throw UnauthorizedException("No tienes permiso para ver el historial de esta mascota")
            }
        }

        val citas = citaRepository.findAllByMascotaId(mascotaId)
        logger.info("[HISTORIAL_MASCOTA] Encontradas {} citas para mascota {}", citas.size, mascotaId)
        return citas.map { it.toDetalladaResponse() }
    }

    // NOT @Transactional at method level to allow manual handling of rollback scenario
    fun finalizarCita(id: UUID, request: FinalizarCitaRequest?, staff: JwtPayload): Cita {
        val metodoPago = request?.metodoPago
        logger.info("[FINALIZAR_CITA] Request. CitaID: {}, Staff: {}, Metodo: {}", id, staff.email, metodoPago)
        
        // Validate permissions
        if (staff.role != UserRole.STAFF && staff.role != UserRole.ADMIN) {
            logger.warn("[FINALIZAR_CITA] Acceso denegado. User {} no es Staff/Admin", staff.email)
            throw UnauthorizedException("No tienes permisos para finalizar citas")
        }

        val cita = citaRepository.findById(id).orElseThrow { NotFoundException("Cita no encontrada") }

        if (cita.estado == EstadoCita.FINALIZADA || cita.estado == EstadoCita.CANCELADA) {
            logger.warn("[FINALIZAR_CITA] Intento de finalizar cita en estado inv√°lido: {}", cita.estado)
            throw BadRequestException("La cita no se puede finalizar porque est√° en estado ${cita.estado}")
        }

        return try {
            val saved = transactionTemplate.execute {
                // 1. Consumir stock
                cita.detalles.forEach { detalle ->
                    logger.info("[FINALIZAR] Consumiendo stock para ${detalle.servicio.nombre}")
                    inventarioService.consumirStock(detalle.servicio.id!!, 1, "Cita $id")

                    // Registrar Signos Vitales si vienen en el request
                    val mascotaVal = detalle.mascota
                    if (mascotaVal != null) {
                        request?.signosVitales?.get(mascotaVal.id)?.let { svReq ->
                            val sv = cl.clinipets.veterinaria.domain.SignosVitales(
                                mascota = mascotaVal,
                                peso = svReq.peso,
                                temperatura = svReq.temperatura,
                                frecuenciaCardiaca = svReq.frecuenciaCardiaca
                            )
                            signosVitalesRepository.save(sv)
                            logger.info("[CLINICO] Signos vitales registrados para mascota {}", mascotaVal.id)
                        }
                    }
                }

                // 2. Solo si TODO el stock se consumi√≥ exitosamente ‚Üí Finalizar
                cita.metodoPagoSaldo = metodoPago
                cita.staffFinalizadorId = staff.userId
                cita.cambiarEstado(EstadoCita.FINALIZADA, staff.email)
                
                citaRepository.save(cita)
            }
            logger.info("AUDIT: Cita $id finalizada y stock descontado por staff ${staff.email}")
            saved!!
        } catch (ex: cl.clinipets.core.web.ConflictException) {
            logger.error("[FINALIZAR] Error consumiendo stock: ${ex.message}")

            // Rollback happened automatically for the transactionTemplate block.
            // Stock is restored.
            // We now mark as CANCELADA in a fresh transaction.

            cita.cambiarEstado(EstadoCita.CANCELADA, staff.email)
            citaRepository.save(cita)

            logger.warn("AUDIT: Cita $id marcada como CANCELADA por falta de stock al finalizar. Staff: ${staff.email}")

            throw BadRequestException(
                "No se pudo finalizar la cita: ${ex.message}. " +
                "El stock fue insuficiente al momento de la atenci√≥n. La cita ha sido cancelada."
            )
        }
    }

    @Transactional
    fun cancelarPorStaff(citaId: UUID, staff: JwtPayload): Cita {
        logger.info("[CANCELAR_STAFF] Iniciando cancelaci√≥n administrativa. CitaID: {}, Staff: {}", citaId, staff.email)
        val cita = citaRepository.findById(citaId).orElseThrow { NotFoundException("Cita no encontrada") }

        // 1. Validar rol
        if (staff.role != UserRole.STAFF && staff.role != UserRole.ADMIN) {
            logger.warn("[CANCELAR_STAFF] Usuario {} sin permisos de Staff", staff.email)
            throw UnauthorizedException("No tienes permisos para realizar esta acci√≥n")
        }

        // 2. Devolver stock
        reponerStock(cita)

        // 3. Cambiar estado
        cita.cambiarEstado(EstadoCita.CANCELADA, staff.email)

        // 4. Guardar y retornar
        val saved = citaRepository.save(cita)
        saved.detalles.size // Forzar carga de detalles

        logger.info("AUDIT: Cita $citaId movida a CANCELADA (Admin) por staff ${staff.email}")
        eventPublisher.publishEvent(ReservaCanceladaEvent(saved.id!!, "Cancelaci√≥n realizada por el staff"))
        return saved
    }

    @Transactional(readOnly = true)
    fun obtenerAgendaDiaria(fecha: LocalDate): List<CitaDetalladaResponse> {
        val startOfDay = fecha.atStartOfDay(clinicZoneId).toInstant()
        val endOfDay = fecha.plusDays(1).atStartOfDay(clinicZoneId).toInstant()

        val citas = citaRepository.findAllByFechaHoraInicioBetweenOrderByFechaHoraInicioAsc(startOfDay, endOfDay)

        return citas.map { it.toDetalladaResponse() }
    }

    @Transactional(readOnly = true)
    fun buscarCitas(
        estado: EstadoCita?,
        fechaDesde: LocalDate?,
        fechaHasta: LocalDate?
    ): List<CitaDetalladaResponse> {
        val inicio = fechaDesde?.atStartOfDay(clinicZoneId)?.toInstant() ?: Instant.EPOCH
        val fin = fechaHasta?.plusDays(1)?.atStartOfDay(clinicZoneId)?.toInstant() ?: Instant.now().plus(365, ChronoUnit.DAYS)

        val citas = citaRepository.findAllByFechaHoraInicioBetweenOrderByFechaHoraInicioAsc(inicio, fin)

        val filtradas = if (estado != null) {
            citas.filter { it.estado == estado }
        } else {
            citas
        }

        return filtradas.map { it.toDetalladaResponse() }
    }
}
</file>

</files>
