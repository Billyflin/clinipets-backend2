This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/build/**, **/target/**, **/.gradle/**, **/.idea/**, **/.git/**, **/*.jar, **/*.class, **/mvnw*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.run/
  ClinipetsApplication.run.xml
android-export/
  BookingScreen.kt
  BookingViewModel.kt
gradle/
  wrapper/
    gradle-wrapper.properties
src/
  main/
    kotlin/
      cl/
        clinipets/
          agendamiento/
            api/
              DisponibilidadController.kt
              DisponibilidadDtos.kt
              ReservaController.kt
              ReservaDtos.kt
            application/
              DisponibilidadService.kt
              ReservaService.kt
            domain/
              Cita.kt
              CitaRepository.kt
              DetalleCita.kt
              EstadoCita.kt
              HorarioClinica.kt
              OrigenCita.kt
          core/
            api/
              PingController.kt
            config/
              DataSeeder.kt
              JwtProperties.kt
              TimeConfig.kt
            domain/
              AuditableEntity.kt
            security/
              JwtAuthenticationFilter.kt
              JwtService.kt
              SecurityConfig.kt
            web/
              ApiError.kt
              ConflictException.kt
              DomainExceptions.kt
              RestExceptionHandler.kt
          identity/
            api/
              AuthController.kt
              AuthDtos.kt
            application/
              AuthService.kt
              GoogleTokenVerifier.kt
            domain/
              User.kt
              UserRepository.kt
              UserRole.kt
          maestros/
            api/
              MaestrosController.kt
            application/
              RazasService.kt
          pagos/
            application/
              MercadoPagoService.kt
          servicios/
            api/
              ServicioDtos.kt
              ServicioMedicoController.kt
            application/
              InventarioService.kt
              ServicioMedicoService.kt
            domain/
              CategoriaServicio.kt
              ReglaPrecio.kt
              ServicioMedico.kt
              ServicioMedicoRepository.kt
          veterinaria/
            api/
              MascotaController.kt
              MascotaDtos.kt
            application/
              MascotaService.kt
            domain/
              Especie.kt
              Mascota.kt
              MascotaEnums.kt
              MascotaRepository.kt
            historial/
              api/
                FichaClinicaController.kt
                HistorialDtos.kt
              application/
                FichaClinicaService.kt
              domain/
                FichaClinica.kt
                FichaClinicaRepository.kt
          ClinipetsApplication.kt
    resources/
      static/
        .well-known/
          assetlinks.json
        google-login.html
        index.html
      application-dev.properties
      application-prod.properties
      application.properties
      banner.txt
      logback-spring.xml
  test/
    kotlin/
      cl/
        clinipets/
          backend/
            agendamiento/
              api/
                ReservaDtosTest.kt
              application/
                ReservaServiceTest.kt
            veterinaria/
              application/
                MascotaServiceTest.kt
          core/
            api/
              InstantSerializationTest.kt
            web/
              DomainExceptionsTest.kt
.dockerignore
.gitattributes
.gitignore
build.gradle.kts
docker-compose.yml
Dockerfile
gradle.properties
gradlew
gradlew.bat
README.md
settings.gradle.kts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="android-export/BookingScreen.kt">
package cl.clinipets.ui.features.booking

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Warning
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import cl.clinipets.data.model.ServicioMedicoDto
import java.text.NumberFormat
import java.util.Locale

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun BookingScreen(
    viewModel: BookingViewModel = hiltViewModel(),
    onBookingSuccess: () -> Unit
) {
    val uiState by viewModel.uiState.collectAsState()
    val snackbarHostState = remember { SnackbarHostState() }

    // Error Handling Side Effect
    LaunchedEffect(uiState.error) {
        uiState.error?.let {
            snackbarHostState.showSnackbar(it)
            viewModel.clearError()
        }
    }

    Scaffold(
        snackbarHost = { SnackbarHost(snackbarHostState) },
        topBar = { TopAppBar(title = { Text("Nueva Reserva") }) }
    ) { padding ->
        Column(
            modifier = Modifier
                .padding(padding)
                .padding(16.dp)
                .fillMaxSize()
        ) {
            // 1. Pet Selector
            Text("Mascota", style = MaterialTheme.typography.labelLarge)
            PetSelector(
                pets = uiState.pets,
                selectedPet = uiState.selectedPet,
                onSelect = { viewModel.onPetSelected(it) }
            )

            Spacer(modifier = Modifier.height(16.dp))

            // 2. Service Selector (Reactive Inventory)
            Text("Agregar Servicio / Producto", style = MaterialTheme.typography.labelLarge)
            ServiceDropdown(
                availableServices = uiState.availableServices,
                onServiceSelected = { viewModel.addToCart(it) }
            )

            Spacer(modifier = Modifier.height(24.dp))

            // 3. Cart List
            Text("Carrito", style = MaterialTheme.typography.titleMedium)
            LazyColumn(modifier = Modifier.weight(1f)) {
                items(uiState.cart) { item ->
                    CartItemCard(
                        item = item,
                        onRemove = { viewModel.removeFromCart(item) }
                    )
                }
            }

            // 4. Confirm Button
            Button(
                onClick = { /* Implement confirm logic via ViewModel -> Repository */ },
                modifier = Modifier.fillMaxWidth(),
                enabled = uiState.cart.isNotEmpty()
            ) {
                Text("Confirmar Reserva")
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ServiceDropdown(
    availableServices: List<ServicioMedicoDto>,
    onServiceSelected: (ServicioMedicoDto) -> Unit
) {
    var expanded by remember { mutableStateOf(false) }
    var selectedText by remember { mutableStateOf("") }

    Box(modifier = Modifier.fillMaxWidth()) {
        ExposedDropdownMenuBox(
            expanded = expanded,
            onExpandedChange = { expanded = !expanded }
        ) {
            OutlinedTextField(
                value = selectedText,
                onValueChange = {},
                readOnly = true,
                placeholder = { Text("Selecciona un servicio...") },
                trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded) },
                modifier = Modifier.menuAnchor().fillMaxWidth()
            )

            ExposedDropdownMenu(
                expanded = expanded,
                onDismissRequest = { expanded = false }
            ) {
                if (availableServices.isEmpty()) {
                    DropdownMenuItem(
                        text = { Text("No hay servicios disponibles para esta mascota") },
                        onClick = { }
                    )
                }

                availableServices.forEach { service ->
                    // Logic for Stock Display
                    val stockInfo = if (service.stock != null) {
                        " - Quedan: ${service.stock}"
                    } else {
                        ""
                    }
                    
                    // Logic for Low Stock Warning Color
                    val isLowStock = service.stock != null && service.stock!! < 5
                    val textColor = if (isLowStock) Color(0xFFFF9800) else Color.Unspecified // Orange for alert

                    DropdownMenuItem(
                        text = {
                            Row(verticalAlignment = Alignment.CenterVertically) {
                                Text(
                                    text = "${service.nombre} (${formatPrice(service.precioBase)})$stockInfo",
                                    color = textColor
                                )
                                if (isLowStock) {
                                    Spacer(modifier = Modifier.width(8.dp))
                                    Icon(
                                        imageVector = Icons.Default.Warning,
                                        contentDescription = "Poco stock",
                                        tint = Color(0xFFFF9800),
                                        modifier = Modifier.size(16.dp)
                                    )
                                }
                            }
                        },
                        onClick = {
                            onServiceSelected(service)
                            expanded = false
                            // We don't update selectedText to keep it acting as an "Add" button field
                            // or update it to "Added!" briefly. Keeping simple for now.
                        }
                    )
                }
            }
        }
    }
}

@Composable
fun CartItemCard(
    item: ServicioMedicoDto,
    onRemove: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp),
        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text(item.nombre, fontWeight = FontWeight.Bold)
                Text(formatPrice(item.precioBase), style = MaterialTheme.typography.bodyMedium)
            }
            IconButton(onClick = onRemove) {
                Icon(Icons.Default.Delete, contentDescription = "Eliminar", tint = MaterialTheme.colorScheme.error)
            }
        }
    }
}

// Utility
fun formatPrice(amount: Int): String {
    return NumberFormat.getCurrencyInstance(Locale("es", "CL")).format(amount)
}

// Placeholder for PetSelector since it wasn't the focus
@Composable
fun PetSelector(
    pets: List<cl.clinipets.data.model.Mascota>,
    selectedPet: cl.clinipets.data.model.Mascota?,
    onSelect: (cl.clinipets.data.model.Mascota) -> Unit
) {
    // Simple Row implementation
    Row(modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp)) {
        pets.forEach { pet ->
            FilterChip(
                selected = pet == selectedPet,
                onClick = { onSelect(pet) },
                label = { Text(pet.nombre) },
                modifier = Modifier.padding(end = 8.dp)
            )
        }
    }
}
</file>

<file path="android-export/BookingViewModel.kt">
package cl.clinipets.ui.features.booking

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import cl.clinipets.data.model.Mascota
import cl.clinipets.data.model.ServicioMedicoDto
import cl.clinipets.data.repository.BookingRepository
import cl.clinipets.data.repository.PetRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

data class BookingUiState(
    val isLoading: Boolean = false,
    val pets: List<Mascota> = emptyList(),
    val selectedPet: Mascota? = null,
    val availableServices: List<ServicioMedicoDto> = emptyList(),
    val cart: List<ServicioMedicoDto> = emptyList(),
    val error: String? = null
)

@HiltViewModel
class BookingViewModel @Inject constructor(
    private val bookingRepository: BookingRepository,
    private val petRepository: PetRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(BookingUiState())
    val uiState: StateFlow<BookingUiState> = _uiState.asStateFlow()

    // Raw data source
    private var _allServices: List<ServicioMedicoDto> = emptyList()

    init {
        loadInitialData()
    }

    private fun loadInitialData() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            try {
                val pets = petRepository.getMyPets()
                _allServices = bookingRepository.getServices() // Fetch raw services

                _uiState.update { currentState ->
                    currentState.copy(
                        isLoading = false,
                        pets = pets,
                        selectedPet = pets.firstOrNull() // Auto-select first pet
                    )
                }
                // Trigger calculation after loading data and setting initial pet
                recalculateAvailableServices()
            } catch (e: Exception) {
                _uiState.update { it.copy(isLoading = false, error = e.message) }
            }
        }
    }

    fun onPetSelected(pet: Mascota) {
        _uiState.update { it.copy(selectedPet = pet) }
        recalculateAvailableServices()
    }

    /**
     * Core Logic: Filters services based on Inventory and Species compatibility.
     */
    private fun recalculateAvailableServices() {
        val currentPet = _uiState.value.selectedPet
        
        val filteredList = _allServices.filter { service ->
            // 1. Species Check: If allowed species set is not empty, pet's species must be in it.
            val isSpeciesCompatible = if (service.especiesPermitidas.isNotEmpty()) {
                currentPet != null && service.especiesPermitidas.contains(currentPet.especie)
            } else {
                true // Service available for all (e.g. generic product)
            }

            // 2. Stock Check: Must be null (infinite) or > 0
            val hasStock = service.stock == null || service.stock!! > 0

            // Include only if both pass
            isSpeciesCompatible && hasStock
        }

        _uiState.update { it.copy(availableServices = filteredList) }
    }

    fun addToCart(service: ServicioMedicoDto) {
        // Double check stock before adding (Defensive Programming)
        if (service.stock != null && service.stock!! <= 0) {
            _uiState.update { it.copy(error = "Lo sentimos, este servicio ya no tiene stock.") }
            return
        }

        _uiState.update {
            it.copy(cart = it.cart + service)
        }
    }

    fun removeFromCart(service: ServicioMedicoDto) {
        _uiState.update {
            it.copy(cart = it.cart - service)
        }
    }
    
    fun clearError() {
        _uiState.update { it.copy(error = null) }
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/web/ConflictException.kt">
package cl.clinipets.core.web

import org.springframework.http.HttpStatus
import org.springframework.web.bind.annotation.ResponseStatus

@ResponseStatus(HttpStatus.CONFLICT)
class ConflictException(message: String) : RuntimeException(message)
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/application/InventarioService.kt">
package cl.clinipets.servicios.application

import cl.clinipets.core.web.ConflictException
import cl.clinipets.servicios.domain.ServicioMedico
import cl.clinipets.servicios.domain.ServicioMedicoRepository
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class InventarioService(
    private val servicioMedicoRepository: ServicioMedicoRepository
) {
    @Transactional
    fun consumirStock(servicio: ServicioMedico, cantidad: Int = 1) {
        if (servicio.stock == null) return

        if (servicio.stock!! < cantidad) {
            throw ConflictException("No hay stock suficiente para ${servicio.nombre}")
        }
        
        servicio.stock = servicio.stock!! - cantidad
        servicioMedicoRepository.save(servicio)
    }
}
</file>

<file path="gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14.3-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/application/DisponibilidadService.kt">
package cl.clinipets.agendamiento.application

import cl.clinipets.agendamiento.domain.Cita
import cl.clinipets.agendamiento.domain.CitaRepository
import cl.clinipets.agendamiento.domain.HorarioClinica
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId
import java.time.temporal.ChronoUnit

@Service
class DisponibilidadService(
    private val citaRepository: CitaRepository
) {
    private val intervaloMinutos = 15L
    private val zoneId = ZoneId.systemDefault()

    @Transactional(readOnly = true)
    fun obtenerSlots(fecha: LocalDate, duracionMinutos: Int): List<Instant> {
        val ventana = HorarioClinica.ventanaPara(fecha.dayOfWeek) ?: return emptyList()
        val (abre, cierra) = ventana

        val startOfDay = fecha.atStartOfDay(zoneId).toInstant()
        val endOfDay = fecha.plusDays(1).atStartOfDay(zoneId).toInstant()
        
        val citasDia = citaRepository.findByFechaHoraFinGreaterThanAndFechaHoraInicioLessThan(startOfDay, endOfDay)

        val slots = mutableListOf<Instant>()
        
        // Construir el cursor inicial: fecha + hora de apertura
        var cursor = fecha.atTime(abre).atZone(zoneId).toInstant()
        val limiteCierre = fecha.atTime(cierra).atZone(zoneId).toInstant()

        while (cursor.plus(duracionMinutos.toLong(), ChronoUnit.MINUTES) <= limiteCierre) {
            val inicio = cursor
            val fin = inicio.plus(duracionMinutos.toLong(), ChronoUnit.MINUTES)
            if (estaLibre(inicio, fin, citasDia)) {
                slots.add(cursor)
            }
            cursor = cursor.plus(intervaloMinutos, ChronoUnit.MINUTES)
        }
        return slots
    }

    private fun estaLibre(inicio: Instant, fin: Instant, citas: List<Cita>): Boolean =
        citas.none { cita ->
            inicio < cita.fechaHoraFin && fin > cita.fechaHoraInicio
        }
}
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/domain/DetalleCita.kt">
package cl.clinipets.agendamiento.domain

import cl.clinipets.servicios.domain.ServicioMedico
import cl.clinipets.veterinaria.domain.Mascota
import jakarta.persistence.*
import java.util.UUID

@Entity
@Table(name = "detalles_cita")
data class DetalleCita(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "cita_id", nullable = false)
    val cita: Cita,

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "servicio_id", nullable = false)
    val servicio: ServicioMedico,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "mascota_id", nullable = true)
    val mascota: Mascota?,

    @Column(nullable = false)
    val precioUnitario: Int
)
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/domain/EstadoCita.kt">
package cl.clinipets.agendamiento.domain

enum class EstadoCita {
    PENDIENTE_PAGO,
    CONFIRMADA,
    CANCELADA,
    COMPLETADA
}
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/domain/HorarioClinica.kt">
package cl.clinipets.agendamiento.domain

import java.time.DayOfWeek
import java.time.LocalTime

object HorarioClinica {
    private val horario: Map<DayOfWeek, Pair<LocalTime, LocalTime>> = mapOf(
        DayOfWeek.MONDAY to (LocalTime.of(11, 0) to LocalTime.of(13, 0)),
        DayOfWeek.TUESDAY to (LocalTime.of(11, 0) to LocalTime.of(13, 0)),
        DayOfWeek.WEDNESDAY to (LocalTime.of(11, 0) to LocalTime.of(13, 0)),
        DayOfWeek.THURSDAY to (LocalTime.of(11, 0) to LocalTime.of(13, 0)),
        DayOfWeek.FRIDAY to (LocalTime.of(11, 0) to LocalTime.of(13, 0)),
        DayOfWeek.SATURDAY to (LocalTime.of(10, 0) to LocalTime.of(19, 0))
    )

    fun ventanaPara(dia: DayOfWeek): Pair<LocalTime, LocalTime>? = horario[dia]
}
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/domain/OrigenCita.kt">
package cl.clinipets.agendamiento.domain

enum class OrigenCita {
    APP, WHATSAPP, WEB
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/config/JwtProperties.kt">
package cl.clinipets.core.config

import org.springframework.boot.context.properties.ConfigurationProperties

@ConfigurationProperties(prefix = "jwt")
data class JwtProperties(
    var secret: String = "",
    var refreshSecret: String = "",
    var issuer: String = "clinipets",
    var expirationMinutes: Long = 60,
    var refreshExpirationHours: Long = 24,
    var cookieName: String? = null
)
</file>

<file path="src/main/kotlin/cl/clinipets/core/config/TimeConfig.kt">
package cl.clinipets.core.config

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.data.auditing.DateTimeProvider
import org.springframework.data.jpa.repository.config.EnableJpaAuditing
import java.time.Clock
import java.time.Instant
import java.util.Optional

@Configuration
@EnableJpaAuditing(dateTimeProviderRef = "auditingDateTimeProvider")
class TimeConfig {

    @Bean
    fun clock(): Clock {
        return Clock.systemUTC()
    }

    @Bean
    fun auditingDateTimeProvider(clock: Clock): DateTimeProvider {
        return DateTimeProvider { Optional.of(Instant.now(clock)) }
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/security/JwtAuthenticationFilter.kt">
package cl.clinipets.core.security

import org.springframework.http.HttpHeaders
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.core.authority.SimpleGrantedAuthority
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource
import org.springframework.stereotype.Component
import org.springframework.web.filter.OncePerRequestFilter
import jakarta.servlet.FilterChain
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpServletResponse

@Component
class JwtAuthenticationFilter(
    private val jwtService: JwtService
) : OncePerRequestFilter() {
    override fun doFilterInternal(
        request: HttpServletRequest,
        response: HttpServletResponse,
        filterChain: FilterChain
    ) {
        val authorization = request.getHeader(HttpHeaders.AUTHORIZATION)
        val bearer = authorization?.takeIf { it.startsWith("Bearer ", ignoreCase = true) }
        val token = bearer?.removePrefix("Bearer ")?.trim()

        if (!token.isNullOrBlank() && SecurityContextHolder.getContext().authentication == null) {
            val payload = jwtService.parseAccessToken(token)
            if (payload != null) {
                val auth = UsernamePasswordAuthenticationToken(
                    payload,
                    null,
                    listOf(SimpleGrantedAuthority("ROLE_${payload.role.name}"))
                )
                auth.details = WebAuthenticationDetailsSource().buildDetails(request)
                SecurityContextHolder.getContext().authentication = auth
            }
        }
        filterChain.doFilter(request, response)
    }

    override fun shouldNotFilter(request: HttpServletRequest): Boolean =
        request.servletPath.startsWith("/actuator") ||
            request.servletPath.equals("/api/auth/refresh") ||
            request.servletPath.equals("/api/auth/google")
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/security/JwtService.kt">
package cl.clinipets.core.security

import cl.clinipets.core.config.JwtProperties
import cl.clinipets.identity.domain.User
import cl.clinipets.identity.domain.UserRole
import io.jsonwebtoken.Jwts
import io.jsonwebtoken.io.Decoders
import io.jsonwebtoken.security.Keys
import org.springframework.stereotype.Component
import java.time.Clock
import java.time.Instant
import java.time.temporal.ChronoUnit
import java.util.*
import java.util.UUID
import javax.crypto.SecretKey

data class JwtPayload(
    val userId: UUID,
    val email: String,
    val role: UserRole,
    val expiresAt: Instant
)

@Component
class JwtService(
    private val props: JwtProperties
) {
    private val clock: Clock = Clock.systemUTC()
    private val accessKey: SecretKey by lazy {
        Keys.hmacShaKeyFor(Decoders.BASE64.decode(props.secret))
    }
    private val refreshKey: SecretKey by lazy {
        Keys.hmacShaKeyFor(Decoders.BASE64.decode(props.refreshSecret))
    }

    fun generateAccessToken(user: User): String = buildToken(user, props.expirationMinutes, accessKey)

    fun generateRefreshToken(user: User): String =
        buildToken(user, props.refreshExpirationHours * 60, refreshKey)

    fun parseAccessToken(token: String): JwtPayload? = parse(token, accessKey)

    fun parseRefreshToken(token: String): JwtPayload? = parse(token, refreshKey)

    private fun buildToken(user: User, minutes: Long, key: SecretKey): String {
        val now = Instant.now(clock)
        val expiry = now.plus(minutes, ChronoUnit.MINUTES)
        return Jwts.builder()
            .subject(user.id?.toString() ?: "")
            .issuer(props.issuer)
            .issuedAt(Date.from(now))
            .expiration(Date.from(expiry))
            .claim("email", user.email)
            .claim("name", user.name)
            .claim("role", user.role.name)
            .signWith(key)
            .compact()
    }

    private fun parse(token: String, key: SecretKey): JwtPayload? {
        return try {
            val claims = Jwts.parser()
                .requireIssuer(props.issuer)
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .payload
            val id = claims.subject?.let {
                try { UUID.fromString(it) } catch (e: Exception) { null }
            } ?: return null
            val email = claims["email"] as? String ?: return null
            val role = (claims["role"] as? String)?.let { UserRole.valueOf(it) } ?: return null
            JwtPayload(
                userId = id,
                email = email,
                role = role,
                expiresAt = claims.expiration.toInstant()
            )
        } catch (ex: Exception) {
            null
        }
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/web/ApiError.kt">
package cl.clinipets.core.web

import java.time.Instant

data class ApiError(
    val message: String,
    val status: Int,
    val timestamp: Instant = Instant.now(),
    val path: String? = null
)
</file>

<file path="src/main/kotlin/cl/clinipets/core/web/DomainExceptions.kt">
package cl.clinipets.core.web

open class DomainException(message: String) : RuntimeException(message)
class NotFoundException(message: String) : DomainException(message)
class UnauthorizedException(message: String) : DomainException(message)
class BadRequestException(message: String) : DomainException(message)
</file>

<file path="src/main/kotlin/cl/clinipets/core/web/RestExceptionHandler.kt">
package cl.clinipets.core.web

import jakarta.servlet.http.HttpServletRequest
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.MethodArgumentNotValidException
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.RestControllerAdvice

@RestControllerAdvice
class RestExceptionHandler {
    @ExceptionHandler(NotFoundException::class)
    fun handleNotFound(ex: NotFoundException, request: HttpServletRequest): ResponseEntity<ApiError> =
        buildError(HttpStatus.NOT_FOUND, ex, request)

    @ExceptionHandler(ConflictException::class)
    fun handleConflict(ex: ConflictException, request: HttpServletRequest): ResponseEntity<ApiError> =
        buildError(HttpStatus.CONFLICT, ex, request)

    @ExceptionHandler(UnauthorizedException::class)
    fun handleUnauthorized(ex: UnauthorizedException, request: HttpServletRequest): ResponseEntity<ApiError> =
        buildError(HttpStatus.UNAUTHORIZED, ex, request)

    @ExceptionHandler(BadRequestException::class, IllegalArgumentException::class)
    fun handleBadRequest(ex: Exception, request: HttpServletRequest): ResponseEntity<ApiError> =
        buildError(HttpStatus.BAD_REQUEST, ex, request)

    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleValidation(ex: MethodArgumentNotValidException, request: HttpServletRequest): ResponseEntity<ApiError> {
        val fieldError = ex.bindingResult.fieldError
        val message = fieldError?.defaultMessage ?: "Datos inválidos"
        return buildError(HttpStatus.BAD_REQUEST, IllegalArgumentException(message), request)
    }

    @ExceptionHandler(Exception::class)
    fun handleGeneric(ex: Exception, request: HttpServletRequest): ResponseEntity<ApiError> =
        buildError(HttpStatus.INTERNAL_SERVER_ERROR, ex, request)

    private fun buildError(status: HttpStatus, ex: Exception, request: HttpServletRequest): ResponseEntity<ApiError> {
        val apiError = ApiError(
            message = ex.message ?: status.reasonPhrase,
            status = status.value(),
            path = request.servletPath
        )
        return ResponseEntity.status(status).body(apiError)
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/identity/api/AuthDtos.kt">
package cl.clinipets.identity.api

import cl.clinipets.identity.domain.UserRole
import jakarta.validation.constraints.NotBlank
import java.util.UUID

data class TokenResponse(
    val accessToken: String,
    val refreshToken: String
)

data class GoogleLoginRequest(
    @field:NotBlank(message = "El idToken es obligatorio")
    val idToken: String
)

data class ProfileResponse(
    val id: UUID,
    val email: String,
    val name: String,
    val role: UserRole
)
</file>

<file path="src/main/kotlin/cl/clinipets/identity/application/AuthService.kt">
package cl.clinipets.identity.application

import cl.clinipets.core.security.JwtService
import cl.clinipets.core.security.JwtPayload
import cl.clinipets.core.web.NotFoundException
import cl.clinipets.core.web.UnauthorizedException
import cl.clinipets.identity.api.ProfileResponse
import cl.clinipets.identity.api.TokenResponse
import cl.clinipets.identity.domain.User
import cl.clinipets.identity.domain.UserRepository
import cl.clinipets.identity.domain.UserRole
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.util.*

@Service
class AuthService(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
    private val jwtService: JwtService,
    private val googleTokenVerifier: GoogleTokenVerifier
) {
    @Transactional(readOnly = true)
    fun refresh(token: String?): TokenResponse {
        val payload = token?.let { jwtService.parseRefreshToken(it) }
            ?: throw UnauthorizedException("Token de refresh inválido")
        val user = userRepository.findById(payload.userId)
            .orElseThrow { NotFoundException("Usuario no encontrado") }
        return issueTokens(user)
    }

    @Transactional(readOnly = true)
    fun me(jwtPayload: JwtPayload): ProfileResponse {
        val user = userRepository.findById(jwtPayload.userId)
            .orElseThrow { NotFoundException("Usuario no encontrado") }
        return ProfileResponse(
            id = user.id!!,
            email = user.email,
            name = user.name,
            role = user.role
        )
    }

    @Transactional
    fun loginWithGoogle(idToken: String): TokenResponse {
        val payload = googleTokenVerifier.verify(idToken)
            ?: throw UnauthorizedException("ID Token inválido")
        val email = payload.email?.lowercase() ?: throw UnauthorizedException("ID Token sin email")
        val emailVerified = payload.emailVerified
        if (emailVerified != true) {
            throw UnauthorizedException("Email no verificado en Google")
        }
        val name = payload["name"] as? String
            ?: payload["given_name"] as? String
            ?: "Google User"

        val user = userRepository.findByEmailIgnoreCase(email) ?: userRepository.save(
            User(
                email = email,
                name = name,
                passwordHash = passwordEncoder.encode("google-${UUID.randomUUID()}"),
                role = UserRole.CLIENT
            )
        )
        return issueTokens(user)
    }

    private fun issueTokens(user: User) = TokenResponse(
        accessToken = jwtService.generateAccessToken(user),
        refreshToken = jwtService.generateRefreshToken(user)
    )
}
</file>

<file path="src/main/kotlin/cl/clinipets/identity/application/GoogleTokenVerifier.kt">
package cl.clinipets.identity.application

import com.google.api.client.googleapis.auth.oauth2.GoogleIdToken
import com.google.api.client.googleapis.auth.oauth2.GoogleIdTokenVerifier
import com.google.api.client.http.javanet.NetHttpTransport
import com.google.api.client.json.jackson2.JacksonFactory
import org.springframework.beans.factory.annotation.Value
import org.springframework.stereotype.Component

@Component
class GoogleTokenVerifier(
    @Value("\${google.client-id}") private val clientId: String
) {
    private val verifier: GoogleIdTokenVerifier by lazy {
        GoogleIdTokenVerifier.Builder(NetHttpTransport(), JacksonFactory.getDefaultInstance())
            .setAudience(listOf(clientId))
            .build()
    }

    fun verify(idToken: String): GoogleIdToken.Payload? =
        verifier.verify(idToken)?.payload
}
</file>

<file path="src/main/kotlin/cl/clinipets/identity/domain/User.kt">
package cl.clinipets.identity.domain

import jakarta.persistence.*
import java.time.Instant
import java.util.UUID

@Entity
@Table(name = "users")
data class User(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @Column(nullable = false, unique = true)
    val email: String,

    @Column(nullable = false)
    val name: String,

    @Column(nullable = false)
    val passwordHash: String,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 32)
    val role: UserRole = UserRole.CLIENT,

    @Column(nullable = false, updatable = false)
    val createdAt: Instant = Instant.now()
)
</file>

<file path="src/main/kotlin/cl/clinipets/identity/domain/UserRepository.kt">
package cl.clinipets.identity.domain

import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.util.UUID

@Repository
interface UserRepository : JpaRepository<User, UUID> {
    fun findByEmailIgnoreCase(email: String): User?
    fun existsByEmailIgnoreCase(email: String): Boolean
}
</file>

<file path="src/main/kotlin/cl/clinipets/identity/domain/UserRole.kt">
package cl.clinipets.identity.domain

enum class UserRole { ADMIN, STAFF, CLIENT }
</file>

<file path="src/main/kotlin/cl/clinipets/maestros/api/MaestrosController.kt">
package cl.clinipets.maestros.api

import cl.clinipets.maestros.application.RazasService
import cl.clinipets.veterinaria.domain.Especie
import io.swagger.v3.oas.annotations.Operation
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/api/v1/maestros")
class MaestrosController(
    private val razasService: RazasService
) {

    @Operation(summary = "Listar razas", description = "Devuelve una lista de razas, opcionalmente filtrada por especie")
    @GetMapping("/razas")
    fun listarRazas(
        @RequestParam(required = false) especie: Especie?
    ): ResponseEntity<List<String>> {
        return ResponseEntity.ok(razasService.getRazas(especie))
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/maestros/application/RazasService.kt">
package cl.clinipets.maestros.application

import cl.clinipets.veterinaria.domain.Especie
import org.springframework.stereotype.Service

@Service
class RazasService {
    private val razasPerro = listOf(
        "Mestizo",
        "Labrador Retriever",
        "Pastor Alemán",
        "Golden Retriever",
        "Bulldog Francés",
        "Beagle",
        "Poodle (Caniche)",
        "Chihuahua",
        "Boxer",
        "Dachshund (Salchicha)",
        "Husky Siberiano",
        "Yorkshire Terrier"
    ).sorted()

    private val razasGato = listOf(
        "Mestizo",
        "Persa",
        "Siamés",
        "Maine Coon",
        "Ragdoll",
        "Bengala",
        "Sphynx (Esfinge)",
        "British Shorthair",
        "Angora",
        "Azul Ruso"
    ).sorted()

    fun getRazas(especie: Especie?): List<String> {
        return when (especie) {
            Especie.PERRO -> razasPerro
            Especie.GATO -> razasGato
            null -> (razasPerro + razasGato).sorted().distinct()
        }
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/pagos/application/MercadoPagoService.kt">
package cl.clinipets.pagos.application

import com.mercadopago.MercadoPagoConfig
import com.mercadopago.client.preference.PreferenceClient
import com.mercadopago.client.preference.PreferenceItemRequest
import com.mercadopago.client.preference.PreferenceRequest
import org.springframework.beans.factory.annotation.Value
import org.springframework.stereotype.Component
import java.math.BigDecimal

interface PagoService {
    fun crearPreferencia(titulo: String, precio: Int, externalReference: String): String
}

@Component
class MercadoPagoService(
    @Value("\${mercadopago.access-token}") private val accessToken: String
) : PagoService {

    init {
        require(accessToken.isNotBlank()) { "mercadopago.access-token no está configurado" }
        MercadoPagoConfig.setAccessToken(accessToken)
    }

    override fun crearPreferencia(titulo: String, precio: Int, externalReference: String): String {
        val client = PreferenceClient()
        val item = PreferenceItemRequest.builder()
            .title(titulo)
            .quantity(1)
            .unitPrice(BigDecimal.valueOf(precio.toDouble()))
            .currencyId("CLP")
            .build()
        val request = PreferenceRequest.builder()
            .items(listOf(item))
            .externalReference(externalReference)
            .build()
        val preference = client.create(request)
        return preference.initPoint
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/api/ServicioMedicoController.kt">
package cl.clinipets.servicios.api

import cl.clinipets.servicios.application.ServicioMedicoService
import io.swagger.v3.oas.annotations.Operation
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/api/v1/servicios")
class ServicioMedicoController(
    private val servicioMedicoService: ServicioMedicoService
) {
    @Operation(summary = "Listar servicios activos", operationId = "listarServicios")
    @GetMapping
    fun listar(): ResponseEntity<List<ServicioMedicoDto>> =
        ResponseEntity.ok(servicioMedicoService.listarActivos())
}
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/application/ServicioMedicoService.kt">
package cl.clinipets.servicios.application

import cl.clinipets.servicios.api.ServicioMedicoDto
import cl.clinipets.servicios.api.toDto
import cl.clinipets.servicios.domain.ServicioMedicoRepository
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class ServicioMedicoService(
    private val servicioMedicoRepository: ServicioMedicoRepository
) {
    @Transactional(readOnly = true)
    fun listarActivos(): List<ServicioMedicoDto> =
        servicioMedicoRepository.findByActivoTrue().map { it.toDto() }
}
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/domain/ReglaPrecio.kt">
package cl.clinipets.servicios.domain

import jakarta.persistence.*
import java.math.BigDecimal
import java.util.UUID

@Entity
@Table(name = "reglas_precio")
data class ReglaPrecio(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @Column(nullable = false, precision = 10, scale = 2)
    val pesoMin: BigDecimal,

    @Column(nullable = false, precision = 10, scale = 2)
    val pesoMax: BigDecimal,

    @Column(nullable = false)
    val precio: Int,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "servicio_id", nullable = false)
    var servicio: ServicioMedico
)
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/domain/ServicioMedicoRepository.kt">
package cl.clinipets.servicios.domain

import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.util.UUID

@Repository
interface ServicioMedicoRepository : JpaRepository<ServicioMedico, UUID> {
    fun findByActivoTrue(): List<ServicioMedico>
    fun existsByNombreIgnoreCase(nombre: String): Boolean
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/api/MascotaController.kt">
package cl.clinipets.veterinaria.api

import cl.clinipets.veterinaria.application.MascotaService
import cl.clinipets.core.security.JwtPayload
import io.swagger.v3.oas.annotations.Operation
import jakarta.validation.Valid
import org.springframework.http.ResponseEntity
import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.util.UUID

@RestController
@RequestMapping("/api/mascotas")
class MascotaController(
    private val mascotaService: MascotaService
) {
    @Operation(summary = "Crear mascota", operationId = "crearMascota")
    @PostMapping
    fun crear(
        @Valid @RequestBody request: MascotaCreateRequest,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<MascotaResponse> =
        ResponseEntity.ok(mascotaService.crear(request, principal))

    @Operation(summary = "Listar mascotas", operationId = "listarMascotas")
    @GetMapping
    fun listar(
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<List<MascotaResponse>> =
        ResponseEntity.ok(mascotaService.listar(principal))

    @Operation(summary = "Obtener mascota", operationId = "obtenerMascota")
    @GetMapping("/{id}")
    fun obtener(
        @PathVariable id: UUID,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<MascotaResponse> =
        ResponseEntity.ok(mascotaService.obtener(id, principal))

    @Operation(summary = "Actualizar mascota", operationId = "actualizarMascota")
    @PutMapping("/{id}")
    fun actualizar(
        @PathVariable id: UUID,
        @Valid @RequestBody request: MascotaUpdateRequest,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<MascotaResponse> =
        ResponseEntity.ok(mascotaService.actualizar(id, request, principal))

    @Operation(summary = "Eliminar mascota", operationId = "eliminarMascota")
    @DeleteMapping("/{id}")
    fun eliminar(
        @PathVariable id: UUID,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<Void> {
        mascotaService.eliminar(id, principal)
        return ResponseEntity.noContent().build()
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/domain/Especie.kt">
package cl.clinipets.veterinaria.domain

enum class Especie {
    PERRO, GATO
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/domain/MascotaEnums.kt">
package cl.clinipets.veterinaria.domain

enum class Sexo {
    MACHO, HEMBRA
}

enum class Temperamento {
    DOCIL, NERVIOSO, AGRESIVO
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/domain/MascotaRepository.kt">
package cl.clinipets.veterinaria.domain

import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.util.UUID

@Repository
interface MascotaRepository : JpaRepository<Mascota, UUID> {
    fun findAllByTutorId(tutorId: UUID): List<Mascota>
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/historial/api/FichaClinicaController.kt">
package cl.clinipets.veterinaria.historial.api

import cl.clinipets.core.security.JwtPayload
import cl.clinipets.core.web.UnauthorizedException
import cl.clinipets.identity.domain.UserRole
import cl.clinipets.veterinaria.domain.MascotaRepository
import cl.clinipets.veterinaria.historial.application.FichaClinicaService
import jakarta.validation.Valid
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.web.bind.annotation.*
import java.util.UUID

@RestController
@RequestMapping("/api/v1/fichas")
class FichaClinicaController(
    private val fichaService: FichaClinicaService,
    private val mascotaRepository: MascotaRepository // Needed for ownership check
) {

    @PostMapping
    @PreAuthorize("hasAnyRole('ADMIN', 'STAFF')")
    fun crearFicha(
        @Valid @RequestBody request: FichaCreateRequest,
        @AuthenticationPrincipal user: JwtPayload
    ): ResponseEntity<FichaResponse> {
        val ficha = fichaService.crearFicha(request, user.userId)
        return ResponseEntity.status(HttpStatus.CREATED).body(ficha)
    }

    @GetMapping("/mascota/{mascotaId}")
    @PreAuthorize("hasAnyRole('ADMIN', 'STAFF', 'CLIENT')")
    fun obtenerHistorial(
        @PathVariable mascotaId: UUID,
        @AuthenticationPrincipal user: JwtPayload
    ): ResponseEntity<List<FichaResponse>> {
        
        // If user is CLIENT, must verify ownership
        if (user.role == UserRole.CLIENT) {
             val mascota = mascotaRepository.findById(mascotaId).orElse(null)
             // If mascota doesn't exist, Service will throw NotFound, but here we check access
             if (mascota != null && mascota.tutor.id != user.userId) {
                 throw UnauthorizedException("No tiene permiso para ver el historial de esta mascota.")
             }
        }

        val historial = fichaService.obtenerHistorial(mascotaId)
        return ResponseEntity.ok(historial)
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/historial/api/HistorialDtos.kt">
package cl.clinipets.veterinaria.historial.api

import cl.clinipets.veterinaria.historial.domain.FichaClinica
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.NotNull
import java.time.Instant
import java.time.LocalDate
import java.util.UUID

data class FichaCreateRequest(
    @field:NotNull(message = "El ID de la mascota es obligatorio")
    val mascotaId: UUID,
    val fechaAtencion: Instant = Instant.now(),
    @field:NotBlank(message = "El motivo de consulta es obligatorio")
    val motivoConsulta: String,
    val observaciones: String? = null,
    val diagnostico: String? = null,
    val esVacuna: Boolean = false,
    val nombreVacuna: String? = null,
    val fechaProximaDosis: LocalDate? = null
)

data class FichaResponse(
    val id: UUID,
    val mascotaId: UUID,
    val fechaAtencion: Instant,
    val motivoConsulta: String,
    val observaciones: String?,
    val diagnostico: String?,
    val esVacuna: Boolean,
    val nombreVacuna: String?,
    val fechaProximaDosis: LocalDate?,
    val autorId: UUID
)

fun FichaClinica.toResponse() = FichaResponse(
    id = id!!,
    mascotaId = mascota.id!!,
    fechaAtencion = fechaAtencion,
    motivoConsulta = motivoConsulta,
    observaciones = observaciones,
    diagnostico = diagnostico,
    esVacuna = esVacuna,
    nombreVacuna = nombreVacuna,
    fechaProximaDosis = fechaProximaDosis,
    autorId = autorId
)
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/historial/application/FichaClinicaService.kt">
package cl.clinipets.veterinaria.historial.application

import cl.clinipets.core.web.NotFoundException
import cl.clinipets.veterinaria.domain.MascotaRepository
import cl.clinipets.veterinaria.historial.api.FichaCreateRequest
import cl.clinipets.veterinaria.historial.api.FichaResponse
import cl.clinipets.veterinaria.historial.api.toResponse
import cl.clinipets.veterinaria.historial.domain.FichaClinica
import cl.clinipets.veterinaria.historial.domain.FichaClinicaRepository
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.util.UUID

@Service
class FichaClinicaService(
    private val fichaRepository: FichaClinicaRepository,
    private val mascotaRepository: MascotaRepository
) {

    @Transactional
    fun crearFicha(request: FichaCreateRequest, autorId: UUID): FichaResponse {
        val mascota = mascotaRepository.findById(request.mascotaId)
            .orElseThrow { NotFoundException("Mascota no encontrada con ID: ${request.mascotaId}") }

        val ficha = fichaRepository.save(
            FichaClinica(
                mascota = mascota,
                fechaAtencion = request.fechaAtencion,
                motivoConsulta = request.motivoConsulta,
                observaciones = request.observaciones,
                diagnostico = request.diagnostico,
                esVacuna = request.esVacuna,
                nombreVacuna = request.nombreVacuna,
                fechaProximaDosis = request.fechaProximaDosis,
                autorId = autorId
            )
        )
        return ficha.toResponse()
    }

    @Transactional(readOnly = true)
    fun obtenerHistorial(mascotaId: UUID): List<FichaResponse> {
        // Verificamos que la mascota exista
        if (!mascotaRepository.existsById(mascotaId)) {
            throw NotFoundException("Mascota no encontrada con ID: $mascotaId")
        }
        return fichaRepository.findAllByMascotaIdOrderByFechaAtencionDesc(mascotaId)
            .map { it.toResponse() }
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/historial/domain/FichaClinica.kt">
package cl.clinipets.veterinaria.historial.domain

import cl.clinipets.core.domain.AuditableEntity
import cl.clinipets.veterinaria.domain.Mascota
import jakarta.persistence.*
import java.time.Instant
import java.time.LocalDate
import java.util.UUID

@Entity
@Table(name = "fichas_clinicas")
data class FichaClinica(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "mascota_id", nullable = false)
    val mascota: Mascota,

    @Column(nullable = false)
    val fechaAtencion: Instant = Instant.now(),

    @Column(nullable = false)
    val motivoConsulta: String,

    @Column(columnDefinition = "TEXT")
    val observaciones: String? = null,

    @Column(columnDefinition = "TEXT")
    val diagnostico: String? = null,

    @Column(nullable = false)
    val esVacuna: Boolean = false,

    val nombreVacuna: String? = null,

    val fechaProximaDosis: LocalDate? = null,

    @Column(nullable = false)
    val autorId: UUID
) : AuditableEntity()
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/historial/domain/FichaClinicaRepository.kt">
package cl.clinipets.veterinaria.historial.domain

import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.util.UUID

@Repository
interface FichaClinicaRepository : JpaRepository<FichaClinica, UUID> {
    fun findAllByMascotaIdOrderByFechaAtencionDesc(mascotaId: UUID): List<FichaClinica>
}
</file>

<file path="src/main/kotlin/cl/clinipets/ClinipetsApplication.kt">
package cl.clinipets

import cl.clinipets.core.config.JwtProperties
import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.context.properties.EnableConfigurationProperties
import org.springframework.boot.runApplication

@SpringBootApplication
@EnableConfigurationProperties(JwtProperties::class)
class ClinipetsApplication

fun main(args: Array<String>) {
    runApplication<ClinipetsApplication>(*args)
}
</file>

<file path="src/main/resources/static/.well-known/assetlinks.json">
[
  {
    "relation": [
      "delegate_permission/common.handle_all_urls"
    ],
    "target": {
      "namespace": "android_app",
      "package_name": "cl.clinipets",
      "sha256_cert_fingerprints": [
        "D4:ED:E3:97:76:48:72:C4:C7:6A:2B:C9:BC:9D:AC:71:46:D7:2F:A2:11:A9:0C:1E:02:53:47:54:EE:13:8D:BE"
      ]
    }
  }
]
</file>

<file path="src/main/resources/static/google-login.html">
<!doctype html>
<html lang="es">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
    <title>Obtener Google ID Token - Clinipets</title>
    <script async defer src="https://accounts.google.com/gsi/client"></script>
    <style>
        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif;
            margin: 2rem;
        }

        .box {
            max-width: 720px;
            margin: 0 auto;
        }

        textarea {
            width: 100%;
            height: 160px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        }

        .row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 12px 0;
            flex-wrap: wrap;
        }

        .muted {
            color: #666;
            font-size: 0.9rem;
        }


        button {
            padding: .6rem 1rem;
        }

        code {
            background: #f5f5f5;
            padding: 2px 4px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
<div class="box">
    <h1>Obtener Google ID Token</h1>
    <p class="muted">Usa este botón para iniciar sesión y obtener un <strong>ID Token</strong> (JWT) que luego puedes
        enviar a <code>POST /api/auth/google</code>.</p>

    <div class="row" id="g_id_signin"></div>

    <div class="row">
        <button disabled id="copyBtn">Copiar ID Token</button>
        <span class="muted" id="status">Esperando login…</span>
    </div>

    <label class="muted" for="token">token</label>
    <textarea id="token" placeholder="Aquí verás tu ID Token JWT tras iniciar sesión"></textarea>

    <h3>Cómo usarlo</h3>
    <ol>
        <li>Haz clic en “Sign in with Google”.</li>
        <li>Se rellenará el <em>ID Token</em> en el recuadro superior.</li>
        <li>Cópialo y úsalo en tu request a <code>POST /api/auth/google</code>:
            <pre>POST {{host}}/api/auth/google
Content-Type: application/json

{
  "idToken": "&lt;pega_aquí_el_id_token&gt;"
}
</pre>
        </li>
    </ol>

    <p class="muted">Client ID configurado para esta página:</p>
    <p><code id="cid"></code></p>
</div>

<script>
    // Ajusta este valor si cambias el client id en application-default.properties
    const CLIENT_ID = "516859256009-obqnjjbnn9k5e2phvbk35sspf1sdvqr7.apps.googleusercontent.com";

    const cidEl = document.getElementById('cid');
    const tokenEl = document.getElementById('token');
    const statusEl = document.getElementById('status');
    const copyBtn = document.getElementById('copyBtn');
    cidEl.textContent = CLIENT_ID;

    window.handleCredentialResponse = (response) => {
        const idToken = response && response.credential;
        if (idToken) {
            tokenEl.value = idToken;
            statusEl.textContent = 'ID Token recibido';
            statusEl.className = 'ok';
            copyBtn.disabled = false;
        } else {
            statusEl.textContent = 'No se recibió credential';
            statusEl.className = 'err';
        }
    };

    window.onload = () => {
        google.accounts.id.initialize({
            client_id: CLIENT_ID,
            callback: handleCredentialResponse
        });
        google.accounts.id.renderButton(
            document.getElementById('g_id_signin'),
            {theme: 'outline', size: 'large', type: 'standard', shape: 'rectangular'}
        );
    };

    copyBtn.addEventListener('click', async () => {
        try {
            await navigator.clipboard.writeText(tokenEl.value || '');
            statusEl.textContent = 'Copiado al portapapeles';
            statusEl.className = 'ok';
        } catch (e) {
            statusEl.textContent = 'No se pudo copiar';
            statusEl.className = 'err';
        }
    });
</script>
</body>
</html>
</file>

<file path="src/main/resources/static/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

Hello World!
</body>
</html>
</file>

<file path="src/main/resources/banner.txt">
⣿⣿⣿⡷⠊⡢⡹⣦⡑⢂⢕⢂⢕⢂⢕⢂⠕⠔⠌⠝⠛⠶⠶⢶⣦⣄⢂⢕⢂⢕  ,---. .                  .
⣿⣿⠏⣠⣾⣦⡐⢌⢿⣷⣦⣅⡑⠕⠡⠐⢿⠿⣛⠟⠛⠛⠛⠛⠡⢷⡈⢂⢕⢂  |  -' |  . ,-. . ,-. ,-. |- ,-.
⠟⣡⣾⣿⣿⣿⣿⣦⣑⠝⢿⣿⣿⣿⣿⣿⡵⢁⣤⣶⣶⣿⢿⢿⢿⡟⢻⣤⢑⢂  |  -. |  | | | | | | |-' |  `-.
⣾⣿⣿⡿⢟⣛⣻⣿⣿⣿⣦⣬⣙⣻⣿⣿⣷⣿⣿⢟⢝⢕⢕⢕⢕⢽⣿⣿⣷⣔  `---' `' ' ' ' ' |-' `-' `' `-'
⣿⣿⠵⠚⠉⢀⣀⣀⣈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣗⢕⢕⢕⢕⢕⢕⣽⣿⣿⣿⣿                   |
⢷⣂⣠⣴⣾⡿⡿⡻⡻⣿⣿⣴⣿⣿⣿⣿⣿⣿⣷⣵⣵⣵⣷⣿⣿⣿⣿⣿⣿⡿                   '
⢌⠻⣿⡿⡫⡪⡪⡪⡪⣺⣿⣿⣿⣿⣿⠿⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃  ${application.title} ${application.version}
⠣⡁⠹⡪⡪⡪⡪⣪⣾⣿⣿⣿⣿⠋⠐⢉⢍⢄⢌⠻⣿⣿⣿⣿⣿⣿⣿⣿⠏⠈  Powered by Spring Boot ${spring-boot.version}
⡣⡘⢄⠙⣾⣾⣾⣿⣿⣿⣿⣿⣿⡀⢐⢕⢕⢕⢕⢕⡘⣿⣿⣿⣿⣿⣿⠏⠠⠈
⠌⢊⢂⢣⠹⣿⣿⣿⣿⣿⣿⣿⣿⣧⢐⢕⢕⢕⢕⢕⢅⣿⣿⣿⣿⡿⢋⢜⠠⠈
⢈⢂⢕⢂⠣⡙⢿⣿⣿⣿⣿⣿⣿⣿⣧⢑⢕⢕⢕⢕⢕⣾⣿⣿⢋⢜⠠⠈
</file>

<file path="src/main/resources/logback-spring.xml">
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <include resource="org/springframework/boot/logging/logback/defaults.xml"/>
    <include resource="org/springframework/boot/logging/logback/console-appender.xml"/>

    <!-- Configuración Única: Logs legibles siempre (Dev y Prod) -->
    <!-- Usamos el appender CONSOLE por defecto de Spring Boot que es bonito y legible -->
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
    </root>
</configuration>
</file>

<file path="src/test/kotlin/cl/clinipets/core/api/InstantSerializationTest.kt">
package cl.clinipets.core.api

import com.fasterxml.jackson.databind.ObjectMapper
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.autoconfigure.json.JsonTest
import java.time.Instant

@JsonTest
class InstantSerializationTest {

    @Autowired
    lateinit var objectMapper: ObjectMapper

    @Test
    fun `Instant should serialize to ISO-8601 string`() {
        val now = Instant.now()
        val json = objectMapper.writeValueAsString(now)
        println("Serialized Instant: $json")
        
        // Check if it starts with a quote (string) or is a number
        assertTrue(json.startsWith("\""), "Instant should be serialized as a JSON string, but was: $json")
        // strict ISO check could be added but string check is enough to distinguish from timestamp
    }
}
</file>

<file path="src/test/kotlin/cl/clinipets/core/web/DomainExceptionsTest.kt">
package cl.clinipets.core.web

import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

class DomainExceptionsTest {

    @Test
    fun `DomainException should store the message correctly`() {
        val message = "This is a domain exception"
        val exception = DomainException(message)
        assertEquals(message, exception.message)
    }

    @Test
    fun `NotFoundException should store the message correctly`() {
        val message = "Resource not found"
        val exception = NotFoundException(message)
        assertEquals(message, exception.message)
    }

    @Test
    fun `ConflictException should store the message correctly`() {
        val message = "Conflict occurred"
        val exception = ConflictException(message)
        assertEquals(message, exception.message)
    }

    @Test
    fun `UnauthorizedException should store the message correctly`() {
        val message = "Unauthorized access"
        val exception = UnauthorizedException(message)
        assertEquals(message, exception.message)
    }

    @Test
    fun `BadRequestException should store the message correctly`() {
        val message = "Bad request received"
        val exception = BadRequestException(message)
        assertEquals(message, exception.message)
    }
}
</file>

<file path=".dockerignore">
# Archivos/carpetas que no se necesitan en el contexto de docker build
# Evitar borrar gradle/ ni gradlew, necesarios para el wrapper
auth/
.git
.git/**
.gitignore
.gitattributes
.idea
*.iml
**/.DS_Store

# Gradle caches y outputs
.gradle
.gradle/**
build
build/**
out
out/**

# Node (por si existe frontend dentro del repo)
node_modules
node_modules/**

# Logs y temporales
*.log
**/*.log
.tmp
**/.env
**/.env.*

# Mantener explícitamente estos archivos en el contexto
!../clinipets-backend/Dockerfile
!.dockerignore
!gradlew
!gradlew.bat
!gradle/**
!settings.gradle.kts
!build.gradle.kts
!gradle.properties
!src/**
!build/libs/*.jar
</file>

<file path=".gitattributes">
/gradlew text eol=lf
*.bat text eol=crlf
*.jar binary
</file>

<file path=".gitignore">
# Ignore environment files
.env
.env.*

# Gradle
.gradle/
build/
out/

# IntelliJ IDEA
.idea/
*.iml

# Logs
*.log

# OS files
.DS_Store
Thumbs.db

# Certs/keys (no subir secretos)
certs/
*.pem
*.key
*.crt
*.cer
*.der
*.p12
*.pfx
*.jks

/clinipets.pem
/entityManagerFactory(EntityManagerFactoryBuilder, PersistenceManagedTypes).md
</file>

<file path="gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" -jar "%APP_HOME%\gradle\wrapper\gradle-wrapper.jar" %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="settings.gradle.kts">
rootProject.name = "backend"
</file>

<file path=".run/ClinipetsApplication.run.xml">
<component name="ProjectRunConfigurationManager">
  <configuration default="false" name="ClinipetsApplication" type="SpringBootApplicationConfigurationType" factoryName="Spring Boot" nameIsGenerated="true">
    <option name="ACTIVE_PROFILES" value="dev" />
    <option name="envFilePaths">
      <option value="$PROJECT_DIR$/.env.local" />
    </option>
    <option name="FRAME_DEACTIVATION_UPDATE_POLICY" value="UpdateClassesAndResources" />
    <module name="backend.main" />
    <projectPathOnTarget name="projectPathOnTarget" value="$USER_HOME$/backend" />
    <target name="@@@LOCAL@@@" />
    <selectedOptions>
      <option name="environmentVariables" />
    </selectedOptions>
    <option name="SPRING_BOOT_MAIN_CLASS" value="cl.clinipets.ClinipetsApplication" />
    <method v="2">
      <option name="Make" enabled="true" />
    </method>
  </configuration>
</component>
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/api/DisponibilidadController.kt">
package cl.clinipets.agendamiento.api

import cl.clinipets.agendamiento.application.DisponibilidadService
import io.swagger.v3.oas.annotations.Operation
import org.springframework.format.annotation.DateTimeFormat
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController
import java.time.LocalDate

@RestController
@RequestMapping("/api/v1/disponibilidad")
class DisponibilidadController(
    private val disponibilidadService: DisponibilidadService
) {
    @Operation(summary = "Obtener disponibilidad", operationId = "obtenerDisponibilidad")
    @GetMapping
    fun obtener(
        @RequestParam("fecha") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) fecha: LocalDate,
        @RequestParam("duracionMinutos") duracionMinutos: Int
    ): ResponseEntity<DisponibilidadResponse> {
        val slots = disponibilidadService.obtenerSlots(fecha, duracionMinutos)
        return ResponseEntity.ok(
            DisponibilidadResponse(
                fecha = fecha,
                servicioId = null, // Deprecated/Optional in response
                slots = slots
            )
        )
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/api/DisponibilidadDtos.kt">
package cl.clinipets.agendamiento.api

import java.time.Instant
import java.time.LocalDate
import java.util.UUID

data class DisponibilidadResponse(
    val fecha: LocalDate,
    val servicioId: UUID?,
    val slots: List<Instant>
)
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/api/ReservaController.kt">
package cl.clinipets.agendamiento.api

import cl.clinipets.agendamiento.application.ReservaService
import cl.clinipets.core.security.JwtPayload
import io.swagger.v3.oas.annotations.Operation
import jakarta.validation.Valid
import org.springframework.http.ResponseEntity
import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.web.bind.annotation.*
import java.util.UUID

@RestController
@RequestMapping("/api/v1/reservas")
class ReservaController(
    private val reservaService: ReservaService
) {
    @Operation(summary = "Crear reserva (Carrito)", operationId = "crearReserva")
    @PostMapping
    fun crear(
        @Valid @RequestBody request: ReservaCreateRequest,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<CitaResponse> {
        val result = reservaService.crearReserva(
            detallesRequest = request.detalles,
            fechaHoraInicio = request.fechaHoraInicio,
            origen = request.origen,
            tutor = principal
        )
        return ResponseEntity.ok(result.cita.toResponse(result.paymentUrl))
    }

    @Operation(summary = "Confirmar reserva", operationId = "confirmarReserva")
    @PatchMapping("/{id}/confirmar")
    fun confirmar(
        @PathVariable id: UUID,
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<CitaResponse> {
        val cita = reservaService.confirmar(id, principal)
        return ResponseEntity.ok(cita.toResponse())
    }

    @Operation(summary = "Listar reservas", operationId = "listarReservas")
    @GetMapping
    fun listar(
        @AuthenticationPrincipal principal: JwtPayload
    ): ResponseEntity<List<CitaDetalladaResponse>> {
        return ResponseEntity.ok(reservaService.listar(principal))
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/api/ReservaDtos.kt">
package cl.clinipets.agendamiento.api

import cl.clinipets.agendamiento.domain.Cita
import cl.clinipets.agendamiento.domain.DetalleCita
import cl.clinipets.agendamiento.domain.EstadoCita
import cl.clinipets.agendamiento.domain.OrigenCita
import jakarta.validation.Valid
import jakarta.validation.constraints.NotEmpty
import jakarta.validation.constraints.NotNull
import java.time.Instant
import java.util.UUID

data class DetalleReservaRequest(
    @field:NotNull
    val servicioId: UUID,
    val mascotaId: UUID? // Optional for products
)

data class ReservaCreateRequest(
    @field:NotEmpty
    @field:Valid
    val detalles: List<DetalleReservaRequest>,
    @field:NotNull
    val fechaHoraInicio: Instant,
    @field:NotNull
    val origen: OrigenCita
)

data class DetalleCitaResponse(
    val id: UUID,
    val servicioId: UUID,
    val nombreServicio: String,
    val mascotaId: UUID?,
    val nombreMascota: String?,
    val precioUnitario: Int
)

data class CitaResponse(
    val id: UUID,
    val fechaHoraInicio: Instant,
    val fechaHoraFin: Instant,
    val estado: EstadoCita,
    val precioFinal: Int,
    val detalles: List<DetalleCitaResponse>,
    val tutorId: UUID,
    val origen: OrigenCita,
    val paymentUrl: String?
)

data class CitaDetalladaResponse(
    val id: UUID,
    val fechaHoraInicio: Instant,
    val fechaHoraFin: Instant,
    val estado: EstadoCita,
    val precioFinal: Int,
    val detalles: List<DetalleCitaResponse>,
    val tutorId: UUID,
    val origen: OrigenCita,
    val paymentUrl: String?
)

fun Cita.toResponse(paymentUrl: String? = null) = CitaResponse(
    id = id!!,
    fechaHoraInicio = fechaHoraInicio,
    fechaHoraFin = fechaHoraFin,
    estado = estado,
    precioFinal = precioFinal,
    detalles = detalles.map { it.toResponse() },
    tutorId = tutorId,
    origen = origen,
    paymentUrl = paymentUrl
)

fun Cita.toDetalladaResponse(paymentUrl: String? = null) = CitaDetalladaResponse(
    id = id!!,
    fechaHoraInicio = fechaHoraInicio,
    fechaHoraFin = fechaHoraFin,
    estado = estado,
    precioFinal = precioFinal,
    detalles = detalles.map { it.toResponse() },
    tutorId = tutorId,
    origen = origen,
    paymentUrl = paymentUrl
)

fun DetalleCita.toResponse() = DetalleCitaResponse(
    id = id!!,
    servicioId = servicio.id!!,
    nombreServicio = servicio.nombre,
    mascotaId = mascota?.id,
    nombreMascota = mascota?.nombre,
    precioUnitario = precioUnitario
)
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/application/ReservaService.kt">
package cl.clinipets.agendamiento.application

import cl.clinipets.agendamiento.api.CitaDetalladaResponse
import cl.clinipets.agendamiento.api.DetalleReservaRequest
import cl.clinipets.agendamiento.api.toDetalladaResponse
import cl.clinipets.agendamiento.domain.Cita
import cl.clinipets.agendamiento.domain.CitaRepository
import cl.clinipets.agendamiento.domain.DetalleCita
import cl.clinipets.agendamiento.domain.EstadoCita
import cl.clinipets.agendamiento.domain.OrigenCita
import cl.clinipets.core.security.JwtPayload
import cl.clinipets.core.web.BadRequestException
import cl.clinipets.core.web.NotFoundException
import cl.clinipets.core.web.UnauthorizedException
import cl.clinipets.pagos.application.PagoService
import cl.clinipets.servicios.application.InventarioService
import cl.clinipets.servicios.domain.CategoriaServicio
import cl.clinipets.servicios.domain.ServicioMedicoRepository
import cl.clinipets.veterinaria.domain.MascotaRepository
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.time.Instant
import java.time.ZoneId
import java.time.temporal.ChronoUnit
import java.util.UUID

data class ReservaResult(val cita: Cita, val paymentUrl: String?)

@Service
class ReservaService(
    private val citaRepository: CitaRepository,
    private val disponibilidadService: DisponibilidadService,
    private val servicioMedicoRepository: ServicioMedicoRepository,
    private val mascotaRepository: MascotaRepository,
    private val pagoService: PagoService,
    private val inventarioService: InventarioService
) {

    @Transactional
    fun crearReserva(
        detallesRequest: List<DetalleReservaRequest>,
        fechaHoraInicio: Instant,
        origen: OrigenCita,
        tutor: JwtPayload
    ): ReservaResult {
        if (detallesRequest.isEmpty()) throw BadRequestException("Debe incluir al menos un servicio o producto")

        var totalPrecio = 0
        var duracionTotalMinutos = 0L
        
        // We need a temporary object to hold the data before creating DetalleCita with the Cita reference
        data class TempDetalle(
            val servicio: cl.clinipets.servicios.domain.ServicioMedico,
            val mascota: cl.clinipets.veterinaria.domain.Mascota?,
            val precio: Int
        )
        val tempList = mutableListOf<TempDetalle>()

        for (req in detallesRequest) {
            val servicio = servicioMedicoRepository.findById(req.servicioId)
                .orElseThrow { NotFoundException("Servicio no encontrado: ${req.servicioId}") }
            if (!servicio.activo) throw BadRequestException("Servicio inactivo: ${servicio.nombre}")

            // Delegate inventory management
            inventarioService.consumirStock(servicio)

            var mascota: cl.clinipets.veterinaria.domain.Mascota? = null
            var precioItem = servicio.precioBase

            if (servicio.categoria == CategoriaServicio.PRODUCTO) {
                // Products don't necessarily need a pet, but if provided, check owner
                if (req.mascotaId != null) {
                    mascota = mascotaRepository.findById(req.mascotaId)
                        .orElseThrow { NotFoundException("Mascota no encontrada: ${req.mascotaId}") }
                    if (mascota.tutor.id != tutor.userId) throw UnauthorizedException("La mascota ${mascota.nombre} no te pertenece")
                }
                duracionTotalMinutos += servicio.duracionMinutos
            } else {
                // Services usually require a pet
                if (req.mascotaId == null) throw BadRequestException("El servicio ${servicio.nombre} requiere especificar una mascota")
                
                mascota = mascotaRepository.findById(req.mascotaId)
                    .orElseThrow { NotFoundException("Mascota no encontrada: ${req.mascotaId}") }
                
                if (mascota.tutor.id != tutor.userId) throw UnauthorizedException("La mascota ${mascota.nombre} no te pertenece")

                // Delegate price calculation to Domain Entity
                precioItem = servicio.calcularPrecioPara(mascota)
                duracionTotalMinutos += servicio.duracionMinutos
            }
            
            totalPrecio += precioItem
            tempList.add(TempDetalle(servicio, mascota, precioItem))
        }

        // Validate Availability for the total duration
        if (duracionTotalMinutos > 0) {
            val fechaNormalizada = fechaHoraInicio.truncatedTo(ChronoUnit.MINUTES)
            val fechaLocal = fechaNormalizada.atZone(ZoneId.systemDefault()).toLocalDate()
            val slotValido = disponibilidadService.obtenerSlots(fechaLocal, duracionTotalMinutos.toInt())
                .any { it.compareTo(fechaNormalizada) == 0 }
            if (!slotValido) throw BadRequestException("El horario seleccionado no está disponible para la duración total ($duracionTotalMinutos min)")
            
            // Use normalized time for the appointment start/end
            val fechaHoraFin = fechaNormalizada.plus(duracionTotalMinutos, ChronoUnit.MINUTES)

            val cita = Cita(
                fechaHoraInicio = fechaNormalizada,
                fechaHoraFin = fechaHoraFin,
                estado = EstadoCita.PENDIENTE_PAGO,
                precioFinal = totalPrecio,
                tutorId = tutor.userId,
                origen = origen
            )

            // Now create DetalleCita objects linked to the Cita
            tempList.forEach { temp ->
                cita.detalles.add(
                    DetalleCita(
                        cita = cita,
                        servicio = temp.servicio,
                        mascota = temp.mascota,
                        precioUnitario = temp.precio
                    )
                )
            }

            val guardada = citaRepository.save(cita)

            val paymentUrl = pagoService.crearPreferencia(
                titulo = "Reserva Clínica - ${tempList.size} items",
                precio = guardada.precioFinal,
                externalReference = guardada.id!!.toString()
            )
            return ReservaResult(guardada, paymentUrl)
        } else {
             // Fallback if duration is 0 (e.g. only products), assume immediate/now or keep requested time
             // But usually we should persist something. 
             // If duration is 0, maybe we don't need availability check?
             // Let's keep using fechaHoraInicio as is for 0 duration
             val cita = Cita(
                fechaHoraInicio = fechaHoraInicio,
                fechaHoraFin = fechaHoraInicio,
                estado = EstadoCita.PENDIENTE_PAGO,
                precioFinal = totalPrecio,
                tutorId = tutor.userId,
                origen = origen
            )
            tempList.forEach { temp ->
                cita.detalles.add(
                    DetalleCita(
                        cita = cita,
                        servicio = temp.servicio,
                        mascota = temp.mascota,
                        precioUnitario = temp.precio
                    )
                )
            }
            val guardada = citaRepository.save(cita)
             val paymentUrl = pagoService.crearPreferencia(
                titulo = "Reserva Clínica - ${tempList.size} items",
                precio = guardada.precioFinal,
                externalReference = guardada.id!!.toString()
            )
            return ReservaResult(guardada, paymentUrl)
        }
    }

    @Transactional
    fun confirmar(id: UUID, tutor: JwtPayload): Cita {
        val cita = citaRepository.findById(id).orElseThrow { NotFoundException("Cita no encontrada") }
        if (cita.tutorId != tutor.userId) throw UnauthorizedException("No puedes confirmar esta cita")
        cita.estado = EstadoCita.CONFIRMADA
        return citaRepository.save(cita)
    }

    @Transactional(readOnly = true)
    fun listar(tutor: JwtPayload): List<CitaDetalladaResponse> {
        val citas = citaRepository.findAllByTutorIdOrderByFechaHoraInicioDesc(tutor.userId)
        return citas.map { it.toDetalladaResponse() }
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/domain/Cita.kt">
package cl.clinipets.agendamiento.domain

import cl.clinipets.core.domain.AuditableEntity
import jakarta.persistence.*
import java.time.Instant
import java.util.UUID

@Entity
@Table(name = "citas")
data class Cita(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @Column(nullable = false)
    val fechaHoraInicio: Instant,

    @Column(nullable = false)
    val fechaHoraFin: Instant,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 32)
    var estado: EstadoCita,

    @Column(nullable = false)
    val precioFinal: Int,

    @OneToMany(mappedBy = "cita", cascade = [CascadeType.ALL], orphanRemoval = true, fetch = FetchType.LAZY)
    val detalles: MutableList<DetalleCita> = mutableListOf(),

    @Column(nullable = false)
    val tutorId: UUID,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 16)
    val origen: OrigenCita
) : AuditableEntity()
</file>

<file path="src/main/kotlin/cl/clinipets/agendamiento/domain/CitaRepository.kt">
package cl.clinipets.agendamiento.domain

import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.time.Instant
import java.util.UUID

@Repository
interface CitaRepository : JpaRepository<Cita, UUID> {
    fun findByFechaHoraFinGreaterThanAndFechaHoraInicioLessThan(
        start: Instant,
        end: Instant
    ): List<Cita>

    fun findAllByTutorIdOrderByFechaHoraInicioDesc(tutorId: UUID): List<Cita>
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/domain/AuditableEntity.kt">
package cl.clinipets.core.domain

import jakarta.persistence.Column
import jakarta.persistence.EntityListeners
import jakarta.persistence.MappedSuperclass
import org.springframework.data.annotation.CreatedDate
import org.springframework.data.annotation.LastModifiedDate
import org.springframework.data.jpa.domain.support.AuditingEntityListener
import java.time.Instant

@MappedSuperclass
@EntityListeners(AuditingEntityListener::class)
abstract class AuditableEntity {
    @CreatedDate
    @Column(nullable = false, updatable = false)
    var createdAt: Instant = Instant.EPOCH
        protected set

    @LastModifiedDate
    @Column(nullable = false)
    var updatedAt: Instant = Instant.EPOCH
        protected set
}
</file>

<file path="src/main/kotlin/cl/clinipets/identity/api/AuthController.kt">
package cl.clinipets.identity.api

import cl.clinipets.core.security.JwtPayload
import cl.clinipets.identity.application.AuthService
import io.swagger.v3.oas.annotations.Operation
import jakarta.validation.Valid
import org.springframework.http.ResponseEntity
import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/api/auth")
class AuthController(
    private val authService: AuthService
) {
    @Operation(summary = "Refrescar token", operationId = "refreshToken")
    @PostMapping("/refresh")
    fun refresh(@RequestParam("token") refreshToken: String?): ResponseEntity<TokenResponse> =
        ResponseEntity.ok(authService.refresh(refreshToken))

    @Operation(summary = "Login con Google", operationId = "loginGoogle")
    @PostMapping("/google")
    fun google(@Valid @RequestBody request: GoogleLoginRequest): ResponseEntity<TokenResponse> =
        ResponseEntity.ok(authService.loginWithGoogle(request.idToken))

    @Operation(summary = "Obtener perfil", operationId = "getProfile")
    @GetMapping("/me")
    fun me(@AuthenticationPrincipal principal: JwtPayload): ResponseEntity<ProfileResponse> =
        ResponseEntity.ok(authService.me(principal))
}
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/api/ServicioDtos.kt">
package cl.clinipets.servicios.api

import cl.clinipets.servicios.domain.CategoriaServicio
import cl.clinipets.servicios.domain.ReglaPrecio
import cl.clinipets.servicios.domain.ServicioMedico
import cl.clinipets.veterinaria.domain.Especie
import java.math.BigDecimal
import java.util.UUID

data class ReglaPrecioDto(
    val id: UUID,
    val pesoMin: BigDecimal,
    val pesoMax: BigDecimal,
    val precio: Int
)

data class ServicioMedicoDto(
    val id: UUID,
    val nombre: String,
    val precioBase: Int,
    val requierePeso: Boolean,
    val duracionMinutos: Int,
    val activo: Boolean,
    val categoria: CategoriaServicio,
    val especiesPermitidas: Set<Especie>,
    val stock: Int?,
    val reglas: List<ReglaPrecioDto>
)

fun ServicioMedico.toDto() = ServicioMedicoDto(
    id = id!!,
    nombre = nombre,
    precioBase = precioBase,
    requierePeso = requierePeso,
    duracionMinutos = duracionMinutos,
    activo = activo,
    categoria = categoria,
    especiesPermitidas = especiesPermitidas,
    stock = stock,
    reglas = reglas.map(ReglaPrecio::toDto)
)

fun ReglaPrecio.toDto() = ReglaPrecioDto(
    id = id!!,
    pesoMin = pesoMin,
    pesoMax = pesoMax,
    precio = precio
)
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/domain/CategoriaServicio.kt">
package cl.clinipets.servicios.domain

enum class CategoriaServicio {
    CONSULTA, VACUNA, CIRUGIA, EXAMEN, PRODUCTO, OTRO
}
</file>

<file path="src/main/kotlin/cl/clinipets/servicios/domain/ServicioMedico.kt">
package cl.clinipets.servicios.domain

import cl.clinipets.core.domain.AuditableEntity
import cl.clinipets.veterinaria.domain.Especie
import cl.clinipets.veterinaria.domain.Mascota
import jakarta.persistence.*
import java.util.UUID

@Entity
@Table(name = "servicios_medicos")
data class ServicioMedico(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @Column(nullable = false, unique = true)
    val nombre: String,

    @Column(nullable = false)
    val precioBase: Int,

    @Column(nullable = false)
    val requierePeso: Boolean,

    @Column(nullable = false)
    val duracionMinutos: Int,

    @Column(nullable = false)
    val activo: Boolean = true,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    var categoria: CategoriaServicio = CategoriaServicio.OTRO,

    @ElementCollection(targetClass = Especie::class, fetch = FetchType.EAGER)
    @CollectionTable(name = "servicio_especies", joinColumns = [JoinColumn(name = "servicio_id")])
    @Enumerated(EnumType.STRING)
    @Column(name = "especie", nullable = false)
    var especiesPermitidas: MutableSet<Especie> = mutableSetOf(),

    @Column(nullable = true)
    var stock: Int? = null,

    @OneToMany(mappedBy = "servicio", cascade = [CascadeType.ALL], orphanRemoval = true, fetch = FetchType.LAZY)
    val reglas: MutableList<ReglaPrecio> = mutableListOf()
) : AuditableEntity() {
    fun calcularPrecioPara(mascota: Mascota): Int {
        if (!requierePeso) return precioBase
        val regla = reglas.firstOrNull {
            (mascota.pesoActual >= it.pesoMin) && (mascota.pesoActual <= it.pesoMax)
        }
        return regla?.precio ?: precioBase
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/api/MascotaDtos.kt">
package cl.clinipets.veterinaria.api

import cl.clinipets.veterinaria.domain.Especie
import cl.clinipets.veterinaria.domain.Mascota
import cl.clinipets.veterinaria.domain.Sexo
import cl.clinipets.veterinaria.domain.Temperamento
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.NotNull
import jakarta.validation.constraints.PastOrPresent
import java.math.BigDecimal
import java.time.LocalDate
import java.util.UUID

data class MascotaCreateRequest(
    @field:NotBlank(message = "El nombre es obligatorio")
    val nombre: String,
    @field:NotNull(message = "La especie es obligatoria")
    val especie: Especie,
    @field:NotBlank(message = "La raza es obligatoria (o 'Mestizo')")
    val raza: String,
    @field:NotNull(message = "El sexo es obligatorio")
    val sexo: Sexo,
    val esterilizado: Boolean = false,
    val chipIdentificador: String? = null,
    val temperamento: Temperamento = Temperamento.DOCIL,
    @field:NotNull(message = "El peso es obligatorio")
    val pesoActual: BigDecimal,
    @field:NotNull(message = "La fecha de nacimiento es obligatoria")
    @field:PastOrPresent(message = "La fecha de nacimiento no puede ser futura")
    val fechaNacimiento: LocalDate
)

data class MascotaUpdateRequest(
    @field:NotBlank(message = "El nombre es obligatorio")
    val nombre: String,
    @field:NotNull(message = "El peso es obligatorio")
    val pesoActual: BigDecimal,
    val raza: String?,
    val sexo: Sexo?,
    val esterilizado: Boolean?,
    val chipIdentificador: String?,
    val temperamento: Temperamento?
)

data class MascotaResponse(
    val id: UUID,
    val nombre: String,
    val especie: Especie,
    val raza: String,
    val sexo: Sexo,
    val esterilizado: Boolean,
    val chipIdentificador: String?,
    val temperamento: Temperamento,
    val pesoActual: BigDecimal,
    val fechaNacimiento: LocalDate,
    val tutorId: UUID
)

fun Mascota.toResponse() = MascotaResponse(
    id = id!!,
    nombre = nombre,
    especie = especie,
    raza = raza,
    sexo = sexo,
    esterilizado = esterilizado,
    chipIdentificador = chipIdentificador,
    temperamento = temperamento,
    pesoActual = pesoActual,
    fechaNacimiento = fechaNacimiento,
    tutorId = tutor.id!!
)
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/application/MascotaService.kt">
package cl.clinipets.veterinaria.application

import cl.clinipets.veterinaria.api.MascotaCreateRequest
import cl.clinipets.veterinaria.api.MascotaResponse
import cl.clinipets.veterinaria.api.MascotaUpdateRequest
import cl.clinipets.veterinaria.api.toResponse
import cl.clinipets.veterinaria.domain.Mascota
import cl.clinipets.veterinaria.domain.MascotaRepository
import cl.clinipets.core.security.JwtPayload
import cl.clinipets.core.web.NotFoundException
import cl.clinipets.core.web.UnauthorizedException
import cl.clinipets.identity.domain.UserRepository
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.util.UUID

@Service
class MascotaService(
    private val mascotaRepository: MascotaRepository,
    private val userRepository: UserRepository
) {
    @Transactional
    fun crear(request: MascotaCreateRequest, tutor: JwtPayload): MascotaResponse {
        val user = userRepository.findById(tutor.userId)
            .orElseThrow { NotFoundException("Tutor no encontrado") }
        val mascota = mascotaRepository.save(
            Mascota(
                nombre = request.nombre,
                especie = request.especie,
                raza = request.raza,
                sexo = request.sexo,
                esterilizado = request.esterilizado,
                chipIdentificador = request.chipIdentificador,
                temperamento = request.temperamento,
                pesoActual = request.pesoActual,
                fechaNacimiento = request.fechaNacimiento,
                tutor = user
            )
        )
        return mascota.toResponse()
    }

    @Transactional(readOnly = true)
    fun listar(tutor: JwtPayload): List<MascotaResponse> =
        mascotaRepository.findAllByTutorId(tutor.userId).map { it.toResponse() }

    @Transactional(readOnly = true)
    fun obtener(id: UUID, tutor: JwtPayload): MascotaResponse =
        findMascotaDeTutor(id, tutor).toResponse()

    @Transactional
    fun actualizar(id: UUID, request: MascotaUpdateRequest, tutor: JwtPayload): MascotaResponse {
        val mascota = findMascotaDeTutor(id, tutor)
        mascota.nombre = request.nombre
        mascota.pesoActual = request.pesoActual
        
        request.raza?.let { mascota.raza = it }
        request.sexo?.let { mascota.sexo = it }
        request.esterilizado?.let { mascota.esterilizado = it }
        request.chipIdentificador?.let { mascota.chipIdentificador = it }
        request.temperamento?.let { mascota.temperamento = it }
        
        return mascotaRepository.save(mascota).toResponse()
    }

    @Transactional
    fun eliminar(id: UUID, tutor: JwtPayload) {
        val mascota = findMascotaDeTutor(id, tutor)
        mascotaRepository.delete(mascota)
    }

    private fun findMascotaDeTutor(id: UUID, tutor: JwtPayload): Mascota {
        val mascota = mascotaRepository.findById(id)
            .orElseThrow { NotFoundException("Mascota no encontrada") }
        if (mascota.tutor.id != tutor.userId) throw UnauthorizedException("No puedes acceder a esta mascota")
        return mascota
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/veterinaria/domain/Mascota.kt">
package cl.clinipets.veterinaria.domain

import cl.clinipets.core.domain.AuditableEntity
import cl.clinipets.identity.domain.User
import jakarta.persistence.*
import java.math.BigDecimal
import java.time.LocalDate
import java.util.UUID

@Entity
@Table(name = "mascotas")
data class Mascota(
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    val id: UUID? = null,

    @Column(nullable = false)
    var nombre: String,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 16)
    val especie: Especie,

    @Column(nullable = false, precision = 10, scale = 2)
    var pesoActual: BigDecimal,

    @Column(nullable = false)
    var raza: String = "Mestizo",

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 10)
    var sexo: Sexo,

    @Column(nullable = false)
    var esterilizado: Boolean = false,

    @Column(unique = true)
    var chipIdentificador: String? = null,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 10)
    var temperamento: Temperamento = Temperamento.DOCIL,

    @Column(nullable = false)
    val fechaNacimiento: LocalDate,

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "tutor_id", nullable = false)
    val tutor: User
) : AuditableEntity()
</file>

<file path="gradlew">
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH="\\\"\\\""


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        -jar "$APP_HOME/gradle/wrapper/gradle-wrapper.jar" \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="README.md">
# clinipets

## Getting started

To make it easy for you to get started with GitLab, here's a list of recommended next steps.

Already a pro? Just edit this README.md and make it your own. Want to make it
easy? [Use the template at the bottom](#editing-this-readme)!
repomix --ignore "**/build/**,**/target/**,**/.gradle/**,**/.idea/**,**/.git/**,**/*.jar,**/*.class,**/mvnw*" --output repomix-backend.xml
## Add your files

- [ ] [Create](https://docs.gitlab.com/ee/user/project/repository/web_editor.html#create-a-file)
  or [upload](https://docs.gitlab.com/ee/user/project/repository/web_editor.html#upload-a-file) files
- [ ] [Add files using the command line](https://docs.gitlab.com/topics/git/add_files/#add-files-to-a-git-repository) or
  push an existing Git repository with the following command:

```
cd existing_repo
git remote add origin https://gitlab.com/dci-project/arqsoft-dci/proyectos/2s2025/clinipets/clinipets.git
git branch -M main
git push -uf origin main
```

## Integrate with your tools

- [ ] [Set up project integrations](https://gitlab.com/dci-project/arqsoft-dci/proyectos/2s2025/clinipets/clinipets/-/settings/integrations)

## Collaborate with your team

- [ ] [Invite team members and collaborators](https://docs.gitlab.com/ee/user/project/members/)
- [ ] [Create a new merge request](https://docs.gitlab.com/ee/user/project/merge_requests/creating_merge_requests.html)
- [ ] [Automatically close issues from merge requests](https://docs.gitlab.com/ee/user/project/issues/managing_issues.html#closing-issues-automatically)
- [ ] [Enable merge request approvals](https://docs.gitlab.com/ee/user/project/merge_requests/approvals/)
- [ ] [Set auto-merge](https://docs.gitlab.com/user/project/merge_requests/auto_merge/)

## Test and Deploy

Use the built-in continuous integration in GitLab.

- [ ] [Get started with GitLab CI/CD](https://docs.gitlab.com/ee/ci/quick_start/)
- [ ] [Analyze your code for known vulnerabilities with Static Application Security Testing (SAST)](https://docs.gitlab.com/ee/user/application_security/sast/)
- [ ] [Deploy to Kubernetes, Amazon EC2, or Amazon ECS using Auto Deploy](https://docs.gitlab.com/ee/topics/autodevops/requirements.html)
- [ ] [Use pull-based deployments for improved Kubernetes management](https://docs.gitlab.com/ee/user/clusters/agent/)
- [ ] [Set up protected environments](https://docs.gitlab.com/ee/ci/environments/protected_environments.html)

***

# Editing this README

When you're ready to make this README your own, just edit this file and use the handy template below (or feel free to
structure it however you want - this is just a starting point!). Thanks
to [makeareadme.com](https://www.makeareadme.com/) for this template.

## Suggestions for a good README

Every project is different, so consider which of these sections apply to yours. The sections used in the template are
suggestions for most open source projects. Also keep in mind that while a README can be too long and detailed, too long
is better than too short. If you think your README is too long, consider utilizing another form of documentation rather
than cutting out information.

## Name

Choose a self-explaining name for your project.

## Description

Let people know what your project can do specifically. Provide context and add a link to any reference visitors might be
unfamiliar with. A list of Features or a Background subsection can also be added here. If there are alternatives to your
project, this is a good place to list differentiating factors.

## Badges

On some READMEs, you may see small images that convey metadata, such as whether or not all the tests are passing for the
project. You can use Shields to add some to your README. Many services also have instructions for adding a badge.

## Visuals

Depending on what you are making, it can be a good idea to include screenshots or even a video (you'll frequently see
GIFs rather than actual videos). Tools like ttygif can help, but check out Asciinema for a more sophisticated method.

## Installation

Within a particular ecosystem, there may be a common way of installing things, such as using Yarn, NuGet, or Homebrew.
However, consider the possibility that whoever is reading your README is a novice and would like more guidance. Listing
specific steps helps remove ambiguity and gets people to using your project as quickly as possible. If it only runs in a
specific context like a particular programming language version or operating system or has dependencies that have to be
installed manually, also add a Requirements subsection.

## Usage

Use examples liberally, and show the expected output if you can. It's helpful to have inline the smallest example of
usage that you can demonstrate, while providing links to more sophisticated examples if they are too long to reasonably
include in the README.

## Support

Tell people where they can go to for help. It can be any combination of an issue tracker, a chat room, an email address,
etc.

## Roadmap

If you have ideas for releases in the future, it is a good idea to list them in the README.

## Contributing

State if you are open to contributions and what your requirements are for accepting them.

For people who want to make changes to your project, it's helpful to have some documentation on how to get started.
Perhaps there is a script that they should run or some environment variables that they need to set. Make these steps
explicit. These instructions could also be useful to your future self.

You can also document commands to lint the code or run tests. These steps help to ensure high code quality and reduce
the likelihood that the changes inadvertently break something. Having instructions for running tests is especially
helpful if it requires external setup, such as starting a Selenium server for testing in a browser.

## Authors and acknowledgment

Show your appreciation to those who have contributed to the project.

## License

For open source projects, say how it is licensed.

## Project status

If you have run out of energy or time for your project, put a note at the top of the README saying that development has
slowed down or stopped completely. Someone may choose to fork your project or volunteer to step in as a maintainer or
owner, allowing your project to keep going. You can also make an explicit request for maintainers.
</file>

<file path="src/main/kotlin/cl/clinipets/core/config/DataSeeder.kt">
package cl.clinipets.core.config

import cl.clinipets.servicios.domain.CategoriaServicio
import cl.clinipets.servicios.domain.ReglaPrecio
import cl.clinipets.servicios.domain.ServicioMedico
import cl.clinipets.servicios.domain.ServicioMedicoRepository
import cl.clinipets.veterinaria.domain.Especie
import org.springframework.boot.ApplicationArguments
import org.springframework.boot.ApplicationRunner
import org.springframework.stereotype.Component
import org.springframework.transaction.annotation.Transactional
import java.math.BigDecimal

@Component
class DataSeeder(
    private val servicioMedicoRepository: ServicioMedicoRepository
) : ApplicationRunner {
    @Transactional
    override fun run(args: ApplicationArguments?) {
        if (servicioMedicoRepository.count() > 0) return

        val consulta = ServicioMedico(
            nombre = "Consulta General",
            precioBase = 8000,
            requierePeso = false,
            duracionMinutos = 30,
            activo = true,
            categoria = CategoriaServicio.CONSULTA,
            especiesPermitidas = mutableSetOf() // Todas
        )

        val esterilizacion = ServicioMedico(
            nombre = "Esterilización Canina",
            precioBase = 30000, // base mínima
            requierePeso = true,
            duracionMinutos = 60,
            activo = true,
            categoria = CategoriaServicio.CIRUGIA,
            especiesPermitidas = mutableSetOf(Especie.PERRO)
        )
        val reglasEsterilizacion = listOf(
            ReglaPrecio(
                pesoMin = BigDecimal("0.0"),
                pesoMax = BigDecimal("10.0"),
                precio = 30000,
                servicio = esterilizacion
            ),
            ReglaPrecio(
                pesoMin = BigDecimal("10.0"),
                pesoMax = BigDecimal("15.0"),
                precio = 34000,
                servicio = esterilizacion
            ),
            ReglaPrecio(
                pesoMin = BigDecimal("15.0"),
                pesoMax = BigDecimal("20.0"),
                precio = 38000,
                servicio = esterilizacion
            ),
            ReglaPrecio(
                pesoMin = BigDecimal("20.0"),
                pesoMax = BigDecimal("30.0"),
                precio = 45000,
                servicio = esterilizacion
            )
        )
        esterilizacion.reglas.addAll(reglasEsterilizacion)

        val vacunas = ServicioMedico(
            nombre = "Vacunas",
            precioBase = 12000,
            requierePeso = false,
            duracionMinutos = 15,
            activo = true,
            categoria = CategoriaServicio.VACUNA,
            especiesPermitidas = mutableSetOf(), // Todas
            stock = 100
        )

        val churu = ServicioMedico(
            nombre = "Churu Atún",
            precioBase = 3000,
            requierePeso = false,
            duracionMinutos = 0,
            activo = true,
            categoria = CategoriaServicio.PRODUCTO,
            especiesPermitidas = mutableSetOf(Especie.GATO),
            stock = 50
        )

        servicioMedicoRepository.saveAll(listOf(consulta, esterilizacion, vacunas, churu))
    }
}
</file>

<file path="src/test/kotlin/cl/clinipets/backend/agendamiento/api/ReservaDtosTest.kt">
package cl.clinipets.backend.agendamiento.api

import cl.clinipets.agendamiento.api.CitaResponse
import cl.clinipets.agendamiento.api.ReservaCreateRequest
import cl.clinipets.agendamiento.api.toResponse
import cl.clinipets.agendamiento.domain.Cita
import cl.clinipets.agendamiento.domain.EstadoCita
import cl.clinipets.agendamiento.domain.OrigenCita
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test
import java.time.Instant
import java.time.temporal.ChronoUnit
import java.util.UUID
import org.mockito.Mockito.mock
import org.mockito.Mockito.`when`

class ReservaDtosTest {

    @Test
    fun `ReservaCreateRequest should be correctly instantiated`() {
        val servicioId = UUID.randomUUID()
        val mascotaId = UUID.randomUUID()
        val fechaHoraInicio = Instant.now()
        val origen = OrigenCita.WEB

        val request = ReservaCreateRequest(servicioId, mascotaId, fechaHoraInicio, origen)

        assertEquals(servicioId, request.servicioId)
        assertEquals(mascotaId, request.mascotaId)
        assertEquals(fechaHoraInicio, request.fechaHoraInicio)
        assertEquals(origen, request.origen)
    }

    @Test
    fun `CitaResponse should be correctly instantiated`() {
        val id = UUID.randomUUID()
        val fechaHoraInicio = Instant.now()
        val fechaHoraFin = fechaHoraInicio.plus(1, ChronoUnit.HOURS)
        val estado = EstadoCita.PENDIENTE_PAGO
        val precioFinal = 10000
        val servicioId = UUID.randomUUID()
        val mascotaId = UUID.randomUUID()
        val tutorId = UUID.randomUUID()
        val origen = OrigenCita.WEB
        val paymentUrl = "http://payment.url"

        val response = CitaResponse(
            id,
            fechaHoraInicio,
            fechaHoraFin,
            estado,
            precioFinal,
            servicioId,
            mascotaId,
            tutorId,
            origen,
            paymentUrl
        )

        assertEquals(id, response.id)
        assertEquals(fechaHoraInicio, response.fechaHoraInicio)
        assertEquals(fechaHoraFin, response.fechaHoraFin)
        assertEquals(estado, response.estado)
        assertEquals(precioFinal, response.precioFinal)
        assertEquals(servicioId, response.servicioId)
        assertEquals(mascotaId, response.mascotaId)
        assertEquals(tutorId, response.tutorId)
        assertEquals(origen, response.origen)
        assertEquals(paymentUrl, response.paymentUrl)
    }

    @Test
    fun `Cita toResponse should map correctly with paymentUrl`() {
        val citaId = UUID.randomUUID()
        val fechaHoraInicio = Instant.now()
        val fechaHoraFin = fechaHoraInicio.plus(1, ChronoUnit.HOURS)
        val estado = EstadoCita.PENDIENTE_PAGO
        val precioFinal = 15000
        val servicioId = UUID.randomUUID()
        val mascotaId = UUID.randomUUID()
        val tutorId = UUID.randomUUID()
        val origen = OrigenCita.APP

        val mockCita = mock(Cita::class.java)
        `when`(mockCita.id).thenReturn(citaId)
        `when`(mockCita.fechaHoraInicio).thenReturn(fechaHoraInicio)
        `when`(mockCita.fechaHoraFin).thenReturn(fechaHoraFin)
        `when`(mockCita.estado).thenReturn(estado)
        `when`(mockCita.precioFinal).thenReturn(precioFinal)
        `when`(mockCita.servicioId).thenReturn(servicioId)
        `when`(mockCita.mascotaId).thenReturn(mascotaId)
        `when`(mockCita.tutorId).thenReturn(tutorId)
        `when`(mockCita.origen).thenReturn(origen)

        val paymentUrl = "http://mock.payment.url"
        val response = mockCita.toResponse(paymentUrl)

        assertEquals(citaId, response.id)
        assertEquals(fechaHoraInicio, response.fechaHoraInicio)
        assertEquals(fechaHoraFin, response.fechaHoraFin)
        assertEquals(estado, response.estado)
        assertEquals(precioFinal, response.precioFinal)
        assertEquals(servicioId, response.servicioId)
        assertEquals(mascotaId, response.mascotaId)
        assertEquals(tutorId, response.tutorId)
        assertEquals(origen, response.origen)
        assertEquals(paymentUrl, response.paymentUrl)
    }

    @Test
    fun `Cita toResponse should map correctly without paymentUrl`() {
        val citaId = UUID.randomUUID()
        val fechaHoraInicio = Instant.now()
        val fechaHoraFin = fechaHoraInicio.plus(1, ChronoUnit.HOURS)
        val estado = EstadoCita.CONFIRMADA
        val precioFinal = 12000
        val servicioId = UUID.randomUUID()
        val mascotaId = UUID.randomUUID()
        val tutorId = UUID.randomUUID()
        val origen = OrigenCita.WHATSAPP

        val mockCita = mock(Cita::class.java)
        `when`(mockCita.id).thenReturn(citaId)
        `when`(mockCita.fechaHoraInicio).thenReturn(fechaHoraInicio)
        `when`(mockCita.fechaHoraFin).thenReturn(fechaHoraFin)
        `when`(mockCita.estado).thenReturn(estado)
        `when`(mockCita.precioFinal).thenReturn(precioFinal)
        `when`(mockCita.servicioId).thenReturn(servicioId)
        `when`(mockCita.mascotaId).thenReturn(mascotaId)
        `when`(mockCita.tutorId).thenReturn(tutorId)
        `when`(mockCita.origen).thenReturn(origen)

        val response = mockCita.toResponse() // No paymentUrl provided

        assertEquals(citaId, response.id)
        assertEquals(fechaHoraInicio, response.fechaHoraInicio)
        assertEquals(fechaHoraFin, response.fechaHoraFin)
        assertEquals(estado, response.estado)
        assertEquals(precioFinal, response.precioFinal)
        assertEquals(servicioId, response.servicioId)
        assertEquals(mascotaId, response.mascotaId)
        assertEquals(tutorId, response.tutorId)
        assertEquals(origen, response.origen)
        assertEquals(null, response.paymentUrl) // paymentUrl should be null
    }
}
</file>

<file path="src/test/kotlin/cl/clinipets/backend/agendamiento/application/ReservaServiceTest.kt">
package cl.clinipets.backend.agendamiento.application

import cl.clinipets.agendamiento.application.ReservaService
import cl.clinipets.agendamiento.domain.OrigenCita
import cl.clinipets.pagos.application.PagoService
import cl.clinipets.servicios.domain.ReglaPrecio
import cl.clinipets.servicios.domain.ServicioMedico
import cl.clinipets.servicios.domain.ServicioMedicoRepository
import cl.clinipets.veterinaria.domain.Especie
import cl.clinipets.veterinaria.domain.Mascota
import cl.clinipets.veterinaria.domain.MascotaRepository
import cl.clinipets.core.security.JwtPayload
import cl.clinipets.identity.domain.User
import cl.clinipets.identity.domain.UserRepository
import cl.clinipets.identity.domain.UserRole
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.mockito.kotlin.doReturn
import org.mockito.kotlin.mock
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.boot.test.context.TestConfiguration
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Primary
import org.springframework.test.context.TestPropertySource
import java.math.BigDecimal
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.NONE)
@TestPropertySource(
    properties = [
        "spring.jpa.hibernate.ddl-auto=create-drop",
        "jwt.secret=Y29udGFzZWNvbXNlY3JldG9iZGVDbGluSXBldHMxMjM0NTY3OA==",
        "jwt.refresh-secret=cmVmcmVzaFNlY3JldG9iZGVDbGluSXBldHMxMjM0NTY3OA==",
        "jwt.issuer=TestIssuer",
        "google.client-id=test-google",
        "mercadopago.access-token=dummy"
    ]
)
class ReservaServiceTest(
    @Autowired private val reservaService: ReservaService,
    @Autowired private val userRepository: UserRepository,
    @Autowired private val mascotaRepository: MascotaRepository,
    @Autowired private val servicioMedicoRepository: ServicioMedicoRepository
) {

    @Autowired
    private lateinit var pagoMock: PagoService

    private lateinit var tutorPayload: JwtPayload
    private lateinit var servicio: ServicioMedico
    private lateinit var mascota: Mascota

    @BeforeEach
    fun setup() {
        servicioMedicoRepository.deleteAll()
        mascotaRepository.deleteAll()
        userRepository.deleteAll()

        val tutor = userRepository.save(
            User(
                email = "tutor@test.com",
                name = "Tutor",
                passwordHash = "pw",
                role = UserRole.CLIENT
            )
        )
        tutorPayload = JwtPayload(
            userId = tutor.id!!,
            email = tutor.email,
            role = tutor.role,
            expiresAt = Instant.now()
        )
        servicio = servicioMedicoRepository.save(
            ServicioMedico(
                nombre = "Esterilización Canina",
                precioBase = 30000,
                requierePeso = true,
                duracionMinutos = 60,
                activo = true,
                reglas = mutableListOf()
            )
        )
        val regla = ReglaPrecio(
            pesoMin = BigDecimal("0.0"),
            pesoMax = BigDecimal("10.0"),
            precio = 30000,
            servicio = servicio
        )
        servicio.reglas.add(regla)
        servicio = servicioMedicoRepository.save(servicio)

        mascota = mascotaRepository.save(
            Mascota(
                nombre = "Firulais",
                especie = Especie.PERRO,
                pesoActual = BigDecimal("8.5"),
                // Usamos LocalDate para fecha de nacimiento
                fechaNacimiento = LocalDate.of(2022, 5, 10),
                tutor = tutor
            )
        )
    }

    @Test
    fun `crear reserva genera payment url y cita pendiente`() {
        // Buscamos siguiente sabado
        val fechaSabado = siguienteSabadoAMas(LocalDate.now())
        // Convertimos a Instant a las 11:00 (HorarioClinica abre Sabado a las 10:00, cierra 19:00. 11:00 es válido)
        val inicio = fechaSabado.atTime(11, 0).atZone(ZoneId.systemDefault()).toInstant()
        
        val result = reservaService.crearReserva(
            servicioId = servicio.id!!,
            mascotaId = mascota.id!!,
            fechaHoraInicio = inicio,
            origen = OrigenCita.APP,
            tutor = tutorPayload
        )
        assertEquals("https://pago.test", result.paymentUrl)
        assertEquals(servicio.id, result.cita.servicioId)
        assertEquals(mascota.id, result.cita.mascotaId)
        assertEquals(tutorPayload.userId, result.cita.tutorId)
        assertEquals(30000, result.cita.precioFinal)
    }

    private fun siguienteSabadoAMas(hoy: LocalDate): LocalDate {
        var fecha = hoy
        while (fecha.dayOfWeek.value != 6) { // 6 is Saturday
            fecha = fecha.plusDays(1)
        }
        return fecha
    }

    @TestConfiguration
    class PagoMockConfig {
        @Bean
        @Primary
        fun pagoMock(): PagoService = mock {
            on { crearPreferencia(org.mockito.kotlin.any(), org.mockito.kotlin.any(), org.mockito.kotlin.any()) } doReturn "https://pago.test"
        }
    }
}
</file>

<file path="src/test/kotlin/cl/clinipets/backend/veterinaria/application/MascotaServiceTest.kt">
package cl.clinipets.backend.veterinaria.application

import cl.clinipets.veterinaria.api.MascotaCreateRequest
import cl.clinipets.veterinaria.domain.Especie
import cl.clinipets.veterinaria.domain.MascotaRepository
import cl.clinipets.core.security.JwtPayload
import cl.clinipets.identity.domain.User
import cl.clinipets.identity.domain.UserRepository
import cl.clinipets.identity.domain.UserRole
import cl.clinipets.veterinaria.application.MascotaService
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.TestPropertySource
import java.math.BigDecimal
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.NONE)
@TestPropertySource(
    properties = [
        "spring.jpa.hibernate.ddl-auto=create-drop",
        "jwt.secret=Y29udGFzZWNvbXNlY3JldG9iZGVDbGluSXBldHMxMjM0NTY3OA==",
        "jwt.refresh-secret=cmVmcmVzaFNlY3JldG9iZGVDbGluSXBldHMxMjM0NTY3OA==",
        "jwt.issuer=TestIssuer",
        "google.client-id=test-google"
    ]
)
class MascotaServiceTest(
    @Autowired private val mascotaService: MascotaService,
    @Autowired private val userRepository: UserRepository,
    @Autowired private val mascotaRepository: MascotaRepository
) {

    private lateinit var tutorPayload: JwtPayload
    private lateinit var otroPayload: JwtPayload

    @BeforeEach
    fun setup() {
        mascotaRepository.deleteAll()
        userRepository.deleteAll()

        val tutor = userRepository.save(
            User(
                email = "tutor@test.com",
                name = "Tutor",
                passwordHash = "pw",
                role = UserRole.CLIENT
            )
        )
        val otro = userRepository.save(
            User(
                email = "otro@test.com",
                name = "Otro",
                passwordHash = "pw",
                role = UserRole.CLIENT
            )
        )
        tutorPayload = JwtPayload(
            userId = tutor.id!!,
            email = tutor.email,
            role = tutor.role,
            expiresAt = Instant.now()
        )
        otroPayload = JwtPayload(
            userId = otro.id!!,
            email = otro.email,
            role = otro.role,
            expiresAt = Instant.now()
        )
    }

    @Test
    fun `crear y obtener mascota del tutor`() {
        val creada = mascotaService.crear(
            MascotaCreateRequest(
                nombre = "Firulais",
                especie = Especie.PERRO,
                pesoActual = BigDecimal("8.5"),
                fechaNacimiento = LocalDate.of(2022, 5, 10)
            ),
            tutorPayload
        )
        assertEquals("Firulais", creada.nombre)
        assertEquals(tutorPayload.userId, creada.tutorId)

        val listadas = mascotaService.listar(tutorPayload)
        assertEquals(1, listadas.size)
        assertEquals(creada.id, listadas.first().id)
    }

    @Test
    fun `otro usuario no puede acceder mascota ajena`() {
        mascotaService.crear(
            MascotaCreateRequest(
                nombre = "Michi",
                especie = Especie.GATO,
                pesoActual = BigDecimal("4.2"),
                fechaNacimiento = LocalDate.of(2023, 3, 15)
            ),
            tutorPayload
        )
        val listadasPorOtro = mascotaService.listar(otroPayload)
        assertEquals(0, listadasPorOtro.size)
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/api/PingController.kt">
package cl.clinipets.core.api

import cl.clinipets.core.security.JwtPayload
import io.swagger.v3.oas.annotations.Operation
import org.springframework.http.ResponseEntity
import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

data class PingResponse(
    val message: String,
    val user: String?
)

@RestController
@RequestMapping("/api")
class PingController() {
    @Operation(summary = "Ping", operationId = "ping")
    @GetMapping("/ping")
    fun ping(@AuthenticationPrincipal principal: JwtPayload?): ResponseEntity<PingResponse> {
        return ResponseEntity.ok(
            PingResponse(
                message = "pong",
                user = principal?.email
            )
        )
    }
}
</file>

<file path="src/main/kotlin/cl/clinipets/core/security/SecurityConfig.kt">
package cl.clinipets.core.security

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
import org.springframework.security.config.http.SessionCreationPolicy
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.security.web.SecurityFilterChain
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
class SecurityConfig(
    private val jwtAuthenticationFilter: JwtAuthenticationFilter
) {
    @Bean
    fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http
            .csrf { it.disable() }
            .sessionManagement { it.sessionCreationPolicy(SessionCreationPolicy.STATELESS) }
            .authorizeHttpRequests {
                it.requestMatchers(
                    "/",
                    "/api/auth/refresh",
                    "/api/auth/google",
                    "/api/v1/servicios/**",
                    "/api/v1/disponibilidad/**",
                    "/api/public/**",
                    "/actuator/health",
                    "/index.html",
                    "/google-login.html",
                    "/static/**",
                    "/v3/api-docs"
                ).permitAll()
                    .requestMatchers("/api/v1/reservas").authenticated()
                    .anyRequest().authenticated()
            }
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter::class.java)
        return http.build()
    }

    @Bean
    fun passwordEncoder(): PasswordEncoder = BCryptPasswordEncoder()

    @Bean
    fun authenticationManager(config: AuthenticationConfiguration): AuthenticationManager =
        config.authenticationManager
}
</file>

<file path="Dockerfile">
# ==========================================
# Etapa 1: Builder (Con caché de dependencias)
# ==========================================
FROM gradle:jdk21-alpine AS builder
WORKDIR /home/gradle/src

# 1. COPIADO INTELIGENTE: Solo archivos de configuración primero
# Al hacer esto antes de copiar el código fuente, Docker puede cachear esta capa.
COPY --chown=gradle:gradle build.gradle.kts settings.gradle.kts gradle.properties gradlew ./
COPY --chown=gradle:gradle gradle ./gradle

# Aseguramos permisos de ejecución por si vienes de Windows
RUN chmod +x gradlew

# 2. DESCARGA DE DEPENDENCIAS
# Esta es la capa que tarda tiempo. Docker la reutilizará si no tocas el build.gradle.kts
RUN ./gradlew dependencies --no-daemon

# 3. COPIAR CÓDIGO FUENTE
# Ahora sí copiamos tu código. Si cambias algo en 'src', Docker invalida desde aquí hacia abajo,
# pero ya tiene las librerías descargadas del paso anterior.
COPY --chown=gradle:gradle src ./src

# 4. COMPILAR
RUN ./gradlew bootJar --no-daemon -x test

# ==========================================
# Etapa 2: Extractor de Capas (Igual que antes)
# ==========================================
FROM eclipse-temurin:21-jre-alpine AS layers
WORKDIR /app
# Buscamos el jar generado (el nombre puede variar, el *.jar lo encuentra)
COPY --from=builder /home/gradle/src/build/libs/*.jar app.jar
RUN java -Djarmode=layertools -jar app.jar extract

# ==========================================
# Etapa 3: Imagen Final Ejecutable
# ==========================================
FROM eclipse-temurin:21-jre-alpine
WORKDIR /app

# Herramienta para Healthcheck
RUN apk add --no-cache curl

# Copiamos las capas extraídas
COPY --from=layers /app/dependencies/ ./
COPY --from=layers /app/spring-boot-loader/ ./
COPY --from=layers /app/snapshot-dependencies/ ./
COPY --from=layers /app/application/ ./

ENTRYPOINT ["java", "org.springframework.boot.loader.launch.JarLauncher"]
</file>

<file path="src/main/resources/application-prod.properties">
spring.datasource.url=jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_NAME}
spring.datasource.username=${DB_USER}
spring.datasource.password=${DB_PASSWORD}
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

spring.jpa.hibernate.ddl-auto=update
logging.level.root=INFO
logging.level.cl.clinipets=INFO
# --- JWT ---
jwt.expiration-minutes=60
jwt.refresh-expiration-hours=168
jwt.issuer=ClinipetsBackend
jwt.cookie-name=clinipets-refresh
</file>

<file path="src/main/resources/application-dev.properties">
spring.datasource.url=jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_NAME}
spring.datasource.username=${DB_USER}
spring.datasource.password=${DB_PASSWORD}
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=update

logging.level.root=INFO
logging.level.cl.clinipets=DEBUG
# --- JWT CONFIG DEV ---
jwt.expiration-minutes=60
jwt.refresh-expiration-hours=168
jwt.issuer=ClinipetsBackend
jwt.cookie-name=clinipets-refresh
# --- SECRETOS PARA DEV (Dummy Values) ---
# Valid Base64 strings (no padding needed if length is multiple of 4)
# "ThisIsASecretKeyForDevEnvironment123" -> Base64
jwt.secret=VGhpc0lzQVNlY3JldEtleUZvckRldkVudmlyb25tZW50MTIz
jwt.refresh-secret=VGhpc0lzQVJlZnJlc2hTZWNyZXRLZXlGb3JEZXZFbnZpcm9ubWVudDQ1Ng==
mercadopago.access-token=TEST-6625394767666767-052510-a93374677f0273627f02373627-123456789
app.security.n8n-key=test-n8n-key
app.n8n.webhook-url=https://hook.us1.make.com/your-test-webhook
google.client-id=test-google-client-id
</file>

<file path="src/main/resources/application.properties">
spring.application.name=clinipets-backend
# --- CONFIGURACION DE SECRETOS ---
mercadopago.access-token=${MERCADOPAGO_ACCESS_TOKEN}
app.security.n8n-key=${N8N_API_KEY}
app.n8n.webhook-url=${N8N_WEBHOOK_URL:}

# JWT Config
jwt.secret=${JWT_SECRET}
jwt.refresh-secret=${JWT_REFRESH_SECRET}
google.client-id=${GOOGLE_CLIENT_ID}
# --- CONFIGURACION TECNICA BASE ---
spring.jpa.open-in-view=false
# --- JWT CONFIG ---
jwt.issuer=ClinipetsBackend
jwt.expiration-minutes=60
jwt.refresh-expiration-hours=24

# Jackson Serialization Standard
spring.jackson.serialization.write-dates-as-timestamps=false
</file>

<file path="build.gradle.kts">
plugins {
    kotlin("jvm") version "1.9.25"
    kotlin("plugin.spring") version "1.9.25"
    id("org.springframework.boot") version "3.5.6"
    id("io.spring.dependency-management") version "1.1.7"
    kotlin("plugin.jpa") version "1.9.25"
    id("jacoco")
    id("org.sonarqube") version "7.1.0.6387"
}

group = "cl.clinipets"
version = "0.0.1-SNAPSHOT"
description = "backend"

sonar {
    properties {
        property("sonar.projectKey", "clinipets-backend")
        property("sonar.host.url", "http://homeserver.local:9000")
        property("sonar.login", System.getProperty("sonar.token"))
        }
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

configurations {
    compileOnly {
        extendsFrom(configurations.annotationProcessor.get())
    }
}

repositories { mavenCentral() }

extra["springAiVersion"] = "1.0.3"

dependencies {
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-security")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.boot:spring-boot-starter-websocket")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
    implementation("com.fasterxml.jackson.datatype:jackson-datatype-hibernate6")
    implementation("org.jetbrains.kotlin:kotlin-reflect")
    // Google ID Token verification
    implementation("com.google.api-client:google-api-client:2.8.1")
    implementation("com.google.http-client:google-http-client-jackson2:1.43.3")

    implementation("com.google.guava:guava:32.0.1-jre")

    implementation("com.mercadopago:sdk-java:2.8.0") {
        exclude(group = "org.apache.maven.plugins", module = "maven-javadoc-plugin")
    }

    // JWT
    implementation("io.jsonwebtoken:jjwt-api:0.12.6")
    implementation("org.springframework.boot:spring-boot-starter-actuator")
    runtimeOnly("io.jsonwebtoken:jjwt-impl:0.12.6")
    runtimeOnly("io.jsonwebtoken:jjwt-jackson:0.12.6")
    // springdoc: actualizar a versión compatible con Spring Boot 3.5
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.13")

    developmentOnly("org.springframework.boot:spring-boot-devtools")
    runtimeOnly("org.postgresql:postgresql")
    // H2 local y pruebas
    runtimeOnly("com.h2database:h2")
    annotationProcessor("org.springframework.boot:spring-boot-configuration-processor")
    // test
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.springframework.security:spring-security-test")
    // Usar mockito-core (sin inline)
    testImplementation("org.mockito:mockito-core:5.12.0")
    // Matchers seguros para Kotlin
    testImplementation("org.mockito.kotlin:mockito-kotlin:5.4.0")
    testRuntimeOnly("org.junit.platform:junit-platform-launcher")

    // Logging JSON
    implementation("net.logstash.logback:logstash-logback-encoder:7.4")
}

kotlin {
    compilerOptions { freeCompilerArgs.addAll("-Xjsr305=strict") }
}

allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.MappedSuperclass")
    annotation("jakarta.persistence.Embeddable")
    annotation("org.springframework.stereotype.Service")
    annotation("org.springframework.stereotype.Component")
}

tasks.withType<Test> {
    useJUnitPlatform()
    jvmArgs("-XX:+EnableDynamicAgentLoading", "-Djdk.attach.allowAttachSelf=true")
    // Mostrar más contexto al ejecutar tests
    testLogging {
        events = setOf(
            org.gradle.api.tasks.testing.logging.TestLogEvent.PASSED,
            org.gradle.api.tasks.testing.logging.TestLogEvent.SKIPPED,
            org.gradle.api.tasks.testing.logging.TestLogEvent.FAILED,
            org.gradle.api.tasks.testing.logging.TestLogEvent.STANDARD_OUT,
            org.gradle.api.tasks.testing.logging.TestLogEvent.STANDARD_ERROR
        )
        exceptionFormat = org.gradle.api.tasks.testing.logging.TestExceptionFormat.FULL
        showStandardStreams = true
    }
}

jacoco {
    toolVersion = "0.8.12"
}

tasks.named<Test>("test") {
    useJUnitPlatform()
    finalizedBy(tasks.named("jacocoTestReport"))
}

tasks.named<JacocoReport>("jacocoTestReport") {
    dependsOn(tasks.named("test"))
    reports {
        xml.required.set(true)
        csv.required.set(false)
        html.required.set(true)
    }
    classDirectories.setFrom(
        files(
            classDirectories.files.map {
                fileTree(it) {
                    exclude(
                        "**/Q*",
                        "**/*Application*",
                        "**/package-info.class"
                    )
                }
            }
        )
    )
    sourceDirectories.setFrom(files("src/main/kotlin"))
    executionData.setFrom(files("build/jacoco/test.exec"))
}

// Regla opcional de cobertura mínima
// tasks.register<JacocoCoverageVerification>("jacocoTestCoverageVerification") {
//     dependsOn(tasks.test)
//     violationRules {
//         rule { limit { minimum = BigDecimal("0.90") } }
//     }
// }
</file>

<file path="docker-compose.yml">
services:
  # 1. Base de Datos PostgreSQL
  db:
    image: postgres:15
    container_name: clinipets-db
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: ${DB_NAME}
    ports:
      - "5432:5432"
    volumes:
      - postgres-data:/var/lib/postgresql/data
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U ${DB_USER} -d ${DB_NAME}" ]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 20s
    restart: unless-stopped

  # 2. Tu Backend Spring Boot
  app:
    image: clinipets-backend:latest # O usa ${BACKEND_IMAGE} si lo prefieres
    container_name: clinipets-app
    build: .
    environment:
      # Usamos 'dev' porque es tu entorno real de trabajo
      SPRING_PROFILES_ACTIVE: dev

      # Conexión a la DB del contenedor
      SPRING_DATASOURCE_URL: jdbc:postgresql://db:5432/${DB_NAME}
      SPRING_DATASOURCE_USERNAME: ${DB_USER}
      SPRING_DATASOURCE_PASSWORD: ${DB_PASSWORD}

      # Variables de Negocio
      JWT_SECRET: ${JWT_SECRET}
      JWT_REFRESH_SECRET: ${JWT_REFRESH_SECRET}
      GOOGLE_CLIENT_ID: ${GOOGLE_CLIENT_ID}
      MERCADOPAGO_ACCESS_TOKEN: ${MERCADOPAGO_ACCESS_TOKEN}
      N8N_API_KEY: ${N8N_API_KEY}

      # ☢️ FIX NUCLEAR DE FECHAS (Vital para Android) ☢️
      # Esto obliga a Spring a devolver "2025-12-01T10:00:00Z" (Texto)
      # en lugar de [2025, 12, 1] o 17895623.00 (Números).
      SPRING_JACKSON_SERIALIZATION_WRITE_DATES_AS_TIMESTAMPS: "false"
      SPRING_JACKSON_TIME_ZONE: "UTC"

    ports:
      - "8080:8080"
    depends_on:
      db:
        condition: service_healthy
    healthcheck:
      test: "curl -f http://localhost:8080/actuator/health || exit 1"
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped

  # 3. n8n (El Orquestador)
  n8n:
    image: docker.n8n.io/n8nio/n8n
    container_name: clinipets-n8n
    ports:
      - "5678:5678"
    environment:
      - N8N_BASIC_AUTH_ACTIVE=true
      - N8N_BASIC_AUTH_USER=admin
      - N8N_BASIC_AUTH_PASSWORD=washona
      - N8N_ENCRYPTION_KEY=${N8N_ENCRYPTION_KEY}
      - WEBHOOK_URL=http://localhost:5678/
    volumes:
      - n8n_data:/home/node/.n8n
    restart: unless-stopped

  # 4. SonarQube
  sonarqube:
    image: sonarqube:community
    container_name: clinipets-sonar
    ports:
      - "9000:9000"
    environment:
      - SONAR_ES_BOOTSTRAP_CHECKS_DISABLE=true
    volumes:
      - sonar_data:/opt/sonarqube/data
      - sonar_extensions:/opt/sonarqube/extensions
      - sonar_logs:/opt/sonarqube/logs
    restart: unless-stopped

volumes:
  postgres-data:
  n8n_data:
  sonar_data:
  sonar_extensions:
  sonar_logs:
</file>

</files>
